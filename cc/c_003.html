<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">C ++/C</h6>
            <a class="dropdown-item" href="../cc/cc_001.html">C++ 의 시작</a>
            <a class="dropdown-item" href="../cc/c_001.html">C 의 시작</a>
            <a class="dropdown-item" href="../cc/c_002.html">C 의 기본</a>
            <a class="dropdown-item" href="../cc/c_003.html">자료구조</a>
            <a class="dropdown-item" href="../cc/c_004.html">Redis 분석하기</a>
            <a class="dropdown-item" href="../cc/cc_003.html"></a>
            <a class="dropdown-item" href="../cc/cc_004.html"></a>
            <a class="dropdown-item" href="../cc/cc_005.html"></a>
            <a class="dropdown-item" href="../cc/cc_006.html"></a>
            <a class="dropdown-item" href="../cc/cc_007.html"></a>
            <a class="dropdown-item" href="../cc/cc_008.html"></a>          
            <a class="dropdown-item" href="../cc/cc_009.html"></a>
            <a class="dropdown-item" href="../cc/cc_010.html"></a>
            <a class="dropdown-item" href="../cc/cc_011.html"></a>
            <a class="dropdown-item" href="../cc/cc_012.html"></a>
            <a class="dropdown-item" href="../cc/cc_013.html"></a>
            <a class="dropdown-item" href="../cc/cc_014.html"></a>
            <a class="dropdown-item" href="../cc/cc_015.html"></a>
            <a class="dropdown-item" href="../cc/cc_016.html"></a>
            <a class="dropdown-item" href="../cc/cc_017.html"></a>
            <a class="dropdown-item" href="../cc/cc_018.html"></a>
            <a class="dropdown-item" href="../cc/cc_019.html"></a>
            <a class="dropdown-item" href="../cc/cc_020.html"></a>
            <a class="dropdown-item" href="../cc/cc_021.html"></a>
            <a class="dropdown-item" href="../cc/cc_022.html"></a>
            <a class="dropdown-item" href="../cc/cc_023.html"></a>
            <a class="dropdown-item" href="../cc/cc_024.html"></a>
            <a class="dropdown-item" href="../cc/cc_025.html"></a>
            <a class="dropdown-item" href="../cc/cc_026.html"></a>
            <a class="dropdown-item" href="../cc/cc_027.html"></a>
            <a class="dropdown-item" href="../cc/cc_028.html"></a>
            <a class="dropdown-item" href="../cc/cc_029.html"></a>
            <a class="dropdown-item" href="../cc/cc_030.html"></a>
            <a class="dropdown-item" href="../cc/cc_031.html"></a>
            <a class="dropdown-item" href="../cc/cc_032.html"></a>
            <a class="dropdown-item" href="../cc/cc_033.html">알아두기</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>

          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
                자료구조 
            </div>
            <div class="card-body">
              <div class="accordion" id="accordionExample">
                  <div class="card">
                    <div class="card">
                      <div class="card-header" id="headingThree">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                            시간 복잡도 함수
                          </button>
                        </h2>
                      </div>
                      <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordionExample">
                        <div class="card-body">
                          알고리즘 분석의 2가지 측면
                          <ul>
                            <li>알고리즘 수행 시간 분석 : 시간 복잡도</li>
                            <li>알고리즘이 사용하는 기억 공간 분석 : 공간 복잡도</li>
                          </ul>
                          <hr>
                          <strong>시간 복잡도</strong><br>
                          동일한 조건에서, 똑같은 일을 하는데 알고리즘 A가 30개의 연산을 수행하였고, 알고리즘 B가 300개의 연산을 수행하였다면, 
                          알고리즘 B가 알고리즘 A보다 수행하는 연산의 수가 더 많다. 따라서 알고리즘 A가 효율적인 알고리즘이라고 할 수 있는데, 이것이 시간 복잡도의 기본 개념이다.  
                          <br>
                          연산들의 수행 횟수는 프로그램에서 주어지는 입력의 개수 n에 따라 변하게 된다. 따라서 일반적으로 연산의 수행횟수는 고정된 숫자가 아니라 n에 대한 함수가 된다. 
                          연산의 수를 입력의 개수 n의 함수로 나타낸 것을 시간 복잡도 함수라고 하고 T(n)으로 표기한다. 
                          <hr>
                          <div class="card-group">
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 A</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
sum &lt;- n * n;
                                    </code>
                                  </pre>
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 1회, 나눗셈 연산 1회 => 총 2회 
                              </div>
                            </div>
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 B</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
for i &lt;- 1 to n do  
  sum &lt;- sum + n;
                                    </code>
                                  </pre>
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 n회, 덧셈 연산 n회 => 총 2n회 
                              </div>
                            </div>
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 C</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
for i &lt;- 1 to n do 
  for j &lt;- 1 to n do 
    sum &lt;- sum + 1;                                      
                                    </code>
                                  </pre>                                  
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 n*n, 덧셈 연산 n*n => 2n^2 회 
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>  
                    <div class="card">
                      <div class="card-header" id="heading7">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse7" aria-expanded="false" aria-controls="collapse7">
                            빅오 표기법 
                          </button>
                        </h2>
                      </div>
                      <div id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#accordionExample">
                        <div class="card-body">
                          일반적으로 입력의 개수 n과 시간 복잡도 함수 T(n)의 관계는 상당히 복잡할 수 있다. 하지만 자료가 많은 경우에는 차수가 가장 큰 항이 가장 영향을 크게 미치고
                          다른 항들은 상대적으로 무시될 수있다. 
                          예를 들어 <br>
                          <pre class="C" >
                            <code>
T(n) = n^3 + n + 1
                            </code>
                          </pre>
                          위의 항에서 n이 10000일 때, n^3의 값이 전체의 값을 주도한다는 것을 알 수 있다. 따라서 시간 복잡도 함수에서 차수가 가장 큰 항만을 고려하면 충분하다. <br>
                          시간 복잡도 함수 에서 중요한 것은 n이 증가하였을 때, 연산의 총횟수가 n에 비례하여 증가하는지, n^2에 비례하여 증가하는지, 아니면 다른 추세를 가지는지가 더 중요하다. <br>
                          정확한 연산의 개수 보다 알고리즘의 일반적인 증가 추세가 더 중요하다. 2n과 4n + 1의 차이는 n이 커지게 되면 미미하다고 할 수 있다. 따라서 시간 복잡도 함수에서 불필요한 정보를 
                          제거하여 알고리즘 분석을 더욱 쉽게 할 목적으로 시간복잡도를 표시하는 방법을 빅오 표기법이라고 한다. 즉 알고리즘이 n에 비례하는 수행 시간을 가진다고 말하는 대신에 알고리즘 A의 
                          시간 복잡도 합수가 O(n)이라고 한다. 
                          <hr>
                          <div class="alert alert-primary" role="alert">
                            빅오표기법 : 정의 
                            <hr>
                            두 개의 함수 f(n)과 g(n)이 주어졌을 때 모든 n > n0에 대해여 |f(n)| &lt;= c|g(n)|을 만족하는 2개의 상수 c와 n0가 존재하면 f(n)=O(g(n)) 이다. 
                          </div>
                          빅오 표기법에서 중요한 것은 알고리즘의 일반적인 증가 추세가 중요하다는 것이다. 
                          <div class="alert alert-primary" role="alert">
                            빅오 표기법 예제 
                            <hr>
                            f(n)=5이면 O(1)이다. <br>
                            f(n)=2n+1이면 O(n)이다. <br>
                            f(n)=3n^2+100이면 O(n^2)이다. <br>
                            f(n)=5*2^n이면 O(n^2)이다. <br>
                            f(n)=5*2^n+10n^2 + 100이면 O(2^n)이다. <br>
                            f(n)=7n-3이면 O(n) <br>
                            8n^2logn + 5n^2 + n = O(n^2logn) <br>
                          </div>
                          기본 연산의 횟수가 다향식으로 표현되었을 경우 다항식의 최고차항만을 남기고 다른 항들과 상수항을 버리는 것이다. <br>
                          최고 차항의 계수도 버리고 단치 최고차항의 차수만을 이용한다. 
                          <hr>
                          <ul>
                            <li>O(1) : 상수형</li>
                            <li>O(logn) : 로그형</li>
                            <li>O(n) : 선형</li>
                            <li>O(nlogn) : 선형 로그형</li>
                            <li>O(n^2) : 2차형 </li>
                            <li>O(n^3) : 3차형</li>
                            <li>O(2^n) : 지수형</li>
                            <li>O(n!) : 팩토리얼형</li>
                          </ul>
                          <hr>
                          또한 위의 순서대로 알고리즘의 수행시간에 걸리는 순서도 같이 확인할 수 있다. 
                          아래로 내려가면 갈수록 걸리는 시간이 커진다. 
                          <hr>
                          <img src="./bigograph.PNG" class="img-fluid" alt="" srcset="">
                          <hr>
                          빅오 표기법 이외의 표기법
                          <hr>
                          <ul>
                            <li>빅오메가 표기법 : 어떤 함수의 하한을 표기하는 방법 </li>
                            <li>빅세타 표기법 : 동일한 함수로 상한과 하한을 만들 수 있는 경우 </li>
                          </ul>
                          표기법 중에 가장 정밀한 것은 빅세타 표기법이다. 
                          <hr>
                          똑같은 알고리즘도 주어지는 입력의 집합에 따라 다른 수행 시간을 보일 수 있다. 즉 특정한 자료 집합이 주어지면 다른 자료 집합보다 더 빨리 수행할 수 있다. 
                          <ul>
                            <li>최악의 경우는 자료집합 중에서 알고리즘의 수행시간이 가장  오래 걸리는 경우이다. </li>
                            <li>최선의 경우는 수행시간이 가장 적은 경우이다. </li>
                            <li>평균적인 경우는 알고리즘의 모든 입력 고려하고 각 입력이 발생하는 확률을 고려하여 평균적인 수행시간이 의미한다. </li>
                          </ul>
                          <hr>
                          우리가 구하려는 데이터의 자료구조에 따라 빅오 표기법의 복잡도가 상이해질 수 있는데, 아래의 코드를 보면 
                          <pre class="C" >
                            <code>
// 최선의 경우는 찾고자 하는 숫자가 배열의 맨 처음에 있는 경우이다. 따라서 빅오 표기법은 O(1)
// 최악의 경우는 찾고자 하는 숫자가 맨 마지막이 있는 경우이다. 따라서 빅오 표기법으로는 O(n)
int seq_search(int list[], int key ){
  int i;
  for ( i = 0; i&lt; n ; i ++){
    if(list[i] == key){
      return i;
    }
  }
}
                            </code>
                          </pre>
                        </div>
                      </div>
                    </div> 
                    
                <div class="card">
                  <div class="card-header" id="heading10">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse10" aria-expanded="false" aria-controls="collapse10">
                        순환 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse10" class="collapse" aria-labelledby="heading10" data-parent="#accordionExample">
                    <div class="card-body">
                      어떤 알고리즘이나  함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법이다. 
                      <hr>
                      <strong>순환의 예</strong>
                      순환은 본질적으로 순환적인 문제나 그러한 자료구조를 다루는 프로그램에 적합하다. 
                      <pre class="C" >
                        <code>
int factorial(int n){
  if( n &lt;= 1) return(1);
  else return (n*factorial(n-1))
}                     

// 위의 코드를 아래의 Factorial 기준대로 정의하는 방법 

/*
  factorial(3) = 3 * factorial(2);
               = 3 * 2 * factorial(1);
               = 3 * 2 * 1
               = 3 * 2
               = 6
*/
                        </code>
                      </pre>
                      <hr>
                      <strong>순환의 동작 원리</strong>
                      <hr>
                      순환을 이해하기 위하여 먼저 함수 호출의 과정을 살펴보면, 프로그래밍 언어에서 하나의 함수가 자기 자신을 다시 호출하는 것은 다름 함수를 호출하는 것과 동일하다. 즉 복귀 주소가 시스템 스택에 저장되고
                      호출되는 함수를 위한 매개변수와 지역 변수를 스택으로부터 할당 받는다. 이러한 함수를 위한 시스템 스택에서의 공간을 활성 레코드라 한다. 이러한 준비가 끝나면 호출된 함수의 시작위치로 점프하여 수행을 시작한다. 
                      만약 호출한 함수가 끝나게 되면 시스템 스택에서 복귀주소를 추출하여 호출한 함수로 되돌아가게 된다. 
                      <hr>
                      <strong>순환 알고리즘의 구조</strong>
                      <pre class="C" >
                        <code>
int factorial( int n )
{
  if ( n &lt;= 1 ) return (1);

  return ( n * factorial(n-1));
}
                        </code>
                      </pre>
                      <hr>
                      <strong>순환 &lt;-> 반복</strong>
                      <hr>
                      반복이란 for나 while 등의 반복구조로 되풀이 하는 방법이다. 반복을 제어하는 변수를 사용하여 일정횟수 동안 반복 시킬수도 있고 어떤 조건이 만족될 때까지 반복시킬 수도 있다. 
                      반복은 간명하고 효율적으로 되풀이를 구현하는 방법이다. 
                      반면에 때로는 반복을 사용하게 되면 지나치게 복잡해지는 문제들도 존재한다. 이런 경우에는 순환이 좋은 해결책이 될 p47수 있다. 순환은 주어진 문제를 해결하기 위하여 자신을 다시 호출하여 
                      수행하는 방식이다. 순환은 본질적으로 순환적인 문제나 그러한 자료구조를 다루는 프로그램에 적합하다. 
                      <br>
                      문제의 크기가 순환이 진행될수록 작아지는 것에 유의해야 한다. 
                      <br>
                      기본적으로 반복과 순환은 문제 해결 능력이 같으며 많은 경우에 순환 알고리즘을 반복 버전으로 , 반복 알고리즘을 순환 버전으로 바꾸어 쓸 수 있다. 특히 순환 호출이 끝에서 이루어지는 순환을 꼬리 순환이라고 하는데, 
                      이를 반복 알고리즘으로 쉽게 바꾸어 쓸 수 있다. 
                      <hr>
                      <strong>순환의 원리</strong>
                      <hr>
                      분할 정복 : 주어진 문제를 더 작은 동일한 문제들로 분해하여 해결하는 방법을 분할 정복이라 한다. <br>
                      순환은 알고리즘 정의가 순환적으로 되어 있는 경우에 유리한 방법이다. 예를 들어 팩토리얼 함수 계산, 피보나치 수열, 이항계수 계산, 이진 트리 알고리즘, 이진 탐색, 하노이 탑 문제들은 순환 알고리즘을 쓰는 것이 자연스러운 알고리즘이다. 
                      <hr>
                      <strong>순환 알고리즘의 성능</strong><br>
                      순환 알고리즘과 반복 알고리즘의 시간 복잡도는 같지만 순환 호출의 경우 여분의 기억공간이 더 필요하고 또한 함수를 호출하기 위해서는, 함수의 매개변수들을 
                      스택에 저장하는 것과 같은 사전 작업이 상당히 필요하다. 따라서 수행시간도 더 걸린다. 결론적으로 순환 알고리즘은 이해하기 쉽다는 것과 쉽게 프로그램 할 수 있다는 장점이 있는 
                      대신 수행 시간과 기억 공간의 사용에 있어서는 비효율적인 경우가 많다. 
                      <hr>
                      거듭제곱 값 계산 
                      <pre class="C" >
                        <code>
// 반복에 의한 방식                           
double slow_power(double x, int n){
  int i;
  double result = 1.0;

  for( i = 0; i &lt; n; i ++ ){
    return = result * x;
    return (result);
  }
}
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
// 순환에 의한 방식      
// 한번의 호출 할 때마다 문제의 크기는 약 절반으로 줄어든다.                      
power(x , n) : 
  if n == 0 
    then return 1;
  else if n이 짝수 
    then return power(x^2, n/2);
  else if n이 홀수 
    then return x * power(x^2, (n-1)/2);
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
// 순환적인 거듭 제곱 계산 
// 순환을 사용하게 되면 단순하게 작성이 가능하며 가독성이 높아진다. 그러나 똑같은 계산을 몇번씩 반복한다면 아주 단순한 경우라 할지라도 
// 계산 시간이 엄청나게 길어질 수 있다. 
double power(double x, int n ){
  if ( n == 0) return 1;
  else if ( (n%2) == 0) 
    return power(x*X, n/2 )
  else return x * power(x*x, (n-1)/2);
}
                        </code>
                      </pre>
                      <hr>
                      <strong>피보나치 수열</strong> <br>
                      <img src="./pibonacci_sequence.PNG" class="img-thumbnail" alt="" srcset=""> <br>
                      피보나치 수열은 이탈리아 수학자가 발견한 수열로서 한 쌍의 토끼가 번식하는 상황을 수열로 만든 것이다. 
                      <br>
                      <pre class="C" >
                        <code>
// 순환적인 피보나치 수열 계산
int fib(int n){
  if ( n == 0) return 0;
  if ( n == 1) return 1;
  return ( fib(n-1) + fib(n-2));
}
                        </code>
                      </pre>
                      위의 코드는 단순하고 이해하기 쉽지만 굉장히 비효율 적인 코드이다. 
                      fib(6)을 구하기 위해서  fib() 함수가 25번이나 호출되는 것에 유의해야 한다. 근본적인 이유는 중간에 계산되었던 값을 기억하지 않고 
                      다시 계산하기 때문이다. 
                      <br>
                      T(n) = T(n-1) + T(n-2) + C 의 순환적인 수식을 이용하면 시간 복잡도 O(2^n)이 도출된다. 
                      이것은 O(2^n)의 복잡도 패턴이라 할 수 있다. 
                      피보나치 수열을 계산하는데 순환을 사용하는 것이 아닌 반복을 사용하게 되면 제일 좋은 결과를 얻을 수 있었다. 
                      <pre class="C" >
                        <code>
int fib_iter(int n){
  if ( n == 0 ) return 0;
  if ( n == 1 ) return 1;

  int pp = 0;
  int p = 1;
  int result = 0;

  for( int i = 2 ; i &lt; n; i ++){
    result = p + pp;
    pp = p;
    p = result;
  }
  return result 
}
                        </code>
                      </pre>
                      <hr>
                      <strong>하노이 탑</strong>
                      순환의 사용에 가장 적합한 예제가 바로 하노이 탑 문제이다. <br>
                      하노의 탑을 해결하기 위한 알고리즘 <br>
                      <pre class="C" >
                        <code>
// 막대 from에 쌓여있는 n개의 원판을 막대 tmp를 사용하여 막대  to로 옮긴다. 
void hanoi_tower(int n, char from, char tmp, char to ){
  if ( n == 1) {
    from에 있는 한 개의 원판을 to로 옮긴다. 
  } else {
    1. from의 맨 밑의 원판을 제외한 나머지 원판을 tmp로 옮긴다. 
    2. from에 있는 한 개의 원판을 to로 옮긴다. 
    3. tmp의 원판들을 to로 옮긴다. 
  }
}

// 코드 예제
#include &lt;stdio.h>
void hanoi_tower( int n , char from, char tmp, char to ){
  if ( n ==  1) printf("원판 1을 %C에서 %c으로 옮긴다. \n" , from, to );
  else {
    hanoi_tower( n - 1, from, to tmp );
    printf("원판 %d 을 %C에서 %c으로 옮긴다. \n" , from, to );
    hanoi_tower( n - 1, tmp, from, to );
  }
}

int main(void){
  hanoi_tower( 4, 'A' , 'B' , 'C');
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <pre class="C" >
                        <code>
//  순환 호출이 맨끝에서 이루어지는 형태의 순환으로, 꼬리 순환의 경우, 알고리즘은 쉽게 반복적인 형태로 변환이 가능하다.                           
return n*factorial(n - 1);

// 머리 순환(head recursion)의 경우나 방금 살펴본 하노이 탑의 문제 처럼 여러 군데에서 자기 자신을 호출하는 경우는 쉽게 반복적인 코드로 바꿀 수 없다. 
return factorial(n - 1)*n;
                        </code>
                      </pre>

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading11">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse11" aria-expanded="false" aria-controls="collapse11">
                        배열, 구조체, 포인터 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse11" class="collapse" aria-labelledby="heading11" data-parent="#accordionExample">                        
                    <div class="card-body">
                      <strong>배열</strong><br>
                      <pre class="C" >
                        <code>
객체 : &lt; 인덱스, 값 > 쌍의 집합 
연산 : 
  - create(size) ::= size개의 요소를 저장할 수 있는 배열 생성 
  - get(A, i) ::= 배열 A의 i 번째 요소 반환. 
  - set(A, i, v) ::= 배열 A의 i 번째 위치에 값 v 저장. 
                        </code>
                      </pre>
                      컴파일러에서 배열 요소에 대한 메모리 주소 구현 방식 <br>
                      <ul>
                        <li>list[0] : 기본주소=base</li>
                        <li>list[1] : base + 1*sizeof(int)</li>
                        <li>...</li>
                      </ul>
                      우리가 프로그램에서 list[i]라고 적으면 컴파일러는 주소 base + i*sizeof(int)에 있는 값을 가져온다. 
                      <hr>
                      <strong>구조체</strong><br>
                      복잡한 객체에는 다양한 타입의 데이터들이 한데 묶여져서 있다. 배열이 타입이 같은 데이터의 모임이라면 구조체는 타입이 다른 데이터를 묶는 방법이다. <br>
                      <pre class="C" >
                        <code>
struct 구조체이름 {
  항목1;
  항목2;
  ...
}

// 구조체 변수 선언 방식 
struct 구조체이름 구조체변수;
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
#include &lt;stdio.h>

typedef struct studentTag {
  char name[10];
  int age;
  double gpa;
} student; 

int main(void) {
  student a = { "kim", 30, 4.3 };
  student b = { "park", 21, 4.2 };
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>배열의 응용  : 다항식</strong><br>
                      <ul>
                        <li>
                          <strong>첫번째 방법</strong><br>
                          <pre class="C" >
                            <code>
10x^5 + 0 * x^4 + 0 * x^3 + 0 * x^2 + 6 * x + 3 


#define MAX_DEGREE 101 

typedef struct {
  int degree;
  float coef[MAX_DEGREE];
} polynomial 

polynomial a = { 5, { 10, 0 , 0, 0, 6 , 3}}
                            </code>
                          </pre>
                        </li>
                        <li>
                          <strong>두번째 방법</strong><br>
                          <pre class="C" >
                            <code>
#define MAX_TERMS 101

typedef struct {
  float coef;
  int expon;
} terms[MAX_TERMS];
int avail; 

terms[MAX_TERMS] = {{ 8,3 }, { 7,1 } , { 1, 0 } , { 10, 3 } , { 3 , 2 } , { 1 , 0 } }
                            </code>
                          </pre>
                        </li>
                        <li>
                          <strong>희소 행렬</strong><br>
                          <pre class="C" >
                            <code>
// 희소 행렬의 표현 방법 #1
#define MAX_ROWS 100
#define MAX_COLS 100
int matrix[MAX_ROWS][MAX_COLS];


// 희소 행렬의 표현방법 #2
struct matrix {
  int x,
  int y, 
  char value
}

int main(){
  struct matrix m[100] = { { .x = 1 , .y= 1 , .value = 'G' }, ... }
}
                            </code>
                          </pre>
                        
                        </li>
                        <li>
                          <strong>전치 행렬 계산법</strong>
                          <pre class="C" >
                            <code>
#define ROWS 3
#define COLS 3

// 행렬 전치 함수 - 첫번째 방식 
void matrix_transpose(int A[ROWS][COLS], int B[ROWS][COLS]){
  for ( int r = 0 ; r &lt; ROWS ; r ++){
    for ( int c = 0 ; c &lt; COLS ; c ++){
      B[c][r] = A[r][c];
    }
  }
}

// 행렬 전치 함수 - 두번째 방식 
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_TERMS 100
typedef struct {
  int row;
  int col;
  int value;
}

typedef struct SparseMatrix {
  element data[MAX_TERMS];
  int rows;
  int cols;
  int terms;
} SparseMatrix;

SparseMatrix matrix_transpose2(SparseMatrix a){
  SparseMatrix b;

  int bindex;
  b.rows = a.rows;
  b.cols = a.cols;
  b.terms = a.terms;

  if(a.terms > 0){
    bindex = 0;
    for ( int c = 0 ; c &lt; a.cols ; r ++){
      for ( int i = 0 ; i &lt; a.terms ; i ++){
        if(a.data[i].col == c){
          b.data[bindex].row = a.data[i].col;
          b.data[bindex].col = a.data[i].row;
          b.data[bindex].value = a.data[i].value;
        }
      }
    }
  }
  return b;
}
                            </code>
                          </pre>
                        </li>
                      </ul>
                      <strong>Pointer</strong><br>
                      포인터는 다른 변수의 주소를 가지고 있는 변수이다. 모든 변수는 메모리 공간에 저장되고 메모리의 각 바이트에는 주소가 매겨져 있다. 
                      이 주소가 포인터에 저장된다. 주소는 컴퓨터에 따라 다를 수 있으므로 포인터 변수는 정확한 숫자보다는 그냥 화살표로 그려진다. 
                      <ul>
                        <li>널 포인터</li>
                        <li></li>
                      </ul>
                      배열과 포인터의 관계 : 배열의 이름은 배열의 시작부분을 가리키는 포인터이다. <br>
                      배열의 이름이 점선으로 그려져 있는 이유는 실제로 컴파일러가 배열의 이름에 공간을 할당하지는 않기 때문이다. 대신에 배열의 이름이 있는 곳을 배열의 첫번째 요소의 
                      주소로 대치한다. 따라서 배열의 이름이 포인터이기 때문에 배열이 함수의 매개변수로 전달 될 때 사실을 포인터가 전달되는 것이다. 
                      <hr>
                      <strong>동적 메모리 할당</strong>
                      <pre class="C" >
                        <code>
int *p;
// malloc() 함수가 반환했던 포인터 값을 잊어버리면 안된다는 것이다. 포인터 값을 잊어버리면 동적 메모리를 반환할 수 없다. 
// malloc()은 시스템의 메모리가 부족해서 요구된 메머리를 할당할 수 없으면 NULL을 반환한다. 
p = ( int * )malloc(sizeof(int));
*p = 1000;
free(p);                          
                        </code>
                      </pre>
                      동적 메모리가 할당되는 공간을 히프라고 한다. 히프는 운영체제가 사용되지 않는 메모리 공간을 모아 놓은 곳이다. 필요한 만큼 할당을 받고 또 필요한 대에 사용하고 반납하기 때문에 
                      메모리를 매우 효율적으로 사용할 수 있다. 
                      <hr>
                      <strong>구조체와 포인터</strong><br>
                      우리는 구조체에 포인터를 선언하고 포인터를 통하여 구조체 멤버에 접근할 수 있다. 여기에서 하나 주의할 것은 포인터를 통하여 구조체의 멤버에 접근하는 편리한 표기법 "->"이다. <br>
                      <pre class="C" >
                        <code>
// (*ps).i 보다 ps -> i 라고 쓰는 것이 더 편리하다. 

typedef struct studentTag {
  char name[10];
  int age;
  double gpa;
} student;

int main(void) {
  student s*;

  s = (student *)malloc(sizof(student));
  if ( s == NULL ){
    fprintf(stderr, "메모리가 부족해서 할당할 수 없습니다. \n");
    exit(1);
  } 

  strcpy(s -> name,  "Park");
  s -> age = 20;

  free(s);
  return 0;
}

                        </code>
                      </pre>

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading13">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse13" aria-expanded="false" aria-controls="collapse13">
                      
                      </button>
                    </h2>
                  </div>
                  <div id="collapse13" class="collapse" aria-labelledby="heading13" data-parent="#accordionExample">
                    <div class="card-body">
                      <pre class="C" >
                        <code>

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading14">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse14" aria-expanded="false" aria-controls="collapse14">
                       
                      </button>
                    </h2>
                  </div>
                  <div id="collapse14" class="collapse" aria-labelledby="heading14" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading15">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse15" aria-expanded="false" aria-controls="collapse15">
                     
                      </button>
                    </h2>
                  </div>
                  <div id="collapse15" class="collapse" aria-labelledby="heading15" data-parent="#accordionExample">
                    <div class="card-body">
                     
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading16">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse16" aria-expanded="false" aria-controls="collapse16">
                         
                      </button>
                    </h2>
                  </div>
                  <div id="collapse16" class="collapse" aria-labelledby="heading16" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading17">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse17" aria-expanded="false" aria-controls="collapse17">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse17" class="collapse" aria-labelledby="heading17" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading18">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse18" aria-expanded="false" aria-controls="collapse18">
                 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse18" class="collapse" aria-labelledby="heading18" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading19">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse19" aria-expanded="false" aria-controls="collapse19">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse19" class="collapse" aria-labelledby="heading19" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading9">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse9" aria-expanded="false" aria-controls="collapse9">
                         
                      </button>
                    </h2>
                  </div>
                  <div id="collapse9" class="collapse" aria-labelledby="heading9" data-parent="#accordionExample">
                    <div class="card-body">

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading1700">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#heading1700" aria-expanded="false" aria-controls="heading1700">
                        
                      </button>                    
                    </h2>
                  </div>
                  <div id="heading1700" class="collapse" aria-labelledby="heading1700" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
              </div>                  
            </div>
            <div class="card-footer small text-muted"></div>
          </div>
          
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
    

    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

 

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>
  </body>

</html>
