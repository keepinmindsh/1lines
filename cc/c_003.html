<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">C ++/C</h6>
            <a class="dropdown-item" href="../cc/cc_001.html">C++ 의 시작</a>
            <a class="dropdown-item" href="../cc/c_001.html">C 의 시작</a>
            <a class="dropdown-item" href="../cc/c_002.html">C 의 기본</a>
            <a class="dropdown-item" href="../cc/c_003.html">자료구조</a>
            <a class="dropdown-item" href="../cc/c_004.html">Redis 분석하기</a>
            <a class="dropdown-item" href="../cc/cc_003.html"></a>
            <a class="dropdown-item" href="../cc/cc_004.html"></a>
            <a class="dropdown-item" href="../cc/cc_005.html"></a>
            <a class="dropdown-item" href="../cc/cc_006.html"></a>
            <a class="dropdown-item" href="../cc/cc_007.html"></a>
            <a class="dropdown-item" href="../cc/cc_008.html"></a>          
            <a class="dropdown-item" href="../cc/cc_009.html"></a>
            <a class="dropdown-item" href="../cc/cc_010.html"></a>
            <a class="dropdown-item" href="../cc/cc_011.html"></a>
            <a class="dropdown-item" href="../cc/cc_012.html"></a>
            <a class="dropdown-item" href="../cc/cc_013.html"></a>
            <a class="dropdown-item" href="../cc/cc_014.html"></a>
            <a class="dropdown-item" href="../cc/cc_015.html"></a>
            <a class="dropdown-item" href="../cc/cc_016.html"></a>
            <a class="dropdown-item" href="../cc/cc_017.html"></a>
            <a class="dropdown-item" href="../cc/cc_018.html"></a>
            <a class="dropdown-item" href="../cc/cc_019.html"></a>
            <a class="dropdown-item" href="../cc/cc_020.html"></a>
            <a class="dropdown-item" href="../cc/cc_021.html"></a>
            <a class="dropdown-item" href="../cc/cc_022.html"></a>
            <a class="dropdown-item" href="../cc/cc_023.html"></a>
            <a class="dropdown-item" href="../cc/cc_024.html"></a>
            <a class="dropdown-item" href="../cc/cc_025.html"></a>
            <a class="dropdown-item" href="../cc/cc_026.html"></a>
            <a class="dropdown-item" href="../cc/cc_027.html"></a>
            <a class="dropdown-item" href="../cc/cc_028.html"></a>
            <a class="dropdown-item" href="../cc/cc_029.html"></a>
            <a class="dropdown-item" href="../cc/cc_030.html"></a>
            <a class="dropdown-item" href="../cc/cc_031.html"></a>
            <a class="dropdown-item" href="../cc/cc_032.html"></a>
            <a class="dropdown-item" href="../cc/cc_033.html">알아두기</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>

          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
                자료구조 
            </div>
            <div class="card-body">
              <div class="accordion" id="accordionExample">
                  <div class="card">
                    <div class="card">
                      <div class="card-header" id="headingThree">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                            시간 복잡도 함수
                          </button>
                        </h2>
                      </div>
                      <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordionExample">
                        <div class="card-body">
                          알고리즘 분석의 2가지 측면
                          <ul>
                            <li>알고리즘 수행 시간 분석 : 시간 복잡도</li>
                            <li>알고리즘이 사용하는 기억 공간 분석 : 공간 복잡도</li>
                          </ul>
                          <hr>
                          <strong>시간 복잡도</strong><br>
                          동일한 조건에서, 똑같은 일을 하는데 알고리즘 A가 30개의 연산을 수행하였고, 알고리즘 B가 300개의 연산을 수행하였다면, 
                          알고리즘 B가 알고리즘 A보다 수행하는 연산의 수가 더 많다. 따라서 알고리즘 A가 효율적인 알고리즘이라고 할 수 있는데, 이것이 시간 복잡도의 기본 개념이다.  
                          <br>
                          연산들의 수행 횟수는 프로그램에서 주어지는 입력의 개수 n에 따라 변하게 된다. 따라서 일반적으로 연산의 수행횟수는 고정된 숫자가 아니라 n에 대한 함수가 된다. 
                          연산의 수를 입력의 개수 n의 함수로 나타낸 것을 시간 복잡도 함수라고 하고 T(n)으로 표기한다. 
                          <hr>
                          <div class="card-group">
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 A</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
sum &lt;- n * n;
                                    </code>
                                  </pre>
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 1회, 나눗셈 연산 1회 => 총 2회 
                              </div>
                            </div>
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 B</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
for i &lt;- 1 to n do  
  sum &lt;- sum + n;
                                    </code>
                                  </pre>
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 n회, 덧셈 연산 n회 => 총 2n회 
                              </div>
                            </div>
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 C</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
for i &lt;- 1 to n do 
  for j &lt;- 1 to n do 
    sum &lt;- sum + 1;                                      
                                    </code>
                                  </pre>                                  
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 n*n, 덧셈 연산 n*n => 2n^2 회 
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>  
                    <div class="card">
                      <div class="card-header" id="heading7">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse7" aria-expanded="false" aria-controls="collapse7">
                            빅오 표기법 
                          </button>
                        </h2>
                      </div>
                      <div id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#accordionExample">
                        <div class="card-body">
                          일반적으로 입력의 개수 n과 시간 복잡도 함수 T(n)의 관계는 상당히 복잡할 수 있다. 하지만 자료가 많은 경우에는 차수가 가장 큰 항이 가장 영향을 크게 미치고
                          다른 항들은 상대적으로 무시될 수있다. 
                          예를 들어 <br>
                          <pre class="C" >
                            <code>
T(n) = n^3 + n + 1
                            </code>
                          </pre>
                          위의 항에서 n이 10000일 때, n^3의 값이 전체의 값을 주도한다는 것을 알 수 있다. 따라서 시간 복잡도 함수에서 차수가 가장 큰 항만을 고려하면 충분하다. <br>
                          시간 복잡도 함수 에서 중요한 것은 n이 증가하였을 때, 연산의 총횟수가 n에 비례하여 증가하는지, n^2에 비례하여 증가하는지, 아니면 다른 추세를 가지는지가 더 중요하다. <br>
                          정확한 연산의 개수 보다 알고리즘의 일반적인 증가 추세가 더 중요하다. 2n과 4n + 1의 차이는 n이 커지게 되면 미미하다고 할 수 있다. 따라서 시간 복잡도 함수에서 불필요한 정보를 
                          제거하여 알고리즘 분석을 더욱 쉽게 할 목적으로 시간복잡도를 표시하는 방법을 빅오 표기법이라고 한다. 즉 알고리즘이 n에 비례하는 수행 시간을 가진다고 말하는 대신에 알고리즘 A의 
                          시간 복잡도 합수가 O(n)이라고 한다. 
                          <hr>
                          <div class="alert alert-primary" role="alert">
                            빅오표기법 : 정의 
                            <hr>
                            두 개의 함수 f(n)과 g(n)이 주어졌을 때 모든 n > n0에 대해여 |f(n)| &lt;= c|g(n)|을 만족하는 2개의 상수 c와 n0가 존재하면 f(n)=O(g(n)) 이다. 
                          </div>
                          빅오 표기법에서 중요한 것은 알고리즘의 일반적인 증가 추세가 중요하다는 것이다. 
                          <div class="alert alert-primary" role="alert">
                            빅오 표기법 예제 
                            <hr>
                            f(n)=5이면 O(1)이다. <br>
                            f(n)=2n+1이면 O(n)이다. <br>
                            f(n)=3n^2+100이면 O(n^2)이다. <br>
                            f(n)=5*2^n이면 O(n^2)이다. <br>
                            f(n)=5*2^n+10n^2 + 100이면 O(2^n)이다. <br>
                            f(n)=7n-3이면 O(n) <br>
                            8n^2logn + 5n^2 + n = O(n^2logn) <br>
                          </div>
                          기본 연산의 횟수가 다향식으로 표현되었을 경우 다항식의 최고차항만을 남기고 다른 항들과 상수항을 버리는 것이다. <br>
                          최고 차항의 계수도 버리고 단치 최고차항의 차수만을 이용한다. 
                          <hr>
                          <ul>
                            <li>O(1) : 상수형</li>
                            <li>O(logn) : 로그형</li>
                            <li>O(n) : 선형</li>
                            <li>O(nlogn) : 선형 로그형</li>
                            <li>O(n^2) : 2차형 </li>
                            <li>O(n^3) : 3차형</li>
                            <li>O(2^n) : 지수형</li>
                            <li>O(n!) : 팩토리얼형</li>
                          </ul>
                          <hr>
                          또한 위의 순서대로 알고리즘의 수행시간에 걸리는 순서도 같이 확인할 수 있다. 
                          아래로 내려가면 갈수록 걸리는 시간이 커진다. 
                          <hr>
                          <img src="./bigograph.PNG" class="img-fluid" alt="" srcset="">
                          <hr>
                          빅오 표기법 이외의 표기법
                          <hr>
                          <ul>
                            <li>빅오메가 표기법 : 어떤 함수의 하한을 표기하는 방법 </li>
                            <li>빅세타 표기법 : 동일한 함수로 상한과 하한을 만들 수 있는 경우 </li>
                          </ul>
                          표기법 중에 가장 정밀한 것은 빅세타 표기법이다. 
                          <hr>
                          똑같은 알고리즘도 주어지는 입력의 집합에 따라 다른 수행 시간을 보일 수 있다. 즉 특정한 자료 집합이 주어지면 다른 자료 집합보다 더 빨리 수행할 수 있다. 
                          <ul>
                            <li>최악의 경우는 자료집합 중에서 알고리즘의 수행시간이 가장  오래 걸리는 경우이다. </li>
                            <li>최선의 경우는 수행시간이 가장 적은 경우이다. </li>
                            <li>평균적인 경우는 알고리즘의 모든 입력 고려하고 각 입력이 발생하는 확률을 고려하여 평균적인 수행시간이 의미한다. </li>
                          </ul>
                          <hr>
                          우리가 구하려는 데이터의 자료구조에 따라 빅오 표기법의 복잡도가 상이해질 수 있는데, 아래의 코드를 보면 
                          <pre class="C" >
                            <code>
// 최선의 경우는 찾고자 하는 숫자가 배열의 맨 처음에 있는 경우이다. 따라서 빅오 표기법은 O(1)
// 최악의 경우는 찾고자 하는 숫자가 맨 마지막이 있는 경우이다. 따라서 빅오 표기법으로는 O(n)
int seq_search(int list[], int key ){
  int i;
  for ( i = 0; i&lt; n ; i ++){
    if(list[i] == key){
      return i;
    }
  }
}
                            </code>
                          </pre>
                        </div>
                      </div>
                    </div> 
                    
                <div class="card">
                  <div class="card-header" id="heading10">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse10" aria-expanded="false" aria-controls="collapse10">
                        순환 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse10" class="collapse" aria-labelledby="heading10" data-parent="#accordionExample">
                    <div class="card-body">
                      어떤 알고리즘이나  함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법이다. 
                      <hr>
                      <strong>순환의 예</strong>
                      순환은 본질적으로 순환적인 문제나 그러한 자료구조를 다루는 프로그램에 적합하다. 
                      <pre class="C" >
                        <code>
int factorial(int n){
  if( n &lt;= 1) return(1);
  else return (n*factorial(n-1))
}                     

// 위의 코드를 아래의 Factorial 기준대로 정의하는 방법 

/*
  factorial(3) = 3 * factorial(2);
               = 3 * 2 * factorial(1);
               = 3 * 2 * 1
               = 3 * 2
               = 6
*/
                        </code>
                      </pre>
                      <hr>
                      <strong>순환의 동작 원리</strong>
                      <hr>
                      순환을 이해하기 위하여 먼저 함수 호출의 과정을 살펴보면, 프로그래밍 언어에서 하나의 함수가 자기 자신을 다시 호출하는 것은 다름 함수를 호출하는 것과 동일하다. 즉 복귀 주소가 시스템 스택에 저장되고
                      호출되는 함수를 위한 매개변수와 지역 변수를 스택으로부터 할당 받는다. 이러한 함수를 위한 시스템 스택에서의 공간을 활성 레코드라 한다. 이러한 준비가 끝나면 호출된 함수의 시작위치로 점프하여 수행을 시작한다. 
                      만약 호출한 함수가 끝나게 되면 시스템 스택에서 복귀주소를 추출하여 호출한 함수로 되돌아가게 된다. 
                      <hr>
                      <strong>순환 알고리즘의 구조</strong>
                      <pre class="C" >
                        <code>
int factorial( int n )
{
  if ( n &lt;= 1 ) return (1);

  return ( n * factorial(n-1));
}
                        </code>
                      </pre>
                      <hr>
                      <strong>순환 &lt;-> 반복</strong>
                      <hr>
                      반복이란 for나 while 등의 반복구조로 되풀이 하는 방법이다. 반복을 제어하는 변수를 사용하여 일정횟수 동안 반복 시킬수도 있고 어떤 조건이 만족될 때까지 반복시킬 수도 있다. 
                      반복은 간명하고 효율적으로 되풀이를 구현하는 방법이다. 
                      반면에 때로는 반복을 사용하게 되면 지나치게 복잡해지는 문제들도 존재한다. 이런 경우에는 순환이 좋은 해결책이 될 수 있다. 순환은 주어진 문제를 해결하기 위하여 자신을 다시 호출하여 
                      수행하는 방식이다. 순환은 본질적으로 순환적인 문제나 그러한 자료구조를 다루는 프로그램에 적합하다. 
                      <br>
                      문제의 크기가 순환이 진행될수록 작아지는 것에 유의해야 한다. 
                      <br>
                      기본적으로 반복과 순환은 문제 해결 능력이 같으며 많은 경우에 순환 알고리즘을 반복 버전으로 , 반복 알고리즘을 순환 버전으로 바꾸어 쓸 수 있다. 특히 순환 호출이 끝에서 이루어지는 순환을 꼬리 순환이라고 하는데, 
                      이를 반복 알고리즘으로 쉽게 바꾸어 쓸 수 있다. 
                      <hr>
                      <strong>순환의 원리</strong>
                      <hr>
                      분할 정복 : 주어진 문제를 더 작은 동일한 문제들로 분해하여 해결하는 방법을 분할 정복이라 한다. <br>
                      순환은 알고리즘 정의가 순환적으로 되어 있는 경우에 유리한 방법이다. 예를 들어 팩토리얼 함수 계산, 피보나치 수열, 이항계수 계산, 이진 트리 알고리즘, 이진 탐색, 하노이 탑 문제들은 순환 알고리즘을 쓰는 것이 자연스러운 알고리즘이다. 
                      <hr>
                      <strong>순환 알고리즘의 성능</strong><br>
                      순환 알고리즘과 반복 알고리즘의 시간 복잡도는 같지만 순환 호출의 경우 여분의 기억공간이 더 필요하고 또한 함수를 호출하기 위해서는, 함수의 매개변수들을 
                      스택에 저장하는 것과 같은 사전 작업이 상당히 필요하다. 따라서 수행시간도 더 걸린다. 결론적으로 순환 알고리즘은 이해하기 쉽다는 것과 쉽게 프로그램 할 수 있다는 장점이 있는 
                      대신 수행 시간과 기억 공간의 사용에 있어서는 비효율적인 경우가 많다. 
                      <hr>
                      거듭제곱 값 계산 
                      <pre class="C" >
                        <code>
// 반복에 의한 방식                           
double slow_power(double x, int n){
  int i;
  double result = 1.0;

  for( i = 0; i &lt; n; i ++ ){
    return = result * x;
    return (result);
  }
}
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
// 순환에 의한 방식      
// 한번의 호출 할 때마다 문제의 크기는 약 절반으로 줄어든다.                      
power(x , n) : 
  if n == 0 
    then return 1;
  else if n이 짝수 
    then return power(x^2, n/2);
  else if n이 홀수 
    then return x * power(x^2, (n-1)/2);
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
// 순환적인 거듭 제곱 계산 
// 순환을 사용하게 되면 단순하게 작성이 가능하며 가독성이 높아진다. 그러나 똑같은 계산을 몇번씩 반복한다면 아주 단순한 경우라 할지라도 
// 계산 시간이 엄청나게 길어질 수 있다. 
double power(double x, int n ){
  if ( n == 0) return 1;
  else if ( (n%2) == 0) 
    return power(x*X, n/2 )
  else return x * power(x*x, (n-1)/2);
}
                        </code>
                      </pre>
                      <hr>
                      <strong>피보나치 수열</strong> <br>
                      <img src="./pibonacci_sequence.PNG" class="img-thumbnail" alt="" srcset=""> <br>
                      피보나치 수열은 이탈리아 수학자가 발견한 수열로서 한 쌍의 토끼가 번식하는 상황을 수열로 만든 것이다. 
                      <br>
                      <pre class="C" >
                        <code>
// 순환적인 피보나치 수열 계산
int fib(int n){
  if ( n == 0) return 0;
  if ( n == 1) return 1;
  return ( fib(n-1) + fib(n-2));
}
                        </code>
                      </pre>
                      위의 코드는 단순하고 이해하기 쉽지만 굉장히 비효율 적인 코드이다. 
                      fib(6)을 구하기 위해서  fib() 함수가 25번이나 호출되는 것에 유의해야 한다. 근본적인 이유는 중간에 계산되었던 값을 기억하지 않고 
                      다시 계산하기 때문이다. 
                      <br>
                      T(n) = T(n-1) + T(n-2) + C 의 순환적인 수식을 이용하면 시간 복잡도 O(2^n)이 도출된다. 
                      이것은 O(2^n)의 복잡도 패턴이라 할 수 있다. 
                      피보나치 수열을 계산하는데 순환을 사용하는 것이 아닌 반복을 사용하게 되면 제일 좋은 결과를 얻을 수 있었다. 
                      <pre class="C" >
                        <code>
int fib_iter(int n){
  if ( n == 0 ) return 0;
  if ( n == 1 ) return 1;

  int pp = 0;
  int p = 1;
  int result = 0;

  for( int i = 2 ; i &lt; n; i ++){
    result = p + pp;
    pp = p;
    p = result;
  }
  return result 
}
                        </code>
                      </pre>
                      <hr>
                      <strong>하노이 탑</strong>
                      순환의 사용에 가장 적합한 예제가 바로 하노이 탑 문제이다. <br>
                      하노의 탑을 해결하기 위한 알고리즘 <br>
                      <pre class="C" >
                        <code>
// 막대 from에 쌓여있는 n개의 원판을 막대 tmp를 사용하여 막대  to로 옮긴다. 
void hanoi_tower(int n, char from, char tmp, char to ){
  if ( n == 1) {
    from에 있는 한 개의 원판을 to로 옮긴다. 
  } else {
    1. from의 맨 밑의 원판을 제외한 나머지 원판을 tmp로 옮긴다. 
    2. from에 있는 한 개의 원판을 to로 옮긴다. 
    3. tmp의 원판들을 to로 옮긴다. 
  }
}

// 코드 예제
#include &lt;stdio.h>
void hanoi_tower( int n , char from, char tmp, char to ){
  if ( n ==  1) printf("원판 1을 %C에서 %c으로 옮긴다. \n" , from, to );
  else {
    hanoi_tower( n - 1, from, to tmp );
    printf("원판 %d 을 %C에서 %c으로 옮긴다. \n" , from, to );
    hanoi_tower( n - 1, tmp, from, to );
  }
}

int main(void){
  hanoi_tower( 4, 'A' , 'B' , 'C');
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <pre class="C" >
                        <code>
//  순환 호출이 맨끝에서 이루어지는 형태의 순환으로, 꼬리 순환의 경우, 알고리즘은 쉽게 반복적인 형태로 변환이 가능하다.                           
return n*factorial(n - 1);

// 머리 순환(head recursion)의 경우나 방금 살펴본 하노이 탑의 문제 처럼 여러 군데에서 자기 자신을 호출하는 경우는 쉽게 반복적인 코드로 바꿀 수 없다. 
return factorial(n - 1)*n;
                        </code>
                      </pre>

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading11">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse11" aria-expanded="false" aria-controls="collapse11">
                        배열, 구조체, 포인터 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse11" class="collapse" aria-labelledby="heading11" data-parent="#accordionExample">                        
                    <div class="card-body">
                      <strong>배열</strong><br>
                      <pre class="C" >
                        <code>
객체 : &lt; 인덱스, 값 > 쌍의 집합 
연산 : 
  - create(size) ::= size개의 요소를 저장할 수 있는 배열 생성 
  - get(A, i) ::= 배열 A의 i 번째 요소 반환. 
  - set(A, i, v) ::= 배열 A의 i 번째 위치에 값 v 저장. 
                        </code>
                      </pre>
                      컴파일러에서 배열 요소에 대한 메모리 주소 구현 방식 <br>
                      <ul>
                        <li>list[0] : 기본주소=base</li>
                        <li>list[1] : base + 1*sizeof(int)</li>
                        <li>...</li>
                      </ul>
                      우리가 프로그램에서 list[i]라고 적으면 컴파일러는 주소 base + i*sizeof(int)에 있는 값을 가져온다. 
                      <hr>
                      <strong>구조체</strong><br>
                      복잡한 객체에는 다양한 타입의 데이터들이 한데 묶여져서 있다. 배열이 타입이 같은 데이터의 모임이라면 구조체는 타입이 다른 데이터를 묶는 방법이다. <br>
                      <pre class="C" >
                        <code>
struct 구조체이름 {
  항목1;
  항목2;
  ...
}

// 구조체 변수 선언 방식 
struct 구조체이름 구조체변수;
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
#include &lt;stdio.h>

typedef struct studentTag {
  char name[10];
  int age;
  double gpa;
} student; 

int main(void) {
  student a = { "kim", 30, 4.3 };
  student b = { "park", 21, 4.2 };
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>배열의 응용  : 다항식</strong><br>
                      <ul>
                        <li>
                          <strong>첫번째 방법</strong><br>
                          <pre class="C" >
                            <code>
10x^5 + 0 * x^4 + 0 * x^3 + 0 * x^2 + 6 * x + 3 


#define MAX_DEGREE 101 

typedef struct {
  int degree;
  float coef[MAX_DEGREE];
} polynomial 

polynomial a = { 5, { 10, 0 , 0, 0, 6 , 3}}
                            </code>
                          </pre>
                        </li>
                        <li>
                          <strong>두번째 방법</strong><br>
                          <pre class="C" >
                            <code>
#define MAX_TERMS 101

typedef struct {
  float coef;
  int expon;
} terms[MAX_TERMS];
int avail; 

terms[MAX_TERMS] = {{ 8,3 }, { 7,1 } , { 1, 0 } , { 10, 3 } , { 3 , 2 } , { 1 , 0 } }
                            </code>
                          </pre>
                        </li>
                        <li>
                          <strong>희소 행렬</strong><br>
                          <pre class="C" >
                            <code>
// 희소 행렬의 표현 방법 #1
#define MAX_ROWS 100
#define MAX_COLS 100
int matrix[MAX_ROWS][MAX_COLS];


// 희소 행렬의 표현방법 #2
struct matrix {
  int x,
  int y, 
  char value
}

int main(){
  struct matrix m[100] = { { .x = 1 , .y= 1 , .value = 'G' }, ... }
}
                            </code>
                          </pre>
                        
                        </li>
                        <li>
                          <strong>전치 행렬 계산법</strong>
                          <pre class="C" >
                            <code>
#define ROWS 3
#define COLS 3

// 행렬 전치 함수 - 첫번째 방식 
void matrix_transpose(int A[ROWS][COLS], int B[ROWS][COLS]){
  for ( int r = 0 ; r &lt; ROWS ; r ++){
    for ( int c = 0 ; c &lt; COLS ; c ++){
      B[c][r] = A[r][c];
    }
  }
}

// 행렬 전치 함수 - 두번째 방식 
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_TERMS 100
typedef struct {
  int row;
  int col;
  int value;
}

typedef struct SparseMatrix {
  element data[MAX_TERMS];
  int rows;
  int cols;
  int terms;
} SparseMatrix;

SparseMatrix matrix_transpose2(SparseMatrix a){
  SparseMatrix b;

  int bindex;
  b.rows = a.rows;
  b.cols = a.cols;
  b.terms = a.terms;

  if(a.terms > 0){
    bindex = 0;
    for ( int c = 0 ; c &lt; a.cols ; r ++){
      for ( int i = 0 ; i &lt; a.terms ; i ++){
        if(a.data[i].col == c){
          b.data[bindex].row = a.data[i].col;
          b.data[bindex].col = a.data[i].row;
          b.data[bindex].value = a.data[i].value;
        }
      }
    }
  }
  return b;
}
                            </code>
                          </pre>
                        </li>
                      </ul>
                      <strong>Pointer</strong><br>
                      포인터는 다른 변수의 주소를 가지고 있는 변수이다. 모든 변수는 메모리 공간에 저장되고 메모리의 각 바이트에는 주소가 매겨져 있다. 
                      이 주소가 포인터에 저장된다. 주소는 컴퓨터에 따라 다를 수 있으므로 포인터 변수는 정확한 숫자보다는 그냥 화살표로 그려진다. 
                      <ul>
                        <li>널 포인터</li>
                        <li></li>
                      </ul>
                      배열과 포인터의 관계 : 배열의 이름은 배열의 시작부분을 가리키는 포인터이다. <br>
                      배열의 이름이 점선으로 그려져 있는 이유는 실제로 컴파일러가 배열의 이름에 공간을 할당하지는 않기 때문이다. 대신에 배열의 이름이 있는 곳을 배열의 첫번째 요소의 
                      주소로 대치한다. 따라서 배열의 이름이 포인터이기 때문에 배열이 함수의 매개변수로 전달 될 때 사실을 포인터가 전달되는 것이다. 
                      <hr>
                      <strong>동적 메모리 할당</strong>
                      <pre class="C" >
                        <code>
int *p;
// malloc() 함수가 반환했던 포인터 값을 잊어버리면 안된다는 것이다. 포인터 값을 잊어버리면 동적 메모리를 반환할 수 없다. 
// malloc()은 시스템의 메모리가 부족해서 요구된 메머리를 할당할 수 없으면 NULL을 반환한다. 
p = ( int * )malloc(sizeof(int));
*p = 1000;
free(p);                          
                        </code>
                      </pre>
                      동적 메모리가 할당되는 공간을 히프라고 한다. 히프는 운영체제가 사용되지 않는 메모리 공간을 모아 놓은 곳이다. 필요한 만큼 할당을 받고 또 필요한 대에 사용하고 반납하기 때문에 
                      메모리를 매우 효율적으로 사용할 수 있다. 
                      <hr>
                      <strong>구조체와 포인터</strong><br>
                      우리는 구조체에 포인터를 선언하고 포인터를 통하여 구조체 멤버에 접근할 수 있다. 여기에서 하나 주의할 것은 포인터를 통하여 구조체의 멤버에 접근하는 편리한 표기법 "->"이다. <br>
                      <pre class="C" >
                        <code>
// (*ps).i 보다 ps -> i 라고 쓰는 것이 더 편리하다. 

typedef struct studentTag {
  char name[10];
  int age;
  double gpa;
} student;

int main(void) {
  student s*;

  s = (student *)malloc(sizof(student));
  if ( s == NULL ){
    fprintf(stderr, "메모리가 부족해서 할당할 수 없습니다. \n");
    exit(1);
  } 

  strcpy(s -> name,  "Park");
  s -> age = 20;

  free(s);
  return 0;
}

                        </code>
                      </pre>

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading13">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse13" aria-expanded="false" aria-controls="collapse13">
                        스택   
                      </button>
                    </h2>
                  </div>
                  <div id="collapse13" class="collapse" aria-labelledby="heading13" data-parent="#accordionExample">
                    <div class="card-body">
                      스택에서의 입출력은 맨 위에서만 일어나고 스택의 중간에서는 데이터를 삭제할 수 없다. 
                      스택에서 입출력이 이루어지는 부분을 스택 상단이라고 하고 반대쪽인 바닥부분을 스택 하단이라고 한다. 스택에 저장되는 것을 요소라 부른다. 
                      <hr>
                      후입 선출 ( LIFO : Last In First Out )
                      <hr>
                      함수는 실행이 끝나면 자신을 호출한 함수로 되돌아가야한다. 이때 스택이 사용되는데, 즉 복귀할 주소를 기억하는데 사용된다. 
                      <hr>
                      추상 자료형 스택 
                      <pre class="C" >
                        <code>
- 객체 : 0개 이상의 원소를 가지는 유한 선형 리스트 
- 연산 : 
  create(size)  ::= 최대크키가 size인 공백 스택을 생성한다. 
  is_full(s) ::= 
    if(스택의 원소수 == false) return TRUE;
    else return FALSE;
  is_empty(s)   ::= 
    if(스택의 원소수 == 0) return TRUE;
    else return FALSE;
  push(s, item) ::=
    if( is_full(s) ) retirm ERROR_STACKFULL;
    else 스택의 맨 위에 item을 추가한다. 
  pop(s) ::=
    if ( is_empty(s) ) return ERROR_STACKEMPTY;
    else 스택의 맨 위의 원소를 제거해서 반환한다.
  peeck(s) ::=
    if( is_empty(s) ) return ERROR_STACKEMPTY;
    else 스택의 맨 위의 원소를 제거하지 않고 반환한다.                          

                        </code>
                      </pre>
                      Stack은 기본적으로 Push와 Pop의 두가지 연산으로 이루어져있고, 실제 Stack에서 허용하는 Item 갯수가 가득찼는지 pop을 했을 때 더 빼낼 아이템이 없는지를
                      체크하기 위한 Validation이 존재한다. 
                      <hr>
                      <strong>스택의 구현</strong><br>
                      <pre class="C" >
                        <code>
is_empty(S):
  if top == -1
    then return TRUE
    then return FALSE 

is_full(S):
  if top >= ( MAX_STACK_SIZE )
    then return TRUE 
    then return FALSE 

// push에서는 먼저 top의 값을 증가하는 것에 유의하라. top이 가리키는 위치는 마지막으로 삽입되었던 요소이므로 top을 증가시키지 않고 삽입하면 마지막 요소가 지워지게 된다. 
push(S,x):
  if is_full(S)
    then error "overflow"
    else top &lt;- top + 1
         stack[top] &lt;- x

// pop 연산은 스택에서 하나의 요소를 제거하는 여산으로 top이 가리키는 요소를 스택에서 꺼내어 외부로 건네주는 연산이다. 
// 먼저 요소를 제거하기 전에 스택이 비어있는지 검사행한다. 
pop(S, x) :
  if is_empty(S)
    then error "underflow"
    else e &lt;- stack[top]
        top &lt;- top-1
        return e
                        </code>
                      </pre>
                      <hr>
                      <strong>전역변수를 이용하여 구현하는 방법</strong>  
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

// 스택이 전역 변수로 구현된다. 
#define MAX_STACK_SIZE 100
typedef int element;
element stack[MAX_STACK_SIZE];
int top = -1;

// 공백 상태 검출 함수 
int is_empty()
{
  return ( top == -1 );
}

// 포화 상태 검출 함수 
int is_full()
{
  return ( top == ( MAX_STACK_SIZE - 1));
}

// 삽입 함수 
void push(element item){
  if(is_full()){
    fprintf(stderr, "스택 포화 에러\n");
    return;
  }
  else stack[++top] = item;
}

// 삭제 함수 
element pop(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return stack[top--];
}

// 피크함수 
element peek(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return statck[top];
}

int main(void){
  push(1);
  push(2);
  push(3);
  printf("%d\n", pop());
  printf("%d\n", pop());
  printf("%d\n", pop());
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택의 요소를 구조체로 하기 </strong><br>
                      <pre class="C" >
                        <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_STACK_SIZE 100
#defind MAX_STRINC 100

typedef stuct {
  int student_no;
  char name[MAX_STRING];
  char address[MAX_STRING];
} element;

element stack[MAX_STACK_SIZE];
int top = -1;

// 공백 상태 검출 
int is_empty(){
  return ( top == -1);
}

// 포화 상태 검출 함수 
int is_full(){
  return ( top == (MAX_STACK_SIZE - 1));
}

// 삽입 함수 
void push(element itme){
  if(is_full()){
    fprintf(stderr, "스택 포화 에러\n");
    exit(1);
  }
  else stack[++top] = item;
}

// 삭제 함수 
element pop(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러 \n");
    exit(1);
  }
  else return stack[top--];
}

// 피크 함수 
element peek(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return stack[top];
}

int main(void){
  element ie = {
    20190001,
    "Hong",
    "Seoul"
  };

  element oe;

  push(ie);
  oe = pop();

  printf("학번 : %d\n", oe.student_no);
  printf("이름 : %d\n", oe.name);
  printf("주소 : %d\n", oe.address);

  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>함수의 매개변수로 전달하는 방법</strong>
                      <hr>
                      <pre>
                        <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

// 차후에 스택이 필요하면 여기만 복사하여 붙인다. 
// ===== 스택 코드의 시작 =====
#define MAX_STACK_SIZE 100

typedef int element;
typedef struct {
  element data[MAX_STACK_SIZE];
  int top;
} StackType;


// 스택 초기화 함수 
void init_stack(StackType *s){
  return ( s -> top == -1);
}

// 공백상태 검출 함수
int is_empty(StackType *s){
  return ( s -> top == -1);
}

// 포화 상태 검출 함수 
int is_full(StackType *s){
  return ( s -> top == ( MAX_STACK_SIZE - 1));
}

// 삽입함수 
void push(StackType *s, element item){
  if(is_full(s)){
    fprinf(stderr, "스택 포화 에러\n");
    return;
  }
  else{
    s -> data[++(s-> top)] = item;
  }
}

// 삭제함수 
element pop(StackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return s->data[(s->top)X-UA-Compatible]
}

// 피크함수 
element peek(StackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return s ->data[s->top];
}
// ===== 스택 코드의 끝 =====

// C언어에서의 함수 매개변수 전달 방식이 기본적으로 Call By Value이기 때문에, 구조체를 함수의 매개변수로 전달하는 경우, 구조체의 원본이 전달되는 것이 아니라 구조체의 복사본이 전달된다. 
// 따라서 함수 안에서는 복사본을 수정하여도 원본에는 영향을 주지 못한다. 그러나 원본에 대한 포인터를 전달하면 원본을 변경할 수 있다. 

int main(void){
  StackType s;

  init_stack(&s);
  push(&s, 1);
  push(&s, 2);
  push(&s, 3);
  printf("%d\n", pop(&s));
  printf("%d\n", pop(&s));
  printf("%d\n", pop(&s));
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택을 동적할 메모리 할당으로 생성</strong>
                      <pre class="C" >
                        <code>
int main(void){
  StackType *s;
  s = (StackType *)malloc(sizeof(StackType));
  init_stack(s);
  push(s, 1);
  push(s, 2);
  push(s, 3);
  printf("%d\n", pop(s));
  printf("%d\n", pop(s));
  printf("%d\n", pop(s));
  free(s);
}
                        </code>
                      </pre>
                      <hr>
                      <strong>동적배열스택</strong>
                      <hr>
                      <pre class="C" >
                        <code>
typedef int element;
typedef struct {
  element *data;
  int capacity;
  int top;
} StackType;

// 스택 생성 함수 
void int_stack(StackType *s){
  s -> top = -1;
  s -> capacity = 1;
  s -> data = (element *)malloc(s -> capacity*sizeof(element));
}

// 스택 삭제 함수 
void delete(StackType *s){
  free(s);
}

void push(StackType *s, element item){
  if(is_full(s)){
    s -> capacity *= 2;
    s -> data = (element *)realloc(s->data, s->capacity * sizeof(element));
  }
  s -> data[++(s->top)] = item;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>동적 배열 스택 프로그램</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_STACK_SIZE 100

typedef int element;
typedef struct {
  element *data;
  int capacity;
  int top;
} StackType;

// 스택 생성 함수 
void init_stack(StackType *s){
  s -> top = -1;
  s -> capacity = 1;
  s -> data = (element *)malloc(s -> capacity * sizeof(element));
}

// 공백 상태 검출 함수 
int is_empty(StackType *s){
  return ( s -> top == -1 );
}

// 포화상태 검출 함수 
int is_full(StackType *s)
{
  return ( s -> top == (MAX_STACK_SIZE -1 ));
}

void push(StackType *s, element item){
  if(is_full(s)){
    s -> capacity *= 2;
    s -> data = ( element *)realloc(s -> data, s -> capacity * sizeof(element));
  }
  s -> data[++(s->top)] = item;
}

// 삭제 함수 
element pop(StackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return s -> data[(s->top)--];
}

int main(void){
  StackType s;
  init_stack(&s);
  push(&s, 1);
  push(&s, 2);
  push(&s, 3);
  printf("%d \n", pop(&s));
  printf("%d \n", pop(&s));
  printf("%d \n", pop(&s));
  free(s.data);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택의 활용 : 괄호 검사 문제 </strong>
                      <hr>
                      <ul>
                        <li>왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.</li>
                        <li>같은 종류의 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.</li>
                        <li>서로 다른 종류의 왼쪽 괄호와 오른쪽 괄호 쌍은 서로를 교차하면 안된다.</li>
                      </ul>
                      <pre>
                        <code class="C" >
check_matching(expr);

while(입력 expr의 끝이 아니면)
ch &lt;- expr의 다음 글자 
switch(ch)
    case '(' : case '[' : case '{' :
        ch를 스택에 삽입 
        break
    case ')' : case ']' : case '}' :
        if ( 스택이 비어 있으면 )
            then 오류 
            else 스택에서 open_ch 를 꺼낸다
                if ( ch와 open_ch가 같은 짝이 아니면 )
                    then 오류 보고 
    break
if( 스택이 비어 있지 않으면 )
    then 오류                                           
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#define MAX_STACK_SIZE 100

typedef char element;
element stack[MAX_STACK_SIZE];

int check_matching(const char *in){
  StackType s;
  char ch, open_ch;
  int i, n = strlen(in);
  init_stack(&s);

  for ( i = 0; i &lt; n ; i ++){
    ch = in[i];
    switch(ch){
      case '(' : case '[' : case '{' :
        push(&s, ch);
        break;
      case ')' : case ']' : case '}' :
        if(is_empty(&s)) return 0;
        else {
          open_ch = pop(&s);
          if((open_ch == '(' && ch != ')' ) ||
            (open_ch == '[' && ch != ']' ) ||
            (open_ch == '{' && ch != '}' ) 
          ){
            return 0;
          }
          break;
        }  
    }
  }
  if(!is_empty(&s)) return 0;
  return 1;
}

int main(void){
  char *p = "{ A[(i+1)]=0; }";
  if(check_matching(p) == 1)
    printf("%s 괄호검사성공\n", p);
  else 
    printf("%s 괄호검사실패\n", p);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택의 응용 : 후위 표기 수식의 계산</strong>
                      <hr>
                            
                      <pre>
                        <code class="C" >
calc_posfix:
    스택 s를 생성하고 초기화한다. 
    for item in 후위표기식 do 
        if ( item이 피연산자이면 )
            push(s, item)
        else if ( item이 연산자 op이면 )
            second &lt;- pop(s)
            first &lt;- pop(s)
            result &lt;- first op second // op 는 +-*/ 중의 하나 
            push(s, result)
        final_result &lt;- pop(s);                                  
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_STACK_SIZE 100

typedef char element;

int eval(char exp[]){
  int op1, op2, value , i = 0;
  int len = strlen(exp);
  char ch;
  StackType s;

  init_stack(&s);
  for( i = 0; i &lt; len ; i ++){
    ch = exp[i];
    if( ch != '+' && ch != '-' && ch != '*' && ch != '/' ){
      value = ch - '0';
      push(&s, value);
    }else {
      op2 = pop(&s);
      op1 = pop(&s);
      switch ( ch ) {
        case '+' : push(&s, op1 + op2); break;
        case '-' : push(&s, op1 - op2); break;
        case '*' : push(&s, op1 * op2); break;
        case '/' : push(&s, op1 / op2); break;
      }
    }
  }
  return pop(&s);
}

int main(void){
  int result;
  printf("후위표기식은 82/3-32*+\n");
  result = eval("82/3 - 32 *+");
  printf("결과값은 %d\n", )
}
                        </code>
                      </pre>
                      <hr>
                      <strong>중위 표기 수식을 후위 표기 수식으로 전환</strong>
                      <hr>
                      <pre>
                        <code class="c">
infix_to_postfix(exp);

스택 s를 생성하고 초기화 
while ( exp에 처리할 문자가 남아 있으면 )
    ch &lt;- 다음에 처리할 문자 
    switch ( ch )
    case 연산자 : 
        while ( peek(s)의 우선순위 >= ch의 우선순위 ) do 
            e &lt;- pop(s)
            e를 출력 
        push(s, ch);
        break;
    case 왼쪽 괄호 : 
        push(s, ch);
        break;
    case 오른쪽 괄호 : 
        e &lt;- pop(s);
        while( e != 왼쪽괄호 ) do 
            e를 출력 
            e &lt;- pop(s);
        break;
    case 피연산자 : 
        ch를 출력
        break;

while( not is_empty(s) ) do 
    e &lt;- pop(s)
    e를 출력 
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_STACK_SIZE 100

typedef char element;

int prec(char op)
{
  switch(op) {
    case '(' : case ')' : return 0;
    case '+' : case '-' : return 1;
    case '*' : case '/' : return 2;
  }
  return -1;
}

void infix_to_postfix(char exp[]){
  int i = 0;
  char ch, top_op;
  int len = strlen(exp);
  StackType s;

  init_stack(&s);
  for ( i = 0; i &lt; len; i ++){
    ch = exp[i];
    switch(ch) {
      case '+' : case '-' : case '*' : case '/' : 
        while ( !is_empty(&s) && (prec(ch) &lt;= prec(&s)))
          prinf("%sc", pop(&s));
        push(&s, ch);
        break;
      case '(' :
        push(&s, ch);
        break;
      case ')' :
        top_op = pop(&s);
        while ( top_op != '('){
          printf("%c", top_op);
          top_op = pop(&s);
        }
        break;
      default:
        printf("%c", pop(&s));
        break;
    }
  }
  while( !is_empty(&s))
    printf("%c", pop(&s));
}

init main(void){
  char *s = "(2+3)*4+9";
  printf("중위 표시 수식  %s \n", s);
  printf("후위 표시 수식 ");
  infix_to_postfix(s);
  printf("\n");
}
                        </code>
                      </pre>
                      <hr>
                      <strong>미로 탐색 프로그램</strong>
                      <hr>
                      <pre>
                        <code class="C" >
maze_search();

스택 s과 출구의 위치 x, 현재 생쥐의 위치를 초기화 
while( 현재의 위치가 출구가 아니면 ) do 
    현재 위치를 방문한 것으로 표기 
    if( 현재위치의 위, 아래, 왼쪽, 오른쪽 위치가 아직 방문되지 않았고 갈 수 있으면 )
        then 그 위치들을 스택에 push 
    if( is_empty(s) )
        then 실패 
    else 스택에서 하나의 위치를 꺼내어 현재 위치로 만든다. 
성공;                           
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#define MAX_SIZE 6

typedef struct {
  short r;
  short c;
} element;

element here = { 1, 0}, entry = { 1, 0 };

void push_loc(StackType *s, int r, int c){
  if( r &lt; 0 || c &lt; 0) return;
  if( maze[r][c] != '1' && maze[r][c] != '.' ) {
    element tmp;
    tmp.r = r;
    tmp.c = c;
    push(s, tmp);
  }
}

void maze_print(char maz[MAZE_SIZE][MAZE_SIZE]){
  print("\n");
  for( int r = 0; r &lt; MAZE_SIZE; r++){
    for( int c = 0; c &lt; MAZE_SIZE; c++){
      print("%c", maze[r][c]);
    }
    printf("\n");
  }
}

int main(void){
  int r,c;
  StackType s;

  init_stack(&s);
  here = entry;
  while ( maze[here.r][here.c] != 'x'){
    r = here.r;
    c = here.c;
    maze[r][c] = '.';
    maze_print(maze);
    push_loc(&s. r - 1, c);
    push_loc(&s. r + 1, c);
    push_loc(&s. r , c - 1);
    push_loc(&s. r , c + 1);
    if(is_empty(&s)){
      printf("실패\n");
      return;
    }
    else 
      here = pop(&s);
  }
  printf("성공\n");
  return 0;
}
                        </code>
                      </pre>
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading14">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse14" aria-expanded="false" aria-controls="collapse14">
                        큐
                      </button>
                    </h2>
                  </div>
                  <div id="collapse14" class="collapse" aria-labelledby="heading14" data-parent="#accordionExample">
                    <div class="card-body">
                      스택의 경우, 나중에 들어온 데이터가 먼저 나가는 구조인데 반하여 큐는 먼저 들어온 데이터가 먼저 나가는 구조로 이러한 특성을 선입선출(First In First Out)이라고 한다. 
                      <hr>
                      <strong>ADT : 큐</strong>
                      <hr>
                      <pre>
                        <code class="C" >
객체 : 0개 이상의 요소들로 구성된 선형 리스트 

연산 : 
    create(max_size) ::=
        최대 크기가 max_size 인 공백큐를 생성한다. 
    is_empty(q) ::= 
        if(size == max_size) return TRUE;
        else return FALSE;
    is_full(q) ::=
        if(size == max_size ) return TRUE;
        else return FALSE;
    enqueue(q, e) ::=
        if( is_full(q) ) queue_full 오류;
        else q의 끝에 e를 추가한다. 
    dequeue(q) ::=
        if( is_empty(q) ) queue_empty 오류:
        else q의 맨 앞에 있는 e를 제거하여 반환한다. 
    peek(q) ::=
        if( is_empty(q) ) queue_empty 오류;
        else q의 맨 앞에 있는 e를 읽어서 반환한다.                       

                        </code>
                      </pre>
                      <hr>
                      많이 이용되는 분야는 컴퓨터를 이용하여 현실 세계의 실제 상황을 시뮬레이션 하는 것이다, 예를 들면 은행에서 기다리는 사람들의 대기열, 공항에서 이륙하는 비행기들, 인터넷에서 전송되는 데이터 패킷들을 모델링하는 데 큐가 이용된다. 
                      큐는 운영체제에서도 중요하게 사용된다. 예를 들면 운영체제에는 인쇄 작업큐가 존재한다. 프린터는 속도가 늦고 상대적으로 컴퓨터의 CPU는 속도가 빠르기 때문에 CPU는 빠른 속도로 인쇄 데이터를 만든 다음, 인쇄 작업 큐에 저장하고
                      다른 작업으로 넘어간다. 
                      <hr>
                      <strong>선형 큐</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_QUEUE_SIZE 5

typedef int element;
typedef struct {
  int front;
  int rear;
  element data[MAX_QUEUE_SIZE];
} QueueType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

void init_queue(QueueType *q){
  q -> rear = -1;
  q -> front = -1;
}

void queue_print(QueueType *q){
  for ( int i = 0; i &lt; MAX_QUEUE_SIZE; i ++ ) {
    if ( i &lt;= q -> front || i > q -> rear ){
      printf(" | ");
    }else{
      printf("%d | ", q -> data[i]);
    }
  }
  printf("\n");
}

int is_full(QueueType *q){
  if( q -> rear == MAX_QUEUE_SIZE - 1 )
    return 1;
  else 
    return 0;
}

int is_empty(QueueType *q){
  if( q -> front ==  q -> rear )
    return 1;
  else 
    return 0;
}

void enqueue(QueueType *q, int item){
  if(is_full(q)) {
    error("큐가 포화상태입니다. ")
    return;
  }
  q -> data[++(q->rear)] = item;
}

int dequeue(QueueType *q){
  if(is_empty(q)){
    error("큐가 공백상태입니다. ");
    return 1;
  }
  int item = q -> data[++(q->front)];
  return item;
}

int main(void){
  int item = 0;
  QueueType q;

  init_queue(&q);

  enqueue(&q, 10); queue_print(&q);
  enqueue(&q, 20); queue_print(&q);
  enqueue(&q, 30); queue_print(&q);

  item = dequeue(&q); queue_print(&q);
  item = dequeue(&q); queue_print(&q);
  item = dequeue(&q); queue_print(&q);
  return 0;
}


                        </code>
                      </pre>
                      <hr>
                      <strong>원형큐</strong>
                      <hr>
                      <pre>
                        <code class="C" >
* 원형큐에서의 삽입 알고리즘 
enqueue(Q, x):
    rear &lt;- ( rear + 1) % MAX_QUEUE_SIZE;
    Q[rear] &lt;- x;                          

* 원형큐에서의 삭제 알고리즘
    front &lt;- ( front + 1) % MAX_QUEUE_SIZE;
    return Q[front];                          
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_QUEUE_SIZE 5
typedef int element;
typedef struct {
  element data[MAX_QUEUE_SIZE];
  int front;
} QueueType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

void init_queue(QueueType *q)
{
  q -> front = q -> rear = 0;
}

int is_empty(QueueType *q)
{
  return ( q -> front == q -> rear);
}

int is_full(QueueType *q){
  return ((q -> rear + 1)% MAX_QUEUE_SIZE == q -> front);
}

void queue_print(QueueType *q){
  printf("QUEUE(front=%d rear=%d) = " , q -> front, q -> rear );
  if(!is_empty(q)) {
    int i = q -> front;
    do {
      i = ( i + 1) % ( MAX_QUEUE_SIZE );
      printf("%d | " , q -> data[i]);
      if( i == q -> rear ){
        break;
      }
    } while ( i != q -> front );
  }

  printf("\n");
}

void enqueue(QueueType *q, element item){
  if(is_full(q))
    error("큐가 포화상태입니다. ");
  q -> rear = ( q -> rear + 1) % MAX_QUEUE_SIZE;
  q -> data[q->rear] = item;
}

element dequeue(QueueType *q){
  if(is_empty(q)){
    error("큐가 공백상태입니다.");
  }
  q -> front = ( q -> front + 1) % MAX_QUEUE_SIZE;
}

element peek(QueueType *q){
  if(is_empty(q))
    error("큐가 공백상태입니다.");
  return q -> data[(q->front+1 ) % MAX_QUEUE_SIZE;
}

int main(void){
  QueueType queue;
  int element;

  init_queue(&queue);
  printf("--데이터 추가 단계--\n");
  while(!is_full(&queue)){
    printf("정수를 입력하시오 : ");
    scanf(%d, &element);
    enqueue(&queue, element);
    queue_print(&queue);
  }
  printf("큐는 포화상태입니다. \n\n");

  printf("--데이터 삭제 단계--\n");
  while(!is_empty(&queue)){
    element = dequeue(&queue);
    printf("꺼내진 정수 : %d \n", element);
    queue_print(&queue);
  }
  printf("큐는 공백상태입니다. \n");
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>Queue의 버퍼</strong>
                      <hr>
                      <p>
                        버퍼란? <br>
                        버퍼란 임시 저장 공간을 의미합니다. 임시 저장 공간이라고 해서 생뚱맞게 보일 수 있지만 정확히 말하면 A와 B가 서로 입출력을 수행하는 데에 있어서 속도차이를 극복하기 위해 사용하는 임시 저장 공간을 의미합니다. <br>
                        프로그래밍에서의 버퍼는 거의 대부분 CPU와 보조 기억 장치 사이에서 사용되는 임시저장 공간을 의미합니다. 버퍼라는 것은 속도차가 큰 대상이 입출력을 수행할 때 효율성을 위해 사용하는 임시 저장공간이라고 할 수 있겠습니다. 
                      </p>
                      <pre>
                        <code class="C" >
큐를 버퍼처럼 사용할 수 잇는데, 

#include &lt;stdio.h>
#include &lt'stdlib.h>

int main(void){
  QueueType queue;
  int element;

  init_queue(&queue);
  srand(time(NULL));

  for(int i = 0; i &lt; 100; i++ ){
    if(rand() % 5 == 0){
      enqueue(&queue , rand()%100);
    }
    queue_print(&queue);
    if(rand() % 10 == 0){
      int data = dequeue(&queue);
    }
    queue_print(&queue);
  }
  return 0;
}
                        </code>
                      </pre>
                      <p>
                        랜덤한 수(난수)를 생성하는 함수 <br>
                        <ul>
                          <li>
                            int rand(void)
                            <br>
                            랜덤한 숫자를 반환합니다. 
                            그 범위는 0 ~ RAND_MAX 까지 인데요. RAND_MAX 라는 것은 stdlib.h 헤더파일에 매크로로 작성되어 있습니다. <br>
                            RAND_MAX = 32767 <br>
                          </li>
                          <li>
                            void srand(unsigned int seed) <br>
                            rand 함수에 사용될 수를 초기화 한다. 이 초기화를 매개변수로 받는 seed값을 이용해서 합니다. <br>
                          </li>
                          <li>
                            time_t time(time_t* timer); <br>
                            UCT 기준 1970년 1월 1일 0시 0분 0초 부터 경과된 시간을 초(sec)로 반환하는 함수 
                          </li>
                        </ul>
                      </p>
                      <p>
                        매크로(#define) <br>
                        매크로란 어떤 것을 대신하여 사용하는 이름을 말한다. 즉, 어떤 특정한 값이나 처리 명령어를 하나의 이름을 부여하고 그 특정한 값이나 처리 명령어를 사용할 때 부여한 이름을 사용하여 대신 코딩하는 것을 말합니다. 
                        <pre>
                          <code class="C" >
#include &lt;stdio.h>

#define MAIN main(int argc, char *argv[])
#define BEGIN {
#define END } 
#define OUTPUT printf

MAIN
BEGIN
OUTPUT("Hello World! \n");
END
                          </code>
                        </pre>
                      </p>
                      <hr>
                      <Strong>덱(double-ended queue)</Strong> <br>
                      덱은 double-ended queue이 줄임말로서 큐의 전달과 후단에서 모두 삽입과 삭제가 가능한 큐를 의미한다. 그렇지만 여전히 중간에 삽입하거나 삭제하는 것은 허용하지 않는다. 
                      <hr>
                      <pre>
                        <code class="C" >
객체 : n개의 element형의 요소들의 순서 있는 모임 
연산 :
    create() ::= 덱을 생성한다. 
    init(dq) ::= 덱을 초기화한다. 
    is_empty(dq) ::= 덱이 공백상태인지를 검사한다. 
    is_full(dq) ::= 덱이 포화 상태 인지를 검사한다. 
    add_front(dq, e) ::= 덱의 앞에 요소를 추가한다. 
    add_rear(dq, e) ::= 덱의 뒤에 요소를 추가한다. 
    delete_front(dq) ::= 덱의 앞에 있는 요소를 반환한 다음 삭제한다. 
    delete_rear(dq) ::= 덱의 뒤에 있는 요소를 반환한 다음 삭제한다. 
    get_front(q) ::= 덱의 앞에서 삭제하지 않고 앞에 있는 요소를 반환한다.
    get_rear(q) ::= 덱의 뒤에서 삭제하지 않고 뒤에 있는 요소를 반환한다. 
                        </code>
                      </pre>
                      <hr>
                      배열을 이용한 덱의 구현 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_QUEUE_SIZE 5
typedef int element;
type struct {
  element data[MAX_QUEUE_SIZE];
  int fornt, rear;
} DequeType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

void init_deque(DequeType *q){
  q -> front = q -> rear = 0;
}

void is_empty(DequeType *q){
  return ( q -> front == q -> rear );
}

int is_full(DequeType *q){
  return ((q->rear + 1) % MAX_QUEUE_SIZE == q -> front );
}

void deque_print(DequeType *q){
  printf("DEQUE(fornt=%d rear=%d) = ", q -> front, q -> rear );
  if(!is_empty(q)){
    int i = q -> front;
    do {
      i = ( i + 1 ) % ( MAX_QUEUE_SIZE );
      printf("%d | ", q -> data[i]);
      if ( i == q -> rear )
        break;
    } while ( i != q -> front );
  }
  printf("\n");
}

void add_rear(DequeType *q, element item){
  if(is_full(q))
    error("큐가 포화상태입니다.");
  q -> rear = ( q -> rear + 1 ) % MAX_QUEUE_SIZE;
  q -> data[q -> rear ] = item;
}

element delete_front(DequeType *q){
  if(is_empty(q))
    error("큐가 공백상태입니다.");
  q -> front ( q -> front + 1) % MAX_QUEUE_SIZE;
  return q -> data[q->front];
}

element get_front(DequeType *q){
  if(is_empty(q))
    error("큐가 공백상태입니다.");
  return q -> data[( q -> front + 1) % MAX_QUEUE_SIZE];
}

void add_front(DequeType *q, element val){
  if ( is_full(q) )
    error("큐가 포화상태입니다.");
  q -> data[q -> front] = val;
  q -> front = ( q -> front - 1 + MAX_QUEUE_SIZE) % MAX_QUEUE_SIZE;
}

element delete_rear(DequeType *q){
  int prev = q -> rear;
  if(is_empty(q))
    error("큐가 공백상태입니다.");
  q -> rear = ( q -> rear - 1 + MAX_QUEUE_SIZE) % MAX_QUEUE_SIZE;
  return q -> data[prev];
}

element get_rear(DequeType *q){
  if(is_empty(q))
    error("큐기 공백 상태입니다. ");
  return q -> data[q -> rear];
}

int main(void){
  DequeType queue;

  init_deque(&queue);
  for ( int i = 0; i &lt; 3 ; i ++ ){
    add_front(&queue, i);
    deque_print(&queue);
  }
  for ( int 1 = 0; i &lt; 3 ; i ++ ){
    delete_rear(&queue);
    delete_print(&queue);
  }
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      큐는 주로 컴퓨터로 큐잉이론에 따라 시스템의 특성을 시물레이션하여 분석하는 데 이용한다. 큐잉 모델은 고객에 대한 서비스를 수행하는 서버와 서비스를 받는 고객들로 이루어진다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef struct {
  int id;
  int arrival_time;
  int service_time;
} element;

int main(void){
  int minutes = 60;
  int total_wait = 0;
  int total_customers = 0;
  int service_time = 0;
  int service_customer;
  QueueType queue;
  init_queue(&queue);

  srand(time(NULL));
  for(int clock = 0;clock &lt; minutes; clock ++){
    printf("현재시각=%d\n", clock);
    if((rand()%10) &lt; 3){
      element customer;
      customer.id = total_customers ++;
      customer.arrival_time = clock;
      customer.service_time = rand() % 3 + 1;
      enqueue(&queue, customer);
      printf("고객 %d이 %분에 들어옵니다. 업무처리시간 = %d분 \n", customer.id, customer.arrival_time, customer.service_time);
    }
    if(servie_time > 0){
      printf("고객 %d 업무 처리중입니다. \n", service_customer);
      service_time ++''
    }else{
      if(!is_empty(&queue)){
        element customer = dequeue(&queue);
        service_customer = customer.id;
        service_time = customer.service_time;
        printf("고객 %d이 %분에 업무를 시작합니다. eo대기 시간은 %d 분이었습니다. \n", customer.id, clock, clock-customer.arrival_time);
        total_wait += clock - customer.arrival_time;
      }
    }
  }
  printf("전체 대기 시간 = %d분 \n", total_wait);
  return 0;
}
                        </code>
                      </pre>
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading15">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse15" aria-expanded="false" aria-controls="collapse15">
                        연결리스트 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse15" class="collapse" aria-labelledby="heading15" data-parent="#accordionExample">
                    <div class="card-body">
                      리스트와 소개 <br>
                      리스트에는 항목들이 차례대로 저장되어 있다. 리스트의 항목들은 순서 또는 위치를 가진다. 앞에서 살펴본 스택과 큐도 넓게 보면 리스트의 일종이다. 리스트는 기호로 같이 다음과 같이 표현한다. 
                      리스트는 집합하고는 다르다. 집합은 각 항목 간에 순서의 개념이 없다. <br>
                      L = ( item, tiem, time , ... , item ) <br>
                      <hr>
                      <pre>
                        <code class="C" >
객체 : n개의 element형으로 구성된 순서 있는 모임
연산 : 
    insert(list, pos, timer) ::= pos 위치에 요소를 추가한다. 
    insert_last(list, item) ::= 맨 끝에 요소를 추가한다. 
    insert_first(list, item) ::= 맨 처음에 요소를 추가한다. 
    delete(list, pos) ::= pos 위치의 요소를 제거한다. 
    clear(list) ::= 리스트의 모든 요소를 제거한다. 
    get_entry(list, pos) ::= pos 위치의 요소를 반환한다. 
    get_length(list) ::= 리스트의 길이를 구한다. 
    is_empty(list) ::= 리스트가 비었는지를 검사한다. 
    is_full(list) ::= 리스트가 꽉 차ㅉ는지를 검사한다. 
    print_last(list) ::= 리스트의 모든 요소를 표시한다.                           
                        </code>
                      </pre>
                      <hr>
                      배열을 사용하여 리스트를 구현하면 장점과 단점이 존재한다. 장점은 구현이 간단하고 속도가 빠르다는 것이다. 단점으로는 리스트의 크기가 고정된다는 것을 들 수 있다. 
                      <hr>
                      <strong>배열로 구현된 리스트</strong>
                      <pre>
                        <code class="C" >
#define MAX_LIST_SIZE 100

typedef int element;
typedef struct {
  element array[MAX_LIST_SIZE];
  int size;
} ArrayListType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

void init(ArrayListType *L){
  return L->size == 0;
}

int is_empty(ArrayListType *L){
  return L -> size == 0;
}

int is_full(ArrayListType *L){
  return L -> size == MAX_LIST_SIZE;
}

element get_entry(ArrayListType *L, int pos){
  if( pos &lt; 0  || pos >= L->size )
    error("위치 오류");
  return L -> array[pos];
}

void print_list(ArrayListType *L){
  int i;
  for ( i = 0; i &lt; L -> size; i ++){
    printf("%d ->" , L -> array[i]);
  }
  printf("\n");
}

void insert_last(ArrayListType *L, element item){
  if( L -> size >= MAX_LIST_SIZE ){
    error("리스트 오버플로우");
  }
  L -> array[L->size++] = item;
}

void insert(ArrayListType *L, int pos, element item){
  if(!is_full(L) && ( pos >= 0 ) && ( pos &lt;= L -> size )){
    for( int i = ( L -> size - 1 ); i >= pos; i --)
      L -> array[i+1] = L -> array[i];
    L -> array[pos] = item;
    L -> size ++;
  }
}

element delete(ArrayListType *L, int pos){
  element item;

  if( pos &lt; 0 || pos => L -> size )
    error("위치오류")
  item = L -> array[pos];
  for ( int i = pos; i &lt; ( L -> size - 1); i ++)
    L -> array[i] = L -> array[i+1];
  L -> size --;
  return item;
}

int main(void){
  ArrayListType list;

  init(&list);
  insert(&list, 0, 10); print_list(&list);
  insert(&list, 0, 20); print_list(&list);
  insert(&list, 0, 30); print_list(&list);
  insert_last(&list, 40); print_list(&list);
  delete(&list, 0); print_list(&list);
  return 0;
}

                        </code>
                      </pre>
                      실행 시간 분석 <br>
                      인덱스를 사용하여 항목에 바로 접근할 수 있으므로 명백히 O(1)이다. 삽입이나 삭제 연산은 다른 항목들을 이동하는 경우가 많으로 최악의 경우 O(n)이 된다. 하지만 리스트의 맨 끝에 삽입하는 경우는 O(1)이다. 
                      <hr>
                      <strong>연결 리스트</strong>
                      <hr>
                      물리적으로 흩어져 있는 자료들을 서로 연결하여 하나로 묶는 방법을 연결 리스트라고 한다. 상자를 연결하는 줄은 포인터로 구현한다. 연결 리스트에서는 앞뒤에 있는 데이터들을 이동할 필요가 없이 줄만 변경시켜주면 된다. <br>
                      연결리스트는 노드들의 집합이다. 노드들은 메모리의 어떤 위치에나 있을 수 있으며 다른 노드로 가기위해서는 현재 노드가 가지고 있는 포인터를 이용하면 된다. 노드는 데이터 필드와 링크 필드로 구성되어 있다. <br>
                      연결리스트의 종류 
                      <ul>
                        <li>단순 연결 리스트 </li>
                        <li>원형 연결 리스트 </li>
                        <li>이중 연결 리스트 </li>
                      </ul>
                      <hr>
                      <strong>단순 연결 리스트</strong> 
                      <br>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
                          
typedef int element;
typedef struct ListNode {
  element data;
  struct ListNode *link;
} ListNode;

// 오류 처리 함수 
void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

ListNode* insert_first(ListNode *head, int value){
  ListNode *p = ( ListNode * )malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = head; // 헤드 포인터의 값을 복사 
  head = p;         // 헤드 포인터 변경 
  return head;      // 벼녕된 헤드 포인터 변환 
}

// 노드 pre 뒤에 새로운 노드 삽입 
ListNode* insert(ListNode *head, ListNode *pre, element value){
  ListNode *p = (ListNode *)malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = pre -> link;
  pre -> link = p;
  return head;
}

ListNode* delete_first(ListNode *head){
  ListNode *remove;
  if ( head == NULL ) return NULL;
  removed = head;
  head = removed -> link;
  free(removed);
  return head;
}

// pre가 가리키는 노드의 다음 노드를 삭제한다. 
ListNode* delete(ListNode *head, ListNode *pre){
  ListNode *removed;
  removed = pre -> link;
  pre -> link = removed -> link;
  free(removed);
  return head;
}

void print_list(ListNode *head){
  for( ListNode * = head; p != NULL; p = p -> link ){
    printf("%d->"), p -> data);
  }
  printf("NULL \n");
}

int main(void){
  ListNode *head = NULL;

  for( int i = 0; i &lt; 5 ; i ++){
    head = insert_first(head, i);
    print_list(head);
  }

  for(int i = 0; i &lt; 5 ; i ++ ){
    head = delete_first(head);
    print_list(head);
  }

  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>단어들을 저장하는 연결 리스트</strong>  
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
$include &lt;string.h>

typedef struct {
  char name[100];
} element;

typedef struct ListNode {
    element data;
    struct ListNode *link;
} ListNode;

// 오류 처리 함수 
void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

ListNode* insert_first(ListNode *head, element value){
  ListNode * = (ListNode *)malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = head;
  head = p;
  return head;
}

void print_list(ListNode *head){
  for ( ListNode *p = head; p != NULL; p = p -> link )
    printf("%s ->", p -> data.name);
  printf("NULL \n");
}

int main(void){
  ListNode *head = NULL;
  element data;

  strcpy(data.name, "APPLE");
  head = insert_first(head, data);
  print_list(head);

  strcpy(data.name, "KIWI");
  head = insert_first(head, data);
  print_list(head);

  strcpy(data.name, "BANANA");
  head = insert_first(head, data);
  print_list(head);

  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>특정 한 값을 탐색하는 함수</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef int element;

typedef struct ListNode{
    element data;
    struct ListNode *link;
} ListNode;

ListNode* insert_first(ListNode *head, element value){
  ListNode *p = (ListNode *)malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = head;
  head = p;
  return head;
}

void print_line(ListNode *head){
  for ( ListNode *p = head; p != NULL; p = p -> link)
    printf("%d -> ", p -> data);
  printf("NULL \n");
}

ListNode* search_list(ListNode *head, element x){
  ListNode *p = head;

  while( p != NULL){
    if( p -> data == x) return p;
    p = p -> link;
  }
  return NULL;
}

int main(void){
  ListNode *head = NULL;

  head = insert_first(head, 10);
  print_last(head);
  head = insert_first(head, 20);
  print_last(head);
  head = insert_first(head, 30);
  print_last(head);
  if( search_list(head, 30) != NULL){
    printf("리스트에서 30을 찾았습니다. \n");
  }else {
    printf("리스트에서 30을 찾지 못했습니다. \n");
  }
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>두 개의 리스트를 하나로 합치는 것</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef int element;
typedef struct LietNode {
  element data;
  struct ListNode *link;
} ListNode;

ListNode* insert_first(ListNode *head, element value){
  ListNode *p = (ListNode *)malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = head;
  head = p;
  return head;
}

void print_list(ListNode *head){
  for ( ListNode *p = head; p != NULL; p = p -> link)
    printf("%d -> ", p -> data);
  printf("NULL \n");
}

ListNode* concat_list(LietNode *head1, ListNode *head2){
  if(head1 == NULL) return head2;
  else if(head2 == NULL) return head1;
  else {
    ListNode *p;
    p = head1;
    while(p -> link != NULL)
      p = p -> link;
    p -> link = head2;
    return head1;
  }

  int main(void){
    ListNode* head1 = NULL;
    ListNode* head2 = NULL;

    head1 = insert_first( head1, 10);
    head1 = insert_first( head1, 20);
    head1 = insert_first( head1, 30);
    print_list(head1);

    head2 = insert_first( head2, 10);
    head2 = insert_first( head2, 10);
    print_list(head2);

    ListNode *total = concat_list(head1, head2);
    print_list(total);
    return 0;
  }
}


                        </code>
                      </pre>
                      <hr>
                      <strong>리스트를 역순으로 만드는 연산</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h> 
#include &lt;stdlib.h>

typedef int element;

typedef struct ListNode {
  element data;
  struct ListNode *link;
} ListNode;

ListNode* insert_first(ListNode *head, element value){
  ListNode *p = (LietNode *)malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = head;
  head = p;
  return head;
}

void print_list(LietNode *head){
  for ( ListNode *p = head; p != NULL; p = p -> link)
    printf("%d->",  p -> data);
  printf("NULL \n");
}

ListNode* reverse(ListNode *head){
  ListNode *p, *q, *r;

  p = head;
  q = NULL;
  while( p != NULL ){
    r = q;

    q = p;

    p = p -> link;
    q -> link;
  }
  return d;
}

int main(void){
  ListNode* head1 = NULL;
  ListNode* head2 = NULL;

  head1 = insert_first(head1, 10);
  head1 = insert_first(head1, 20);
  head1 = insert_first(head1, 30);
  print_list(head1);

  head2 = reverse(head1);
  print_list(head2);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>다항식 덧셈 프로그램</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef struct ListNode {
  int coef;
  int expon;
  struct ListNode *link;
} ListNode;

typedef struct ListType {
  int size;
  ListNode *head;
  ListNode *tail;
} ListType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

ListType* create(){
  ListType *plist = (ListType *)malloc(sizeof(ListType));
  plist -> size = 0;
  plist -> head = plist -> tail  = NULL;
  return plist;
}

void insert_last(ListType* plist, int coef, int expon){
  ListNode* temp = (ListNode *)malloc(sizeof(ListNode));
  if ( temp == NULL ) error("메모리 할당 에러");
  temp -> coef = coef;
  temp -> expon = expon;
  temp -> link = NULL;
  if(plist -> tail == NULL) {
    plist -> head = plist -> tail = temp;
  }else{
    plist -> tail -> link = temp;
    plist -> tail = temp;
  }
  plist -> size ++;
}

void poly_add(ListType* plist1, ListType* plist2, ListType* plist3){
  ListNode* a = plist1 -> head;
  ListNode* b = plist2 -> head;

  int sum;

  while( a && b ){
    if ( a -> expon == b -> expon ){
      sum = a -> coef + b -> coef;
      if( sum != 0) insert_last(plist3, sum, a -> expon);
      a = a -> link; b = b -> link;
    }else if( a -> expon -> b -> expon) {
      insert_last(plist3, a -> coef, a -> expon );
      a = a -> link;
    }else {
      insert_last(plist3, b -> coef, b -> expon );
      b = b -> link;
    }
  }

  for( ; a != NULL ; a = a -> link)
    insert_last(plist3 , a -> coef, a -> expon );
  for( ; b != NULL ; b = b -> link)
    insert_last(plist3 , b -> coef, b -> expon );

}

void poly_print(ListType* plist){
  ListNode* p = plist -> head;

  printf("polynomial = ");
  for( ; p != NULL ; p = p -> link)
    printf("%d^%d + " , p -> coef, p -> expon );
  pintf("\n");
}

int main(void){
  ListType *list1, *list2, *list3;

  list1 = create();
  list2 = create();
  list3 = create();

  insert_last(list1, 3, 12);
  insert_last(list1, 2, 8);
  insert_last(list1, 1, 0);

  insert_last(list2, 8, 12);
  insert_last(list2, -3, 10);
  insert_last(list2, 10, 6);

  poly_print(list1);
  poly_print(list2);

  poly_add(list1, list2, list3);

  poly_print(list3);

  free(list1);
  free(list2);
  free(list3);
}
                        </code>
                      </pre>
                      <hr>
                      <strong>원형 연결 리스트</strong>
                      <hr>
                      원형 연결 리스트란 마지막 노드가 마지막 노드가 벛 번재 노드를 가리키는 리스트이다. 즉 마지막 노드의 링크 필드가 NULL이 아니라 첫번째 노드 주소가 되는 리스트이다. <br>
                      원경 연결 리스트에서는 하나의 노드에서 다른 모든 노드로의 접근이 가능하다. 하나의 노드에서 링크를 계혹 따라가면 결국 모든 모드를 거쳐서 자기 자신으로 되돌아 올 수 있는 것이다.  <br>
                      원형 연결 리스트가 특히 유용한 경우는 리스트의 끝에 노드를 삽입하는 연산이 단순 연결 리스트 보다 효율적일 수 있다는 것이다. 단순 연결 리스트에서 리스트의 끝에 노드를 추가하려면 첫 번째 노드에서부터 링크를 따라서 노드의 개수만큼 
                      진행하여 마지만 노드까지 가야한다. 그러나 만약 원형 연결 리스트에서 다음과 같이 헤드 포인터가 마지만 노드를 가라키도록 구성한다면 상수 시간 안에 리스트의 처음과 끝에 노드를 삽입할 수 있다. 
                      <pre>
                        <code class="C" >  
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef int element;
typedef struct ListNode {
  element data;
  struct ListNode *link;
} ListNode;

void print_list(ListNode* node){
  ListNode* p;

  if ( head == NULL) return;
  p = head -> link;
  do {
    printf("%d->",  p -> data);
    p = p -> link;
  } while ( p != head );
  printf("%d->", p -> data);
}

ListNode* insert_first(ListNode* head, element data){
  ListNode *node = (ListNode *)malloc(sizeof(ListNode));
  node -> data = data;
  if( head == NULL ){
    head = node;
    node -> link = head;
  }else {
    node -> link = head -> link;
    head -> link = node;
  }
  return head; // 변형된 헤드 포인터를 반환한다. 
}

ListNode* insert_last(ListNode* head, element data){
  ListNode *node = (ListNode *)malloc(sizeof(ListNode));
  node -> data = data;
  if( head == NULL ){
    head = node;
    node -> link = node;
  }else {
    node -> link = head -> link;
    head -> link = node;
    head = node;
  }
  return head; // 변경된 헤드 포인터를 반환한다. 
}

int main(void){
  ListNode *head = NULL;

  head = insert_last(head, 20);
  head = insert_last(head, 30);
  head = insert_last(head, 40);
  head = insert_first(head, 10);
  print_last(head);
  return 0;
}

                        </code>
                      </pre>
                      <hr>
                      <strong>용례</strong>
                      <hr>
                      컴퓨터에서 여러 응용 프로그램을 하나의 CPU를 이용하여 실행할 때에 필요하다. 현재 실행중인 모든 응용 프로그램은 원형 연결 리스트에 보관되며 운영 체제는 원형 연결 리스트에 있는 프로그램의 실행을 위해 고정된 시간 슬롯을 제공한다. <br>
                      멀티플레이어 게임이다. 모든 플에이어는 원형 연결 리스트에 저장되며 한 플레이어의 기회가 끝나면 포인터 앞으로 움직여서 다음 플레이어의 순서가 된다. <br>
                      원형 연결 리스트는 원형 큐를 만드는데도 사용할 수 있다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>

typedef char element[100];
typedef struct ListNode {
  element data;
  struct ListNode *link;
} ListNode;

ListNode* insert_first(ListNode* head, element data){
  ListNode *node = (ListNode *)malloc(sizeof(ListNode));
  strcpy(node -> data, data);
  if ( head == NULL ) {
    head = node;
    node -> link = head;
  }else {
    node -> link = head -> link;
    head -> link = node;
  }
  return head;
}

int main(void){
  ListNode *head = NULL;

  head = insert_first(head, "KIM");
  head = insert_first(head, "PARK");
  head = insert_first(head, "CHOI");

  ListNode* p = head;

  for(int i = 0; i &lt; 10; i ++){
    printf("현재 차례=%s \n", p -> data);
    p = p -> link;
  }
  return 0;0
}
                        </code>
                      </pre>
                      <hr>
                      <strong>이중 연결 리스트</strong>
                      <hr>
                      단순 연결 리스트에서 어떤 노드에서 후속 노드를 찾기는 쉽지만, 선행 노드를 찾으려면 구조상 아주 어렵다. 원형 연결 리스트라고 하더라도 거의 전체 노드를 거쳐서 돌아 와야 한다. 따라서 응용 프로그램에서 
                      특정 노드에서 양방향으로 자유롭게 움직일 필요가 있다면 단순 연결 리스트 구조는 부적합하다. 이중 연결 리스트는 이러한 문제점을 해결하기 위하여 만들어진 자료구조이다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef int element;
typedef struct DListNode {
  element data;
  struct DListNode* llink;
  struct DListNode* rlink;
} DListNode;

void init(DListNode* phead){
  phead -> llink = phead;
  phead -> rlink = phead;
}

void print_dlist(DListNode* phead){
  DListNode* p;
  for( p = phead -> rlink; p != phead; p = p -> rlink){
    printf("&lt;-| |%d| |->", p -> data);
    printf("\n");
  }
}

void dinsert(DListNode *before, element data){
  DListNode *newnode = (DListNode *)malloc(sizeof(DListNode));
  strcpy(newnode -> data, data);
  newnode -> llink = before;
  newnode -> rlink = before -> rlink;
  before -> rlink -> llink = newnode;
  before -> rlink = newnode;
}

void ddelete(DListNode* head, DListNode* removed){
  if( removed == head ) return;
  removed -> llink -> rlink = removed -> rlink;
  removed -> rlink -> llink = removed -> llink;
  free(removed);
}

int main(void){
  DListNode* head = (DListNode *)malloc(sizeof(DListNode));
  init(head);
  printf("추가 단계 \n");
  for( int 1 = 0; i &lt; 5 ; i ++ ) {
    dinsert(head, i);
    print_dlist(head);
  }
  printf("\n삭제단계\n");
  for( int i = 0; i &lt; 5 ; i ++){
    print_list(head);
    ddelete(head, head -> rlink);
  }
  free(head);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>MP3</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h> 
#include &lt;stdlib.h> 
#include &lt;string.h> 

typedef char element[100];
typedef struct DListNode {
  element data;
  struct DListNode* link;
  struct DListNode* rlink;
} DListNode;

DListNode* current;

void init(DListNode* phead){
  phead -> llink = phead;
  phead -> rlink = phead;                                                                                                                                                                                                                                                                                                                                                                     
}

void print_dlist(DListNode* phead){
  DListNode* p;
  for ( p = phead -> rlink ; p != phead; p = p -> rlink ){
    if( p == current )
      printf("&lt;- | #%s# | ->", p -> data);
    else 
      printf("&lt;- | #%s# | ->". p -> data);
  }
  printf("\n");
}

void dinsert(DListNode *bedore, element data){
  DListNode *newnode = (DListNode *)malloc(sizeof(DListNode));
  strcpy(newnode -> data, data);
  newnode -> llink = before;
  newnode -> rlink = before -> rlink;
  before -> rlink = llink = newnode;
  before -> rlink = newnode;
}

void delete(DListNode* head, DListNode* removed){
  if ( removed == head) return;
  removed -> llink -> rlink = removed -> rlink;
  removed -> rlink -> llink = removed -> llink;
  free(removed);
}

int main(void){
  char ch;
  DListNode* head = (DListNode *)malloc(sizeof(DListNode));
  init(head);

  dinsert(head, "Mamamia");
  dinsert(head, "Dancing Queen");
  dinsert(head, "Fernade");

  current = head -> rlink;
  print_dlist(head);

  do {
    printf("\n명령어를 입력하시오(&lt;,>, q");
    ch = getchar();
    if(ch == '&lt;') {
      current = current -> llink;
      if ( current == head )
        current = current -> llink;
    }else if(ch == '>'){
      current = current -> rlink;
      if ( current ==  head )
        current = current -> rlink; 
    }
    print_dlist(head);
    getchar();
  } while( ch != 'q');
}
                        </code>
                      </pre>
                      <hr>
                      <strong>연결 리스트로 구현한 스택</strong>
                      <hr>
                      <pre>
                        <code class="C" >
typedef int element;
typedef struct StackNode {
  element data;
  struct StackNode *link;
} StackNode;

typedef struct {
  StackNode *top;
} LinkedStackType;

void init(LinkedStackType *s){
  return ( s -> top == NULL ); 
}

int is_full(LinkedStackType *s){
  return 0;
}

void push(LinkedStackType *s, element item){
   StackNode *temp = (StackNode *)malloc(sizeof(StackNode));
   temp -> data = item;
   temp -> link = s -> top;
   s -> top = temp;
}

void print_stack(LinkedStackType *s){
  for ( StackNode *p =  s -> top ; p != NULL; p = p -> link )
    printf("%d -> ", p -> data);
  printf("NULL \n");
}

void pop(LinkedStackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택이 비어있음\n");
    exit(1);
  }else {
    StackNode *temp = s -> top;
    int data = temp -> data;
    s -> top = s -> top -> link;
    free(temp);
    return data;
  }
}

element peek(LinkedStackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택이 비어있음\n");
    exit(1);
  }else{
    return s -> top -> data;
  }
}

int main(void) {
  LinkedStackType s;
  init(&s);

  push(&s, 1); print_stack(&s);
  push(&s, 2); print_stack(&s);
  push(&s, 3); print_stack(&s);

  pop(&s); print_stack(&s);
  pop(&s); print_stack(&s);
  pop(&s); print_stack(&s);

  return 0;
}


                        </code>
                      </pre>
                      <hr>
                      <strong>연결 리스트로 구현한 큐</strong>
                      <hr>
                      <pre>
                        <code class="C"  >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef int element;
typedef struct QueueNode {
    element data;
    stuct QueueNode *link;
} QueueNode;

typedef stuct {
  QueueNode *front, *rear;
} LinkedQueueType;

void init(LinkedQueueType *q){
  q -> front = q -> rear = 0;
}

int is_full(LinkedQueueType *q){
  return 0;
}

void enqueue(LinkedQueueType *q, element data){
  QueueNode  *temp = (QueueNode *)malloc(sizeof(QueueNode));
  temp -> data = data;
  temp -> link = NULL;
  if(is_empty(q)){
    fprintf(stderr, "스택이 비어 있음\n");
    exit(1);
  }else {
    data = temp -> data;
    q -> front = q -> front -> link;
    if ( q -> front == NULL )
      q -> rear = NULL;
    free(temp);
    return data;
  }
}


void print_queue(LinkedQueueType *q){
  QueueNode *p;
  for ( p = q -> front ; p != NULL; p = p -> link)
    printf("%d ->", p -> data);
  printf("NULL \n");
}

int main(void){
  LinkedQueueType queue;

  init(&queue);

  enqueue(&queue, 1); print_queue(&queue);
  enqueue(&queue, 2); print_queue(&queue);
  enqueue(&queue, 3); print_queue(&queue);
  dequeue(&queue); print_queue(&queue);
  dequeue(&queue); print_queue(&queue);
  dequeue(&queue); print_queue(&queue);
  
  return 0;
}
                        </code>
                      </pre>
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading16">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse16" aria-expanded="false" aria-controls="collapse16">
                        트리  
                      </button>
                    </h2>
                  </div>
                  <div id="collapse16" class="collapse" aria-labelledby="heading16" data-parent="#accordionExample">
                    <div class="card-body">
                      만약 자료가 계층적인 구조를 가지고 있다면 어떻게 해야하는 가? 예를 들어 가족의 가계도, 회사의 조직도, 컴퓨터의 디렉토리 구조 등의 자료는 어떻게 표현해야 하는가? <br>
                      트리는 이러한 계층적인 자료를 표현하는데 적합한 자료구조이다. 
                      <hr>
                      A는 B의 부모 노드가 된다. 반대로 B는 A의 자식 노드(children)가 된다. B와 C와 D는 형제관계(sibiling)이다. 조상, 후손, 손자, 조부모 노드도 마찬가지이다. 조상 노드(ancestor)란 루트 노드에서 임의 노드까지 경로를 이루고 있는 
                      노드들을 말한다. 후손노드(descendent node)는 임의의 노드 하뉘에 연결된 모드 노드들을 의미한다. 즉 어떤 노드의 서브 트리에 속하는 모든 노드들은 후손 노드이다. 또한 자식 노드가 없는 노드를 단말 노드라고 한다.  <br>
                      노드의 차수는 어떤 노드가 가지고 있는 자식 노드의 개수를 의미한다. 트리의 높이는 트리가 가지고 있는 최대 레벨을 말한다. 도한 나무가 모이는 숨이 되듯이 트리들의 집합을 포리스트라고 한다. <br>
                      <strong>트리의 종류</strong><br>
                      <ul>
                        <li>일반트리</li>
                        <li>이진트리</li>
                      </ul>
                      <hr>
                      <strong>이진트리</strong>
                      <hr>
                      모든 노드가 2개의 서브트리를 가지고 있는 트리를 이진 트리라고 한다. 서브 트리는 공집합일 수 있다. 노드에는 최대 2개 까지의 자식 노드가 존재할 수 있고 
                      모든 노드의 차수가 2 이하가 된다. 공집합도 이진 트리라는 점에 주의하라. 또한 이진 트리에는 서브 트리간의 순서가 존재한다. 따라서 왼쪽 서브 트리와 
                      오른쪽 서브 트리는 서로 구별된다. 
                      <br>
                        <ul>
                          <li>이진 트리의 모든 노드는 차수가 2이하이다. 즉 자신 노드의 개수가 2이하이다. 반면 일반 트리는 자식 노드의 개수에 제한이 없다.</li>
                          <li>일반 트리와 달리 이진 트리는 노드를 하나도 같지 않을 수도 있다. </li>
                          <li>서브 트리간에 순서가 존재한다는 점도 다른 점이다. 따라서 왼쪽 서브트리와 오른쪽 서브트리를 구별한다. </li>
                        </ul>
                      <P>
                        수학에서 공집합은 원소가 하나도 없는 집합을 이야기한다. 
                      </P>
                      이진트리의 성질 <br>
                      n 개의 노드를 가진 이진 트리는 정확하게 n - 1 의 간선을 가진다. 그 이유는 이진트리에서의 노드는 루트를 제외하면 정확하게 하나의 부모 노드를 가진다. 그리고 부모와 자식간에는 정확하게 하나의 간선만이 존재한다. <br>
                      높이가 h인 이진 트리는 , 최소 h 개의 노드를 가지며 최대 2^h - 1 개의 노드를 가진다. <br>
                      n 개의 노드를 가지는 이진트리의 높이는 최대 n 이거나 최소 [log2(n+1)]이 된다. <br>
                      이진트리의 분류 <br>
                      <ul>
                        <li>포화 이진 트리 : 트리의 각 레벨의 노드가 꽉 차있는 이진 트리를 의미한다. 즉 높이 k 인 포화 이진 트리는 정확하게 2^k-1 개의 노드를 가진다. </li>
                        <li>완전 이진 트리 : 높이가 k 일 때 레벨 1부터 k - 1 까지는 노드가 모두 채워져 있고, 마지만 레벨 k 에서는 왼쪽부터 오른쪽으로 노드가 순서대로 채워져있는 이진트리이다. 마지막 레벨에서는 노드가 꽉 차있지 않아도 되지만 중간에 빈곳이 있어서는 안된다. </li>
                        <li>기타 이진 트리</li>
                      </ul>
                      <hr>
                      <strong>배열 표현법</strong>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;memory.h>

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode

int main(void){
  TreeNode *n1, *n2, *n3;
  n1 = (TreeNode *)malloc(sizeof(TreeNode));
  n2 = (TreeNode *)malloc(sizeof(TreeNode));
  n3 = (TreeNode *)malloc(sizeof(TreeNode));

  n1 -> data = 10; // 첫번째 노드를 설정한다.
  n1 -> left = n2;
  n1 -> right = n3;
  n2 -> data = 20; // 두번째 노드를 설정한다. 
  n2 -> left = NULL;
  n2 -> right = NULL;
  n3 -> data = 30; // 세번째 노드를 설정한다. 
  n3 -> left = NULL;
  n3 -> right = NULL;

  free(n1);
  free(n2);
  free(n3);

  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>이진 트리의 순회</strong>
                      <hr>
                      데이터는 노드의 데이터 필드를 이용하여 저장된다. 이진 트리를 순회한다는 것은 이진 트리에 속하는 모든 노드를 한 번씩 방문하여 노드가 가지고 있는 데이터를 목적에 맞게 처리하는 것을 의미한다. 
                      <hr>
                      <strong>이진 트리 순회 방법</strong>
                      <hr>
                      이진 트리를 순회하는 표준적인 방법에는 전위, 중위, 후위의 3가지 방법이 있다. 루트 방문하는 작업을 V라고 하고 왼쪽 서브 트리 방문을 L, 오른쪽 서브트리 방문을 R이라고 하면 다음 과 같이 3가지 방법을 생각할 수 있다. 
                      즉 루트를 서브 트리에 앞서서 먼저 방문하면 전위순회, 루트를 왼쪽과 오른쪽 서브트리 중간에 방문하면 중위순회, 루트를 서브 트리 방문 후에 방문하면 후위 순회가 된다. 
                      <hr>
                      <ul>
                        <li>전위 순회 : VLR 
                          <ul>
                            <li>1. 루트 노드를 방문한다.</li>
                            <li>2. 왼쪽 서브트리를 방문한다.</li>
                            <li>3. 오른쪽 서브트리를 방문한다.</li>
                          </ul>

                        </li> 
                        <li>중위 순회 : LVR 
                          <ul>
                            <li>1. 왼쪽 서브트리를 방문한다. </li>
                            <li>2. 루트노드를 방문한다. </li>
                            <li>3. 오른쪽 서브트리를 방문한다. </li>
                          </ul>
                        </li>
                        <li>후위 순회 : LRV 
                          <ul>
                            <li>1. 왼쪽 서브트리의 모든 노드를 방문한다. </li>
                            <li>2. 오른쪽 서브트리의 모든 모드를 방문한다. </li>
                            <li>3. 루트노드를 방문한다. </li>
                          </ul>
                        </li>
                      </ul>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;memory.h>

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode;

TreeNode n1 = { 1, NULL, NULL };
TreeNode n2 = { 4, &n1 , NULL };
TreeNode n3 = { 16, NULL, NULL };
TreeNode n4 = { 25, NULL, NULL };
TreeNode n5 = { 20, &n3, &n4 };
TreeNode n6 = { 15, &n2, &n5 };
TreeNode *root = &n6;

void inorder(TreeNode *root){
  if( root != NULL ){
    inorder(root -> left);
    printf("[%d] ", root -> data);
    inorder(root -> right);
  }
}

void preorder(TreeNode *root){
  if( root != NULL ) {
    printf("[%d] ", root -> data);
    preorder(root -> left);
    preorder(root -> right);
  }
}

void postorder(TreeNode *root){
  if( root != NULL ) {
    postorder(root -> left);
    postorder(root -> right);
    printf("[%d] ", root -> data);
  }
}

int main(void){
  printf("중위 순회=");
  inorder(root);
  printf("\n");

  printf("전위 순회=");
  pre0order(root);
  printf("\n");

  printf("후위 순회=");
  postorder(root);
  printf("\n");

  return 0;
}

                        </code>
                      </pre>
                      <hr>
                      <strong>반복에 의한 순회</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;memory.h>

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode;

#defined SIZE 100
int top = -1;
TreeNode *stack[SIZE];

void push(TreeNode *p){
  if ( top &lt; SIZE - 1 )
    stack[++top] = p;
}

TreeNode *pop(){
  TreeNode *p = NULL;
  if ( top >= 0 )
    p = stack[top--];
  return p;
}

void inorder_iter(TreeNode *root){
  while(1) {
    for( ; root; root = root -> left )
      push(root);
    root = pop();
    if(!root) break;
    printf("[%d] ", root -> data );
    root = root -> right;
  }
}

TreeNode n1 = { 1, NULL, NULL };
TreeNode n2 = { 4, &n1 , NULL };
TreeNode n3 = { 16, NULL, NULL };
TreeNode n4 = { 25, NULL, NULL };
TreeNode n5 = { 20, &n3, &n4 };
TreeNode n6 = { 15, &n2, &n5 };
TreeNode *root = &n6;

int main(void){
  printf("중위 순회 =");
  inorder_iter(root);
  printf("\n");
  return 0;
}


                        </code>
                      </pre>
                      <hr>
                      <strong>레벨 순회</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;memeory.h> 

typedef stuct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode;

#define MAX_QUEUE_SIZE 100
typedef TreeNode * element;
typedef struct {
  element data[MAX_QUEUE_SIZE];
  int front, rear;
} QueueType;

void error(char *message){
  fprintf(stderr, "%s\n" , message);
  exit(1);
}

void init_queue(QueueType *q){
  q -> front = q -> rear = 0;
}

void is_empty(QueueType *q){
  return ( q -> front  == q -> rear );
}

int is_full(QeueuType *q){
  return ( ( q -> rear + 1) % MAX_QUEUE_SIZE == q -> front );
}

void enqueue(QueueType *q, element item){
  if( is_full(q) )
    error("큐 포화상태입니다.");
  q -> rear = ( q -> rear + 1) % MAX_QUEUE_SIZE;
  q -> data[q-> rear] = item;
}

void dequeue(QueueType *q){
  if(is_empty(q))
    error("큐가 공백상태입니다.");
  q -> front = ( q -> front + 1) % MAX_QUEUE_SIZE;
  return q -> data[q -> front];
}

void level_order(TreeNode *ptr){
  QeueuType q;

  init_queue(&q);

  if ( ptr == NULL ) return;

  enqueue(&q, ptr);

  while(!is_empty(&q)){
    ptr = dequeue(&q);
    printf(" [%d] ", ptr -> data );
    if ( ptr -> left )
      enqueue(&q, ptr -> left);
    if ( ptr -> right )
      enqueue(&q, ptr -> right);
  }
}


TreeNode n1 = { 1, NULL, NULL };
TreeNode n2 = { 4, &n1 , NULL };
TreeNode n3 = { 16, NULL, NULL };
TreeNode n4 = { 25, NULL, NULL };
TreeNode n5 = { 20, &n3, &n4 };
TreeNode n6 = { 15, &n2, &n5 };
TreeNode *root = &n6;

int main(void){
  printf("레벨 순회 =");
  level_order(root);
  printf("\n");
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>수식 트리 처리</strong><br>
                      이진 트리는 수식 트리를 처리하는 데 사용될 수 있다. 수식 트리는 산술 연산자와 피 연산자로 만들어진다. 피연산자들은 단말 노트가 되며 연산자는 비단말 노드가 된다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h> 

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode;


TreeNode n1 = { 1, NULL, NULL };
TreeNode n2 = { 4, NULL , NULL };
TreeNode n3 = {'*', &n1 , &n2 };
TreeNode n4 = { 16, NULL, NULL };
TreeNode n5 = { 25, NULL, NULL };
TreeNode n6 = { '+', &n4 , &n5 };
TreeNode n6 = { '+', &n3 , &n6 };
TreeNode *exp = &n7;

int evaluate(TreeNode *root){
  if ( root == NULL )
    return 0;
  if ( root -> left == NULL && root -> right == NULL )
    return root -> data;
  else {
    int op1 = evaluate(root -> left);
    int op2 = evaluate(root -> right);
    printf("%d %c %d을 계산합니다. \n", op1, root -> data, op2);
    switch(root -> data) {
      case '+' :
        return op1 + op2;
      case '-' :
        return op1 - op2;
      case '*' :
        return op1 * op2;
      case '/' :
        return op1 / op2;
    }
  }
  return 0;
}

int main(void) {
  printf("수식의 값은 %d 입니다.", evaluate(exp));
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>디렉토리 용량 계산</strong>
                      <pre>
                        <code class="C">
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode;

int calc_dir_size(TreeNode *root){
  int left_size, right_size;
  if( root == NULL ) return 0;

  left_size = calc_dir_size(root -> left);
  right_size = clac_dir_size(root -> right);
  return ( root -> data + left_size + right_size );
}

int main(void){
  TreeNode n4 = { 500, NULL, NULL };
  TreeNode n5 = { 200, NULL, NULL };
  TreeNode n3 = { 100, &n4, &n5 };
  TreeNode n2 = { 50, NULL, NULL };
  TreeNode n1 = { 0, &n2, &n3 };
0
  printf("디렉토리의 크기 = %d\n", calc_dir_size(&n1));
}
                        </code>
                      </pre>
                      <hr>
                      <strong>이진트리 추가 연산</strong>
                      <pre>
                        <code class="C" >
// 노드의 개수 
int get_node_count(TreeNode *node){
  int count = 0;

  if( node != NULL ){
    count = 1 + get_node_count(node -> left) + get_node_count(node -> right);
  }
}

// 단말 노드 개수 구하기 
int get_leaf_count(TreeNode *node){
  int count = 0;

  if ( node != NULL ) {
    if ( node -> left == NULL && node -> right == NULL )
      return 1;
    else 
      count = get_leaf_count(node -> left) + get_leaf_count(node -> right );
  }

  return count;
}

// 높이 구하기 
int get_height(TreeNode *node) {
  int height = 0;

  if ( node != NULL ) {
    height = 1 + max(get_height(node -> left), get_height(node -> right ));
  } 

  return height;
}

                        </code>
                      </pre>
                      <hr>
                      <strong>스레드 이진 트리</strong><br>
                      이진 트리 순회는 순환 호출을 사용한다. 순환 호출은 함수를 호출해야되므로 상당히 비효율 적일 수가 있다. 이진 트리 순회도 노드의 개수가 많이지고 트리의 높이가 커지게 되면 상당히 비효율 적일 수 있다. 
                      <br>
                      그렇다면 순환 없이 노드를 순회할 수 있는 방법은 무엇이 있을까? 
                      <br>
                      우리는 이진 트리의 노드에 많은 NULL링크들이 존재함을 알고 있다. 만약 트리의 노드의 개수를 n개 라고 하면 각 노드당 2개의 링크가 있으므로 총 링크의 개수는 2n이 되고 이들 링크 중에서 
                      n - 1 개의 링크들이 루트노드를 제외한 n -1 개의 다른 노드들을 가리킨다. 따라서 2n 개 중에서 n - 1 은 NULL 링크가 아니지만 나머지 n + 1 개의 링크는 NULL임을 알 수 있다. 따라서 하나의 아이디어는 
                      이들 NULL 링크를 잘 사용하여 순환호출 없이도 트리의 노드들을 순회할 수 있도록 하자는 것이다. 
                      <hr>
                      노드의 개수 : 2개 ( n ) <br>
                      총 링크의 수 : 4개 ( 4n ) <br>
                      루트노드를 제외한 다른 노드를 가리키는 링크 개수 : 1개 ( n - 1 ) <br>
                      4(2n)개 중에 1(n-1)개는 NULL링크가 아니지만 나머지 3(n + 1)개의 링크는 NULL 임을 알 수 있다. <br>
                      이들 NULL 링크 중에 중위 순회 시에 선행 노드인 중위 선행자나 중위 순회시에 후속 노드인 중위 후속자를 저장시켜 놓은 트리가 스레드 이진 트리다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#define TRUE 1
#define FLASE 0

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
  int is_thread;
} TreeNode;

TreeNode n1 = { 'A'}

TreeNode * find_successor(TreeNode * p){
  TreeNode * q = p -> right;

  if( q == NULL || P -> is_thread == TRUE )
    return q;

  while( q -> left != NULL ) q = q -> left;
  return q;
}

void thread_inorder(TreeNode *t){
  TreeNode *q;
  
  q = t;

  while ( q -> left ) q = q -> left;
  do {
    printf("%c -> " , q -> data);
    q = find_successor(q);
  } while (q);
}

int main(void){
  n1.right = &n3;
  n2.right = &n7;
  n4.right = &n6;

  thread_inorder(exp);
  printf("\n");
  return 0;
}
                        </code>
                      </pre>
                      스레드 트리는 순회를 빠르게 하는 장점이 있으나 문제는 스레드를 설정하기 위하여 삽입이나 삭제 함수가 더 많은 일을 하여야 한다. 
                      <hr>
                      <strong>이진 탐색 트리</strong><br>
                      이진 트리 기반의 탐색을 위한 자료 구조이다. 탐색은 가장 중요한 컴퓨터 응용 의 하나이다. 탐색은 우리의 일상 생활에서 많이 사용되는데 
                      전화번호부에서 전화번호를 찾거나, 사전에서 단어를 찾거나, 어떤 특정한 날에 선약이 없는가를 검사할 때 사용된다. 
                      <hr>
                      탐색 : 레코드의 집합에서 특정한 레코드를 찾아내는 작업을 의미한다. <br>
                      레코드 들은 보탇 키라고 불리는 하나의 필드에 의해 식별할 수 있다. 일반적인 경우 키는 다른 키와 중복되지 않는 고유한 값을 가지며 이러한 키를 사용하면 각각의 레코드를 구별할 수 있을 것이다. 
                      이러한 키를 주요키(primary key)라고 부른다. 
                      <hr>
                      <ul>
                        <li>모든 원소의 키는 유일한 키를 가진다.</li>
                        <li>왼쪽 서브 트리 키들은 루트 키보다 작다. </li>
                        <li>오른쪽 서브 트리의 키들은 루트의 키보다 크다.</li>
                        <li>왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다. </li>
                      </ul>
                      <strong>순환 적인 탐색 연산</strong><br>
                      이진 트리 탐색 연산을 위해서 중요한 요소를 결국 레코드를 저장할 때 이진 트리 구조로 얼마나 "효과적"으로 저장하느냐에 있다고 본다. 이는 내가 사용할 데이터 자료구조에 따라 탐색을 위해서 
                      사용하는 알고리즘이 달라 질 수 있기 때문이며, 결국에는 "데이터"를 저장하는 방식이 가장 중요한 요소가 되는 것이다. 
                      <hr>
                      <pre>
                        <code class="C" >
// 순환적인 탐색함수                           
TreeNode *search(TreeNode *node, int key){
  if ( node == NULL ) return NULL;
  if ( key == node -> key ) return node;
  else if( key &lt; node -> key )
    return search(node -> left, key);
  else 
    return search(node -> right , key);
}

// 반복적인 탐색함수 
TreeNode *search(TreeNode *node, int key ){
  while ( node != NULL ) {
      if ( key == node -> key ) return node;
      else if ( key &lt; node -> key )
        node = node -> left;
      else 
        node = node -> right;
  }
  return NULL;
}

// 이진 트리 삽입 프로그램
TreeNode *insert_node(TreeNode *node, int key){
  // 트리가 공백이면 새로운 노드를 반환한다. 
  if ( node == NULL) return new_node(key);

  // 그렇지 않으면 순환적으로 트리를 내려간다. 
  if( key &lt; node -> key )
    node -> left = insert_node(node -> left, key);
  else if( key > node -> key)
    node -> right = insert_node(node -> right, key);

  // 변경된 루트 포인터를 반환한다. 
  return node;
}

TreeNode *new_node(int item){
  TreeNode *temp = (TreeNode*)malloc(sizeof(TreeNode));
  temp -> key = item;
  temp -> left = temp -> right = NULL;
  return temp;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>이진 탐색 트리 삭제 연산</strong> <br>
                      <ul>
                        <li>삭제하려는 노드가 단말 노드 일 경우 </li>
                        <li>삭제하려는 노드가 하나의 왼쪽이나 오른쪽 서브 트리 중 하나만 가지고 있는 경우</li>
                        <li>삭제하려는 노드가 두 개의 서브 트리 모두 가지고 있는 경우 </li>
                      </ul>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h> 

typedef int element;
typedef struct TreeNode {
  element key;
  struct TreeNode *left, *right;
} TreeNode;

TreeNode *search(TreeNode *node, int key){
  if ( node == NULL ) return NULL;
  if ( key == node -> key ) return node;
  else if ( key &lt; node -> key )
    return search(node -> left, key);
  else 
    return search(node -> right, key);
}

TreeNode *new_node(int item){
  TreeNode *item = (TreeNode*)malloc(sizeof(TreeNode));

  temp -> key = item;
  temp -> left = temp -> right = NULL;
  return temp;
}

TreeNode *insert_node(TreeNode *node, int key){
  if ( node == NULL ) return new_node(key);

  if( key &lt; node -> key){
    node -> left = insert_node(node -> left, key);
  }else if(key -> node -> key){
    node -> right = insert_node(node -> right, key);
  }

  return node;
}

TreeNode *min_value_node(TreeNode *node){
  TreeNode *current = node;

  while(current -> left != NULL){
    current = current -> left;
  }

  return current;
}

TreeNode *delete_node(TreeNode *root, int key){
  if(root == NULL) return root;
  // 만약 키가 루트보다 작으면 왼쪽 서브 트리에 있는 것임 
  if(key &lt; root -> key){
      root -> left = delete_node(root -> left, key);
  }else if( key > root -> key ){
    // 만약 키가 루트보다 크면 오른쪽 서브 트리에 있는 것임 
    root -> right = delete_node(root -> right, key);
  }else{ // 키가 루트와 같으면 이 노드를 삭제하면 됨 
    // 첫 번째나 두 번째 경우 
    if ( root -> left == NULL ){
      TreeNode *temp = root -> right;
      free(root);
      return temp;
    }else if ( root -> right == NULL){
      TreeNode *temp = root -> left;
      free(root);
      return temp;
    }

    // 세 번째 경우 
    TreeNode *temp = min_value_node(root -> right);

    // 중외 순회시 후계 노드를 복사한다. 
    root -> key = temp -> key;
    // 중외 순회시 후계 노드를 삭제한다. 
    root -> right = delete_node(root -> right, temp -> key);
  }
  return root;
}

void inorder(TreeNode *root){
  if(root){
    inorder(root -> left);
    printf("[%d]", root -> key);
    inorder(root -> right);
  }
}

int main(void){
  TreeNode *root = NULL;
  TreeNode *tmp = NULL;

  root = insert_node(root, 30);
  root = insert_node(root, 20);
  root = insert_node(root, 10);
  root = insert_node(root, 40);
  root = insert_node(root, 50);
  root = insert_node(root, 60);

  printf("이진 탐색 트리 중위 순회 결과 \n");

  inorder(root);

  printf("\n\n");

  if(search(root, 30) != NULL){
    printf("이진 탐색 트리에서 30을 발견함 \n");
  }else{
    printf("이진 탐색 트리에서 30을 발견 못함 \n");
  }

  return 0;
}
                        </code>
                      </pre>
                      <strong>이진 탐색 트리 분석</strong> <br>
                      이진 탐색 트리에서의 탐색, 삽입, 삭제 연산의 시간 복잡도는 트리의 높이를 h라고 했을 때 O(h)가 된다, 따라서 n 개의 노드를 가지는 이진 탐색 트리의 경우, 
                      일반적인 이진 트리의 높이는 [log2n] 이므로 이진 탐색 트리 연산의 평균적인 경우 시간 복잡도는 O(log2h)이다. 
                      <br>
                      <strong>사례 개발 : 이진 탐색 트리를 이용한 영어 사전 프로그램</strong>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#include &lt;memory.h>

#defined MAX_WORD_SIZE  100
#defined MAX_MEANING_SIZE 200

typedef struct {
  char word[MAX_WORD_SIZE];
  char meaning[MAX_MEANING_SIZE];
} element;

typedef struct TreeNode {
  element key;
  TreeNode *left, *right;
} TreeNode;

// 만약 e1 &lt; e2 이면 -1 반환 
// 만약 e1 == e2 이면 0 반환
// 만약 e1 > e2 이면 1 반환 
int compare(element e1, element e2){
  return strcmp(e1.word, e2.word);
}

// 이진 탐색 트리 출력 함수 
void display(TreeNode *p){
  if( p != NULL){
    printf("(");
    display( p -> left );
    printf("%s:%s", p -> key.word , p -> key.meaning );
    display(p -> right);
    printf(")");
  }
}

// 이진 탐색 트리 탐색 함수  
TreeNode *search(TreeNode *root, element key) {
  TreeNode *p = root;

  while ( p != NULL ) {
    if( compare(key, p -> key ) == 0 )
      return p;
    else if (compare(key, p -> key ) &lt; 0)
      p = p -> left;
    else if (compare(key, p -> key ) > 0 )
      p = p -> right;
  }
  return p;
}

TreeNode *new_node(element item){
  TreeNode *temp = (TreeNode*)malloc(sizeof(TreeNode));
  temp -> key = item;
  temp -> left = temp -> right = NULL;
  return temp;
}

TreeNode *insert_node(TreeNode *node, element key){
  if( node == NULL ) return new_node(key);

  if ( compare(key, node -> key) &lt; 0 ){
    node -> left = insert_node(node -> left, key);
  } else {
    node -> right = insert_node(node -> right, key);
  }

  return node;
}

TreeNode *min_value_node(TreeNode *node){
  TreeNode *current = node;
  while ( current -> right != NULL )
    current = current -> left;
  return current;
}

TreeNode *delete_node(TreeNode *root, element key){
  if( root == NULL ) return root;
  // 만약 키가 루트보다 작으면 왼쪽 서브 트리에 있는 것임 
  if ( compare(key, root -> key ) &lt; 0 )
    root -> left = delete_node(root -> left, key);
  // 만약 키가 루트보다 크면 오른쪽 서브 트리에 있는 것임 
  if ( compare(key, root -> key) > 0 )
    root -> right = delete_node(root -> right, key);
  // 키가 루트와 같으면 이 노드를 삭제하면 됨 
  else {
    // 첫 번째나 두 번재 경우
    if( root -> elft == NULL) {
      TreeNode *temp = root -> right;
      free(root);
      return temp;
    }else if(root -> right == NULL){
      TreeNode *temp = root -> left;
      free(root);
      return temp;
    } 
    //새번째 경우 

    TreeNode *temp = min_value_node(root -> right);

    root -> key = temp -> key;

    root -> right = delete_node(root -> right, temp -> key);
  }
  return root
}

void help() {
  printf("\n**** i: 입력, d:삭제, s: 탐색, p: 출력, q: 종료 ****: ")
}

int main(void){
  char command;
  element e;
  TreeNode *root = NULL;
  TreeNode *tmp;

  do {
    help();
    command = getchar();
    getchar();
    switch(command){
      case 'i' :
        printf("단어 : ");
        gets(e.word);
        printf("의미 : ");
        gets(e.meaning);
        root = insert_node(root, e);
        break;
      case 'd' :
        printf("단어 : ");
        gets(e.word);
        root = delete_node(root, e);
        break; 
      case 'p' :
        display(root);
        printf("\n");
        break;
      case 's' :
        printf("단어:");
        gets(e.word);
        tmp = search(root, e);
        if ( tmp != NULL ){
          printf("의미:%s\n", e.meaning);
        }
        break;
    }
  } while ( command != 'q' );
  return 0;
}
                        </code>
                      </pre>

                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading17">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse17" aria-expanded="false" aria-controls="collapse17">
                        우선순위 큐 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse17" class="collapse" aria-labelledby="heading17" data-parent="#accordionExample">
                    <div class="card-body">
                      우선 순위 큐는 우선 순위의 개념을 큐에 도입한 자료구조 이다. 보통의 큐는 선입 선출의 원칙에 의하여 먼저 들어온 데이터가 먼저 나가게 된다. 
                      그러나 우선 순위 큐에선는 데이터들이 우선 순위를 가지고 있고 우선 순위가 높은 데이터가 먼저 나가게 된다. 
                      <hr>
                      <pre>
                        <code class="C" >  
객체 : n개의 element 형의 우선 순위를 가진 요소들의 모임 
연산 :
    create() ::= 우선 순위 큐를 생성한다. 
    init(q) ::= 우선 순위 큐 q를 초기화한다. 
    is_empty(q) ::= 우선 순위 큐 q가 비어있는지를 검사한다. 
    is_full(q) ::= 우선 순위 큐 q가 가득 찼는가를 검사한다. 
    insert(q, x) ::= 우선 순위 큐 q에 요소 x를 추가한다. 
    delete(q) ::= 우선 순위 큐로부터 가장 우선순위가 높으면 높은 요소를 삭제하고 이 요소를 반환한다. 
    find(q) ::= 우선 순위가 가장 높은 요소를 반환한다.                           
                        </code>
                      </pre>
                      <hr>
                      <strong>우선 순위 큐의 구현 방법</strong>
                      <ul>
                        <li>
                          배열 활용 <br>
                          정렬이 되었냐 안되었느냐에 따라서 시간 복잡도가 차이가 발생한다. 
                          삽입의 경우에는 제일 마지막 위치에 넣으면 되기 때문에 문제가 되지 않지만 삭제를 해야하는 경우에는 시간복잡도가 O(n)으로 증가한다. 
                          정렬이 되어 있는 배열의 경우 순차 탐색이나 이진 탐색 과 같은 방법을 이용할 수 있다. 
                        </li>
                        <li>
                          연결 리스트 활용 <br>
                          삽입시 배열과 달리 다른 노드 들로 이동할 필요가 없다. 포인터만 변경하면 된다. 따라서 삽입의 시간 복잡도는 O(1) 이다. 
                          삭제시에는 포인터를 따라서 모든 노드를 뒤져보아야 한다. 
                        </li>
                        <li>히프 활용 <br>
                          완전 이진트리의 일종으로 우선 순위 큐를 위하여 특별히 만들어진 자료구조. 히프는 일정의 느슨한 정렬 상태를 유지한다. <br>
                          히프의 효율은 O(log2n)으로서 다른 방법보다 상당히 유리하다. 여기서 다시 한번 O(n)과 O(log2n)은 큰 차이가 있다는 것을 유념하라. 
                        </li>
                      </ul>
                      <hr>
                      <strong>히프</strong> <br>
                      히프는 영어사전에 찾아보면 "더미"라고 되어 있다. 컴퓨터 분야에서 히프는 완전이진트리 기반의 "더미"와 모습이 비슷한 특정한 자료구조를 의미한다. 
                      히프는 여러 개의 값들 중에서 가장 큰 값이나 가장 작은 값을 빠르게 찾아내도록 만들어진 자료 구조이다. 히프는 간단히 말하면 부모노드의 키 값이 자식 노드의 키 값보다 항상 큰 이진 트리를 말한다. <br>
                      이진 탐색 트리에서는 중복된 값을 허용하지 않았지만 히프에서는 중복된 값을 허용함에 유의하라. 
                      <ul>
                        <li>
                          최대 히프
                          <br>
                           부모노드의 값이 자식 노드의 키값보다 크거나 같은 완전 이진 트리 
                        </li>
                        <li>최소 히프
                          <br>
                          부모 노드의 키값이 자식 노드의 키값보다 작거나 같은 완전 이진 트리 
                        </li>
                      </ul>
                      배열을 이용하여 히프를 저장하면 완전 이진 트리에서처럼 자식 노드와 부모 노드를 쉽게 알 수 있다. 
                      어떤 노드의 왼쪽이나 오른쪽 자식의 인덱스를 알고 싶으면 다음과 같은 식을 이용하면 된다. 
                      <ul>
                        <li>왼쪽 자식의 인덱스 = (부모의 인덱스) * 2</li>
                        <li>오른쪽 자식의 인덱스 = (부모의 인덱스) * 2 + 1</li>
                      </ul>
                      부모의 인덱스를 알고 싶은 경우 
                      <ul>
                        <li>부모의 인덱스 = (자식의 인덱스) / 2</li>
                      </ul>
                      히프트리에서의 삽입 알고리즘 ( 의사 코드 버전 ) <br>
                      <pre>
                        <code class="C" >
insert_max_heap(A, key); 

1. heap_size &lt;- heap_size + 1;
2. 1 &lt;- heap_size;
3. A[i] &lt;- key;
4. while i /= 1 and A[i] > A[PARENT(i)] do 
5.      A[i] &lt;-> A[PARENT];
6.      i &lt;- PARENT(i);
                        </code>
                      </pre>
                      히프트리에서 삭제 알고리즘 ( 의사코드 버전 ) <br>
                      <pre>
                        <code class="C" >
delete_max_heap(A);

1. item &lt;- A[1]
2. A[1] = A[headp_size];
3. heap_size &lt;- heap_size - 1;
4. i &lt;- 2;
5. while i &lt;=  heap_size do 
6.    if i &lt; heap_size and A[i+1] > A[i];
7.      then largest &lt;- i + 1;
8.      else largest &lt;- i;
9.    if A[PARENT(largest)] > A[largest]
10.     then break;
11.   A[PARENT(largest)] &lt;-> A[largest];
12.   i &lt;- CHILD(largest);
13. 
14. return item; 
                        </code>
                      </pre>
                      <hr>
                      <strong>히프 트리</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_ELEMENT 200

typedef struct {
  int key;
} element;

typedef struct {
  element heap[MAX_ELEMENT];
  int heap_size;
} HeapType;

// 생성함수 
HeapType* create(){
  return (HeapType*)malloc(sizeof(HeapType));
}

// 초기화 함수 
void init(HeapType* h){
  h -> heap_size = 0;
}

// 현재 요소의 개수가 heap_size인 히프 h에 item을 삽입한다. 
// 삽입 함수 
void insert_max_heap(HeapType* h, element item){
  int i;
  i = ++ ( h -> heap_size );

  // 트리를 거슬러 올라가면서 부모 노드와 비교하는 과정 
  while( ( i != 1 ) && ( item.key > h -> heap[i / 2].key )) {
    h -> heap[i] = h -> heap[i / 2];
    i /= 2;
  }
  h -> heap[i] = item;
}

// 삭제 함수 
element delete_max_heap(HeapType* h){
  int parent, child;
  element item, temp;
  
  item = h -> heap[i];
  temp = h -> heap[(h -> heap_size)--];
  parent = 1;
  child = 2;

  while(chile &lt;= h -> heap_size ){
    // 현재 노드의 자식노드 중 더 큰 자식노드를 찾는다. 
    if((child &lt; h -> heap_size) && ( h-> heap[child].key ) &lt; h -> heap[child + 1].key)
      child ++;
    if ( temp.key >= h -> heap[child].key ) break;

    h -> heap[parent] = h -> heap[child];
    parent = child;
    child *= 2;
  }
  h -> heap[parent] = temp;
  return item;
}

int main(void){
  element e1 = { 10 }, e2 = { 5 }, e3 = { 30 };
  element e4, e5, e6;
  HeapType* heap;

  heap = create();

  init(heap);

  insert_max_heap(heap, e1);
  insert_max_heap(heap, e2);
  insert_max_heap(heap, e3);

  e4 = delete_max_heap(heap);
  printf("&lt; %d > ", e4.key );
  e5 = delete_max_heap(heap);
  printf("&lt; %d > ", e5.key );
  e6 = delete_max_heap(heap);
  printf("&lt; %d > \n", e6.key);
  
  free(heap);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>히프 정렬</strong>
                      <hr>
                      최대 히프를 이용하면 정렬을 할 수 있다. 한 번에 하나씩 요소를 꺼내서 배열의 뒤쪽부터 저장하면 된다. 배열 요소들은 값이 증가되는 순서로 정렬되게 된다. 
                      이렇게 히프를 사용하는 정렬 알고리즘을 히트 정렬이라고 한다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h> 

void heap_sort(element a[], int n){
  int i;
  HeapType* h;

  h = create();
  init(h);
  for ( i = 0; i &lt; n ; i ++){
    insert_max_heap(h, a[i]);
  }
  for ( i = ( n - 1 ); i >= 0; i -- ){
    a[i] = delete_max_heap(h);
  }
  free(h);
}

#define SIZE 8
int main(void){
  element list[SIZE] = { 23, 56, 11, 9, 56, 99, 27, 34 };
  heap_sort(list, SIZE);
  for(int i = 0; i &lt; SIZE; i ++){
    printf("%d ", list[i].key);
  }
  printf("\n");
  return 0;
}

                        </code>
                      </pre>
                      <hr>
                      <strong>머신 스케쥴링</strong>
                      <hr>
                      어떤 공장에 동일한 기계가 m개 있다고 하자. 우리는 처리해야 하는 작업을 n개 가지고 있다. 각 작업이 필요로하는 기계의 사용시간은 다르다고 하자. 우리의 목표는 모든 기계를 풀가동하여 가장 최소의 시간안에 작업들을 끝내는 것이다. 이것을
                      머신 스케쥴링이라고 한다. <br>
                      이 문제는 알고리즘 분야에서 상당히 유서 깊은 문제로 많은 응용 분야를 가지고 있다. 예를 들어서 서버가 여러 개 있어서 서버에 작업을 분재할 때도 사용할 수 있다. 최적의 해를 찾는 것은 상당히 어렵다. 
                      하지만 근사의 해를 찾는 방법이 있다. 그 중 한 가지가 LPT(longest processing time first) 방법이다. <br>
                      히프 정렬을 사용한다고 할 때 여기서는 최대 히프가 아닌 최소 히프를 사용한다. 최소 히프는 모든 기계의 종료시간을 저장하고 있다. 
                      처음에는 어떤 기계도 사용되지 않으므로 모든 기계의 종료시간은 0이다. 히프에서 최소의 종료 시간을 가지는 기계를 삭제하여서 작업을 할당한다. 
                      선택된 기계의 종료 시간을 업데이트하고 다시 히프에 저장한다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#defined MAX_ELEMENT 200

typede struct {
  int id;
  int avail;
} element;

typedef struct {
  element heap[MAX_ELEMENT];
  int heap_size;
} HeapType;

// 생성함수 
HeapType* creat() {
  return (HeapType*)malloc(sizeof(HeapType));
}

// 초기화 함수 
voi init(Heaptype* h){
  h -> heap_size = 0;
}

// 현재 요소의 개수가 heap_size 인 히프 h에 item을 삽입한다. 
// 삽입 함수 
void insert_min_heap(HeapType* h, element item){
  int i;
  i = ++( h -> heap_size );

  // 트리를 거슬러 올라가면서 부모 노드와 비교하는 과정 
  while( ( i != 1) && ( item.avail &lt; h -> heap[ i/ 2].avail)){
    h -> heap[i] = h -> heap[i / 2];
    i /= 2;
  }
  h -> heap[i] = item;
}

// 삭제 함수
element delete_min_heap(HeapType* h){
  int parent, child;
  element item, temp;

  item = h -> heap[i];
  temp = h -> heap[(h->heap_size)--];
  parent = 1;
  child = 2;
  while ( child &lt;= h -> heap_size) {
    // 현재 노드의 자식 노드 중 더 작은 자식 노드를 찾는다. 
    if ( ( child &lt; h -> heap_size ) && ( h -> heap[child].avail ) > h -> heap[child + 1].avail)
      child ++;
    if ( temp.avail &lt; h -> heap[child].avail ) break;
    // 한 단계로 이동 
    h -> heap[parent] = h -> heap[child];
    parent = child;
    child *= 2;
  }
  h -> heap[parent] = temp;
  return item;
}


#define JOBS 7
#define MACHINES 3

int main(void){
  int jobs[JOBS] = { 8, 7, 6, 5, 3, 2, 1 };
  element m = { 0, 0 };
  HeapType* h;
  h = creat();
  init(h);

  // 여기서 avail의 값은 기계가 사용 가능하게 되는 시간이다. 
  for ( int i = 0 ; i &lt; MACHINES ; i ++) {
    m.id = i + 1;
    m.avail = 0;
    insert_min_heap(h, m);
  }

  // 최소 히프에게 기계를 꺼내서 작업을 할당하고 사용 가능 시간을 증가 시킨 후에 
  // 다시 최소 히프에 추가한다. 
  for ( int i = 0 ; i &lt; JOBS ; i ++ ) {
    m = delete_min_heap(h);
    printf("JOB %d을 시간 = %d 로부터 시간=%d 가지 기계 %d 번에 할당한다. ",
      i, m.avail, m.avail + jobs[i] - 1 , m.id );
    m.avail += jobs[i];
    insert_min_heap(h, m);
  }
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>허프만 코드</strong> <br>
                      이진 트리는 각 글자의 빈도가 알려져 있는 메세지 내용을 압축하는데 사용될 수 있다. 이런 특별한 종류의 이진트리를 허프만 코딩 트리라고 부른다. 
                      <hr>
                      테이블의 숫자는 빈도수라 불리운다. 각 숫자들은 영문 텍스트에서 해당 글자가 나타내는 회수이다. 이 빈도수를 이용하여 데이터를 압축할 때 각 글자들을 나타내는 최소길이의 엔코딩 비트열을 만들 수 있다. 
                      데이터를 압축할 때는 우리가 흔히 사용하는 아스키 코드를 사용하지 않는다. 보톤 전체 데이터의 양을 줄이기 위하여 고정된 길이를 사용하지 않고 가변 길이의 코드를 사용한다. 
                      각 글자의 빈도 수에 따라서 가장 많이 등장하는 글자에는 짧은 비트열을 사용하고 잘 나오지 않는 글자에는 긴 비트열을 사용하여 전체의 크기를 줄이자는 것이다. 
                      즉 많이 등장하는 e를 나타내기 위하여 2비트를 사용하고 잘 나오니 않는 z를 나타내기 위하여 15비트를 사용하나는 것이다. 
                      <hr>
                      글자를 해독하는 문제를 생각하여 보자. 만약 한 글자당 3비트가 할당된다면 메세지를 해독하는 것은 아주 쉽다. 메시지를 3비트씩 끊어서 읽으면 된다. 만약 가변 길이 코드가 사용되었을 경우에는 어떻게 될 것인가? 
                      teen의 경우, 가변코드를 사용하여 코딩하면 01000010이 된다. 이 메시지를 어디서 끊어서 읽어서 해독해야 되는가? 첫 번째 글자의 경우, 하나의 글자가 3비트까지 가능하므로 00, 01, 010중의 하나이다. 그러나 코드 테이블을 보면
                      0 이나 010인 코드는 없기 때문에 첫 번째 글자는 첫번째 글자는 01이 분명하고 01은 t이다. 또 다음 코드는 0, 00, 000 중의 하나이다. 그러나 같은 이유로 다음 코드는 00이 된다. 
                      <hr>
                      이러한 해독과정을 가능하게 하는 원인은 코드를 관찰하여 보면 모든 코드가 다른 코드의 첫 부분이 아니라는 것이다. 따라서 코딩된 비트열을 왼쪽에서 오른쪽을 조사하여 보면 정확히 하나의 코드만 일치하는 것을 알 수 있다. 
                      이러한 특수한 코드를 만들기 위하여 이진 트리를 사용할 수 있다. 이런 종류의 코드를 호프만 코드라고한다. 
                      <hr>
                      이 허프만 트리에서 왼쪽 간선은 비트 1을 나태니고 오른쪽 간선은 비트 0을 나타낸다. <br>
                      <hr>
                      각 글자에 대한 호프만 코드는 단순히 루트 노드에서 단말 노드까지의 경로에 있는 간선의 라벨값을 읽으면 된다. 즉 빈도수 6에 해당하는 글자인 i의 코드는 100이 된다. 
                      같은 식으로 하여 다른 글자에 대한 허프만 코드 값을 얻을 수 있다. 허프만 코드 알고리즘에서 가장 작은 2개의 빈도수를 얻는 과정이 있다. 이것은 히프트리를 이용하면 가장 효율적으로 구성될 수 있다. 
                      여기서는 최소 히프를 이용하여야 한다. 따라서 히프 트리 코드를 약간 변경하였다. 다음의 프로그램은 먼저 각 빈도수를 단일 노드로 만든 다음에 가장 작은 빈도수를 갖는 노드 2개를 합쳐서 하나의 트리로 
                      만드는 과정을 되풀이 한다. 

                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_ELEMENT 200

typedef struct TreeNode {
  int weight;
  char ch;
  struct TreeNode *left;
  struct TreeNode *right;
} TreeNode;

typedef struct {
  TreeNode* ptree;
  char ch;
  int key;
} element;

typedef struct {
  element heap[MAX_ELEMENT];
  int heap_size;
} HeapType;

// 생성함수 
HeapType* create() {
  return (HeapType*)malloc(sizeof(HeapType));
}

// 초기화 함수 
void init(HeapType* h){
  h -> heap_size = 0;
}

// 현재 요소의 개수가 heap_size 인 히프 h 에 item을 삽입한다. 
// 삽입 함수 
void insert_min_heap(HeapType* h, element item){
  int i;
  i = ++ ( h -> heap_size );

  // 트리를 거슬러 올라가면서 부모 노드와 비교하는 과정 
  while( ( i != 1) && ( item.key &lt; h -> heap[ i / 2].key )) {
    h -> heap[i] = h -> heap[i / 2];
    i /= 2;
  }
  h -> heap[i] = item;
}

// 삭제 함수 
element delete_min_heap(HeapType* h){
  int parent, child;
  element item, temp;

  item = h -> heap[1];
  item = h -> heap[(h -> heap_size)--];
  parent = 1;
  child = 2;
  while ( child &lt;= h -> heap_size ) {
    // 현재 노드의 자식 노드 중 더 작은 자식 노드를 찾는다. 
    if ( ( child &lt; h -> heap_szie ) && ( h -> heap[child].key > h -> heap[child + 1].key ) )
      child ++;
    if( temp.key &lt; h -> heap[child].key ) break;
      h -> heap[parent] = h -> heap[child];
      parent = child;
      child *= 2;
  }
  h -> heap[parent] = temp;
  return item;
}


// 이진 트리 생성 함수 
TreeNode* make_tree(TreeNode* left, TreeNode* right){
  TreeNode *node = (TreeNode*)malloc(sizeof(TreeNode));
  node -> left = left;
  node -> right = right;
  return node;
}

// 이진 트리 제거 함수 
void destroy_tree(TreeNode* root){
  if ( root == NULL ) return;
  destroy_tree(root -> left);
  destroy_tree(root -> right);
  free(root);
}

int is_leaf(TreeNode* root){
  return !(root -> left) && !(root -> right);
}

void print_array(int codes[], int n){
  for ( int i = 0; i &lt; n ; i ++){
    printf("%d", codes[i]);
  }
  printf("\n");
}

void print_codes(TreeNode* root, int codes[], int top){
  // 1 을 저장하고 순환 호출한다. 
  if ( root -> left ) {
    codes[top] = 1;
    print_codes(root -> left, codes, top + 1);
  }

  // 0을 저장하고 순환호출한다. 
  if( root -> right) {
    codes[top] = 0;
    print_codes(root -> right, codes, top + 1);
  }

  // 단말노드이면 코드를 출력한다. 
  if(is_leaf(root)){
    printf("%c : ", root -> ch);
    print_array(codes, top);
  }
}

// 허프만 코드 생성 함수 
void huffman_tree(int freq[], char ch_list[], int n ){
  int i;
  TreeNode *node , *x;
  HeapType* heap;
  element e1, e2, e3;
  int codes[100];
  int top = 0;

  heap = create();
  init(heap);
  for( i = 0; i &lt; n ; i ++){
    node = make_tree(NULL, NULL);
    e.ch = node -> ch = ch_list[i];
    e.key = node -> weight = freq[i];
    e.ptree = node;
    insert_min_heap(heap, e);
  }
  for ( i = 1; i &lt; n ; i ++){
    // 최소값을 가지는 두개의 노드를 삭제 
    e1 = delete_min_heap(heap);
    e2 = delete_min_heap(heap);
    // 두개의 노드를 합친다. 
    x = make_tree(e1.ptree, e2.ptree);
    e.key = x => weight = e1.key + e2.key;
    e.ptree = x;
    printf("%d + %d -> %d \n", e1.key, e2.key, e.key );
    insert_min_heap(heap, e);
  }
  e = delete_min_heap(heap);
  print_codes(e.ptree, codes, top);
  destroy_tree(e.ptree);
  free(heap);
}

int main(void){
  char ch_list[] = { 's', 'i' , 'n', 't', 'e' };
  int freq[] = { 4, 6, 8, 12, 15 };
  huffman_tree(freq, ch_list, 5);
  return 0;
}
                        </code>
                      </pre>
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading18">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse18" aria-expanded="false" aria-controls="collapse18">
                        그래프 I
                      </button>
                    </h2>
                  </div>
                  <div id="collapse18" class="collapse" aria-labelledby="heading18" data-parent="#accordionExample">
                    <div class="card-body">
                      그래프는 객체 사이의 연결관계를 표현할 수 있는 자료 구조다. 그래프의 대표적인 예는 지도이다. 지하철 노선도는 여러 개의 역들이 어떻게 연결되었는지를 보여준다. 지도를 그래프로 표현하면 
                      지하철의 특정한 역에서 다른 역으로 가는 최단 경로를 쉽게 프로그래밍 해서 찾을 수 있다. 또한 전기 소자를 그래프로 표현하기 뒤면 전기 회로의 소자들이 어떻게 연결되어 있는지를 표현해야 
                      회로가 제대로 동작하는지 분석할 수 있으며, 운영 체제에서는 프로세스와 자원들이 어떻게 연관되는지를 그래프로 분석하여 시스템의 효율이나 교착 상태 유무 등을 알아낼 수 있다. 
                      <hr>
                      이러한 많은 문제들은 공통적으로 도시, 소자, 자원, 프로젝트 등의 객체들이 서로 연결되어 있는 구조로 표현가능하다. 그래프는 이러한 많은 문제들을 표현할 수 있는 훌륭한 논리적 도구이다. 우리가 여태 까지 배워온 선형 리스트나 트리의 구조로는 위와 같은 
                      복잡한 문제들을 표현할 수 없다. 그래프 구조는 인접 행렬이나 인접 리스트로 메모리에 표현되고 처리될 수 있으므로 광벙위한 분야의 다양한 문제들을 그래프로 표현하여 해결할 수 있다. 
                      <hr>
                      <img src="./eulerianTour.png" class="img-thumbnail" alt="" srcset=""><br>
                      수학자 오일러는 Konigsberg의 다리 문제를 해결하기 위하여 그래프를 처음으로 사용하였다. Konigs시의 한 가운데는 Pregen 강이 흐르고 있고 여기에는 7개의 다리가 있다. 'Konigsbergs의 다리' 문제란 "임의의 지역에서 출발하여 모든 다리를 단 한번만
                      건너서 처음 출발했던 지역으로 돌아올 수 있는가"이다. 많은 사람들이 이 문제의 답을 찾기 위해 노력을 했다. 여러분도 한번 시도해보면 알 수 있지만 그런 방법은 없다는 것이 정답니다. 오일러는 어떤 한 지역에서 시작하여 모든 다리를 한 번씩만 지나서 
                      처음 출발점으로 되돌아오려면 각 지역에 연결된 다리의 개수가 모두 짝수이어야 함을 증명하였다. 
                      <br>
                      특정 지역은 정점(node)로, 다리는 간선(edge)로 표현하여 그래프 문제로 변경하였다. 오일러는 이러한 그래프에 존재하는 모든 간선을 한번만 통과하면서 처음 정점으로돌아오는 경로를 오일러 경로라고 정의하고, 그래프의 모든 정점에 연결된 간선의 개수가 
                      짝수일 때만 오일러 경로가 존재한다는 오일러의 정의를 증명하였다.
                      <hr>
                      <strong>그래프로 표현할 수 있는 것들</strong>
                      <ul>
                        <li>도로 - 도로의 교차점과 일방통행길 등을 그래프로 효과적으로 표현할 수 있다. </li>
                        <li>미로 - 미로도 그래프를 이용하여 효과적으로 표현이 가능하다. </li>
                        <li>대학교에서 전공 과목을 수강하기 위해서는 미리 들어야 하는 선수과목들이 있다. 그래프는 이러한 선수과목 관계를 효과적으로 표현할 수 있다. 
                        </li>
                      </ul>
                      <hr>
                      <strong>그래프의 정의와 용어</strong><br>
                      그래프는 정점과 간선들의 유한 집합이라고 할 수 있다. 
                      수학적으로는 G = ( V, E)와 같이 표시한다. 여기서, V(G)는 그래프 G의 정점들의 집합을, E(G)는 그래프 G의 간선들의 집합을 의미한다. 정점은 여러 가지 특성을 가질 수 있는 객체를 의미하고, 간선은 이러한 정점들 간의 관계를 의미한다. 
                      정점은 노드라고도 부리며, 간선은 링크라고도 불린다. 이 책에서는 '정점'과 '간선'이라는 용어로 통일해서 사용하고자 한다. <br>
                      <hr>
                      <div class="card">
                        <div class="row">
                          <div class="col-md-6">
                            <img src="./vertextandedge.png" class="img-thumbnail" >
                          </div>
                          <div class="col-md-6">
                            <div class="card-body">
                              <h5 class="card-title">
                                그래프 ( 정점, 간선 )
                              </h5>
                              <p class="card-text">
                                V(G1) = { 0, 1, 2, 3 } <br>
                                E(G1) = { (0, 1), (0, 2), (0, 3), (1, 2) }
                              </p>
                              <p class="card-text"><small class="text-muted"></small></p>
                            </div>
                          </div>
                        </div>
                      </div>
                      <div class="card">
                        <div class="row">
                          <div class="col-md-3">
                            <h5 class="card-title">
                              무 방향 그래프
                            </h5>
                            <img src="./vertextandedge.png" class="img-thumbnail" >
                          </div>
                          <div class="col-md-3">
                            <h5 class="card-title">
                              방향 그래프 
                            </h5>
                            <img src="./vertextandedge2.png" class="img-thumbnail" >
                          </div>
                          <div class="col-md-6">
                            <div class="card-body">
                              <h5 class="card-title">
                                무 방향 그래프와 방향 그래프 
                              </h5>
                              <hr>
                              <p class="card-text">
                                <strong>무방향 그래프</strong><br>
                                무방향 그래프의 간선은 간선을 통해서 양방향으로 갈 수 있음을 나타내며 점정 A와 정점 B 를 연결하는 간선은 ( A, B) 와 같이 정점의 쌍으로 표현한다. <br>
                                V(G1) = { 0, 1, 2, 3 } <br>
                                E(G1) = { (0, 1), (0, 2), (0, 3), (1, 2) }
                                <hr>
                                <strong>방향 그래프</strong><br>
                                방향 그래프는 간선에 양방향이 존재하는 그래프로서 도로의 일방통행길처럼 간선을 통하여 한쪽 방향으로만 갈 수 있음을 나타낸다. 정점 A에서 정점 B로만 갈 수 있는 간선은 
                                &lt;A, B> 로 표시한다. 방향 그래프에서 &lt; A, B>와 &lt; B, A>는 서로 다른 간선이다. <br>
                                V(G1) = { 0, 1, 2, 3 } <br>
                                E(G1) = { &lt;0, 1>, &lt;0, 2>, &lt;0, 3>, &lt;1, 2> }
                              </p>
                              <p class="card-text"><small class="text-muted"></small></p>
                            </div>
                          </div>
                        </div>
                      </div>
                      <div class="card">
                        <div class="row">
                          <div class="col-md-6">
                            <img src="./vertextandedge3.png" class="img-thumbnail" >
                          </div>
                          <div class="col-md-6">
                            <div class="card-body">
                              <h5 class="card-title">
                                네트워크 
                              </h5>
                              <p class="card-text">
                                간선에 가중치를 할당하게 되면, 간선의 역할이 두 정점 간에 연결 유무 뿐만 아니라 연결 강도까지 나타낼 수 있으므로 
                                보다 복잡한 관계를 표현할 수 있게 된다. 이렇게 간선에 비용이나 가중치가 할당된 그래프를 가중치 그래프 또는 네트워크라고 하며 좌측의 
                                이미지와 같이 나타낸다. 
                              </p>
                              <p class="card-text"><small class="text-muted"></small></p>
                            </div>
                          </div>
                        </div>
                      </div>
                      <div class="card">
                        <div class="row">
                          <div class="col-md-6">
                            <img src="./vertextandedge4.png" class="img-thumbnail" >
                          </div>
                          <div class="col-md-6">
                            <div class="card-body">
                              <h5 class="card-title">
                                부분 그래프 
                              </h5>
                              <p class="card-text">
                                어떤 그래프의 정점의 일부와 간선의 일부로 이루어진 그래프를 부분 그래프라 한다. 그래프 G의 부분 그래프 S는 아래와 같은 그래프이다. 
                              </p>
                              <p class="card-text"><small class="text-muted"></small></p>
                            </div>
                          </div>
                        </div>
                      </div>
                      <div class="card">
                        <div class="row">
                          <div class="col-md-12">
                            <div class="card-body">
                              <h5 class="card-title">
                                연결 그래프 
                              </h5>
                              <p class="card-text">
                                그래프에서 인접 정점란 간선에 의해 직접 연결된 정점을 뜻한다. 그래스에서 정점 0의 인접 정점은 정점 1, 정점 2, 정점 3이다. 무방향 
                                그래프에서 정점의 차수는 그 정점에 인접한 정점의 수를 말한다. 
                              </p>
                              <p class="card-text"><small class="text-muted"></small></p>
                            </div>
                          </div>
                        </div>
                      </div>
                      <div class="card">
                        <div class="row">
                          <div class="col-md-12">
                            <div class="card-body">
                              <h5 class="card-title">
                                경로 
                              </h5>
                              <p class="card-text">
                                무방향 그래프에서 정점 s로부터 정점 e까지의 경로는 정점의 나열 s, v1, v2, ... vk, e 로서 , 나열된 정점들 간에는 반드시 간선 
                                (s, v1), ( v1, v2), ... , ( vk, e)가 존재해야 한다. 만약 방향 그래프라면 &lt; s, v1> , &lt; v1, v2 >, ... , &lt; vk, e > 가 있어야 한다. 
                                아래의 그래프에서 0, 1, 2, 3은 경로지만 0, 1, 3, 2는 경로가 아니다. 왜냐하면 간선 ( 1 , 3 ) 이 존재하지 않기 때문이다.    
                                <hr>
                                <strong>싸이클</strong><br>
                                경로 중에서 반복되는 간선이 없을 경우에 이러한 경로는 단순 경로라 한다. 만약에 단순 경로의 시작 정점과 종료 정점이 동일하다면 이라한 경로를 싸이클이라 한다. 
                              </p>
                              <p class="card-text"><small class="text-muted"></small></p>
                            </div>
                          </div>
                        </div>
                      </div>
                      <div class="card">
                        <div class="row">
                          <div class="col-md-12">
                            <div class="card-body">
                              <h5 class="card-title">
                                연결 그래프
                              </h5>
                              <p class="card-text">
                                무방향 그래프 G에 있는 모든 정점 쌍에 대하여 항상 경로가 존재한다면 G는 연결되었다고 하며, 이러한 무방향 그래프 G 를 연결 그래프라 부른다. 
                                그렇지 않은 그래프는 비 연결 그래프라고 한다. 트리는 그래프의 특수한 형태로서 사이클을 가지지 않는 연결 그래프이다. 
                              </p>
                              <p class="card-text"><small class="text-muted"></small></p>
                            </div>
                          </div>
                        </div>
                      </div>
                      <div class="card">
                        <div class="row">
                          <div class="col-md-12">
                            <div class="card-body">
                              <h5 class="card-title">
                                완전 그래프 
                              </h5>
                              <p class="card-text">
                                그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프를 완전 그래프라고 한다. 무방향 완전 그래프의 정점수를 n 이라고 하면, 
                                하나의 정점은 n - 1  개의 다른 정점으로 연결되므로 간선의 수는 n * ( n - 1 ) / 2 가 된다. 만약 완전 그래프에서 n = 4라면 간선의 수는
                                ( 4 * 3 ) / 2 = 6 이다. 
                              </p>
                              <p class="card-text"><small class="text-muted"></small></p>
                            </div>
                          </div>
                        </div>
                      </div>
                      
                      <hr>
                      <strong>그래프 추상 데이터 타입</strong>
                      <pre>
                        <code class="C" >
객체 : 정점의 집합과 간선의 집합
연산 :
  create_graph() ::= 그래프를 생성한다. 
  init(g) ::= 그래프 g를 초기화한다. 
  insert_vertex(g,v) ::= 그래프 g에 정점 v를 삽입한다. 
  insert_edge(g,u,v) ::= 그래프 g에 간선 ( u , v )를 삽입한다. 
  delete_vertex(g,v) ::= 그래프 g의 정점 v를 삭제한다. 
  delete_edge(g,u,v) ::= 그래프 g의 간선 ( u , v )를 삭제한다. 
  is_empty(g) ::= 그래프 g가 공백 상태인지 확인한다. 
  adjacent(v) ::= 정점 v에 인접한 정점들의 리스트를 반환한다. 
  destroy_graph(g) ::= 그래프 g를 제거한다. 
                        </code>
                      </pre>
                      <hr>
                      <strong>그래프의 표현 방법</strong>
                      <hr>
                      <ul>
                        <li>인접 행렬 : 2차원 배열을 사용하여 그래프를 표현한다. </li>
                        <li>인접 리스트 : 연결 리스트를 사용하는 그래프를 표현한다. </li>
                      </ul>
                      <hr>
                      <strong>인접행렬</strong><br>
                      그래프의 정점 수가 n 이라면 n * n 의 2차원 배열인 인접 행렬 M 의 각 원소를 다음 규칙에 의해 할당함으로써 그래프를 메모리에 표현할 수 있다. 
                      <pre>
                        <code class="C" >
if(간선 ( i , j)가 그래프에 존재 ) M[i][j] = 1;
otherwise                     M[i][j] = 0;
                        </code>
                      </pre>
                      우리가 다루고 있는 그래프에서는 자체 간선을 허용하지 않으므로 인접 행렬의 대각선 성분은 모두 0으로 표시된다. 무방향 그래프의 인접 행렬은 대칭 행렬이 된다. 
                      이는 무방향 그래프의 간선(i,j)는 정점 i에서 정점 j로의 연결 뿐만 아니라 정점 j에서 정점 i로의 연결을 동시에 의미하기 때문이다. 
                      <strong>따라서 무방향 그래프의 경우, 배열의 상위 삼각이나 하위 삼각만 저장하면 메모리를 절약할 수 있다. </strong>
                      무 방향 그래프의 경우 인접 행렬에서 행렬의 값이 대칭으로 표시되지만, 방향 그래프는 대칭으고 값을 표시할 수 없다. 따라서 무방향 그래프에서 배열의 상위 삼각또는 
                      하위삼각의 값만 저장하면 되기 때문에 메모리 효율이 더 좋게 처리할 수 있다.  
                      <hr>
                      <img src="../cc/GraphSample.PNG" class="img-thumbnail" alt="" srcset="">
                      <hr>
                      n 개의 정점을 가지는 그래프를 인접 행렬로 표현하기 위해서는 간선의 수와 무관하게 항상 n^2 개의 메모리 공간이 필요하다. 
                      이에 따라 인접 행렬은 G1과 같이 그래프에 간선이 많이 존재하는 밀집 그래프를 표형하는 경우에는 적합하나, 
                      G2와 같이 그래프 내에 적은 숫자의 간선만을 가지는 희소 그래프의 경우에는 메모리의 낭비가 크므로 적합하지 않다. <br>
                      인접 행렬을 이용하면 두 정점을 연결하는 간선의 존재 여부를 O(1) 시간 안에 즉시 알 수 있는 장점이 있다. 즉 정점 u 와 정점 v를 연결하는 정점이 있는지를 알려면 M[u][v] 의 값을 조사하면 바로 알 수 있다. 
                      또한 정점의 차수는 인접 행렬의 행이나 열을 조사하면 알수 있으므로 O(n) 연산에 의해 알 수 있다. 
                      <hr>
                      <strong>인접 행렬을 이용한 추상 데이터 타입의 구현</strong>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_VERTICES 50 
typedef struct GraphType {
  int n ;
  int adj_mat[MAX_VERTICES][MAX_VERTICES];
} GraphType;


// 그래프 초기화 
void init(GraphType* g) {
  int r, c;
  g -> n = 0;
  for ( r = 0; r &lt; MAX_VERTICES ;  r ++ ){
    for ( c = 0; c &lt; MAX_VERTICES ; c ++ ) {
      g -> adj_mat[r][c] = 0;
    }
  }
}

// 정점 삽입 연산
void init(GraphType* g) {
  if (((g -> n) + 1) > MAX_VERTICES ){
    fprintf(stderr, "그래프 : 정점의 개수 초과 ");
    return;
  }
  g -> n++;
}

// 간선 삽입 연산 
void insert_edge(GraphType* g, int start, int end) {
  if ( start &lt;= g -> n || end >= g -> n){
    fprintf(stderr, "그래프 : 정점 번호 오류");
    return;
  }
  g -> adj_mat[start][end] = 1;
  g -> adj_mat[end][start] = 1;
}

// 인접 행렬 출력 함수 
void print_adj_mat(GraphType* g){
  for( int i = 0; i &lt; g -> n ; i ++ ){
    for( int j = 0; j &lt; g -> n ; j ++ ){
      printf("%2d", g -> adj_mat[i][j]);
    } 
    printf("\n");
  }
}

void main(){
  GraphType *g;
  g = (GraphType *)malloc(sizeof(GraphType));
  init(g);
  for( int 1 = 0; i &lt; 4; i ++){
    insert_vertex(g, i);
  }
  insert_edge( g, 0, 1);
  insert_edge( g, 0, 2);
  insert_edge( g, 0, 3);
  insert_edge( g, 1, 2);
  insert_edge( g, 2, 3);
  
  print_adj_mat(g);

  free(g);
}
                        </code>
                      </pre>
                      <hr>
                      <strong>인접 리스트</strong>
                      <hr>
                      인접 리스트는 그래프를 표현함에 있어 각각의 정점에 인접한 정점들을 연결 리스트로 표시한 것이다. 각 연결 리스트의 노드들은 인접 정점을 저장하게 된다. 각 연결 리스트들은 헤러 노드를 가지고 있고 이 헤더 
                      노드들은 인접 정점을 저장하게 된다. 
                      <hr>
                      <img src="./Graph01.PNG" class="img-thumbnail" alt="" srcset="">
                      <hr>
                      정점의 수가 n 개이고 간선의 수가 e개인 무방향 그래프를 표시하기 위해서는 n 개의 연결 리스트가 필요하고, n개의 헤더 노드와 2e 개의 노드가 필요하다. 따라서 인접 행렬 표현은 간선의 개수가 적은 희소 그래프의 표현에 
                      적합하다. 그래프에 간선의 존재여부나 정점 i의 차수를 알기 위해서는 인접 리스트 에서의 정점 i의 연결 리스트를 탐색해야 하므로 연결 리스트에 있는 노드의 수 만큼, 즉 정점 차수 만큼의 시간이 필요하다. 
                      즉 n 개의 정점과 e개의 간선을 가진 그래프에서 전체 간선의 수를 알아내려면 헤더 노드를 포함하여 모든 인접 리스트를 조사해야하므로 O(n + e)의 연산이 요구된다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_VERTICES 50

typedef struct GraphNode {
  int vertex;
  struct GraphNode* link;
} GraphNode;

typedef struct GraphType {
  int n; // 정점의 개수 
  GraphNode* adj_list[MAX_VERTICES];
} GraphType;

// 그래프 초기화 
void init(GraphType* g){
  int v;
  g -> n = 0;
  for ( v = 0; v &lt; MAX_VERTICES; v ++){
    g -> adj_list[v] = NULL;
  }
}

// 정점 삽입 연산 
void insert_vertex(GraphType* g, int v){
  if ((g -> n) + 1) > MAX_VERTICES ) {
    fprintf(stderr, "그래프 : 정점의 개수 초과");
    return;
  }
  g -> n ++;
}

// 간선 삽입 연산, v를 u의 인접 리스트에 삽입한다. 
// 정점  u에 간선 ( u , v )를 삽입하는 연산은 정점 u의 인접 리스트에 간선을 나타내는 노드를 하나 생성하여 삽입하면 된다. 위치는 상관 없으므로, 삽입을 쉽게 하기 위하여 연결 리스트의 맨 처음에 삽입한다. 
void insert_edge(GraphType* g, int u, int v){
  GraphNode* node;
  if ( u >= g -> n || v >= g -> n ) {
    fprintf(stderr, "그래프: 정점 번호 오류 ");
    return;
  }
  node = (GraphNode*)malloc(sizeof(GraphNode));
  node -> vertex = v;
  node -> link = g -> adj_list[u];
  g -> adj_list[u] = node;
}

void print_adj_list(GraphType* g){
  for( int i = 0 ; i &lt; g -> n ; i++){
    GraphNode* p = g -> adj_list[i];
    printf("정점 %d의 인접 리스트 ", i);
    while( p != NULL ){
      printf("-> %d", p -> vertex);
      p = p -> link;
    } 
    printf("\n");
  }
}

int main() {
  GraphType *g;
  g = (GraphType *)malloc(sizeof(GraphType));
  init(g);
  for(int i = 0; i &lt; 4 ; i ++)
    insert_vertex(g, i);
  
  insert_edge(g, 0, 1);
  insert_edge(g, 1, 0);
  insert_edge(g, 0, 2);
  insert_edge(g, 2, 0);
  insert_edge(g, 0, 3);
  insert_edge(g, 3, 0);
  insert_edge(g, 1, 2);
  insert_edge(g, 2, 1);
  insert_edge(g, 2, 3);
  insert_edge(g, 3, 2);
  print_adj_list(g);
  free(g);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>그래프 탐색</strong>
                      <hr>
                      그래프 탐색은 가장 기본적인 연산으로서 하나의 정점으로부터 시작하여 차례대로 모든 정점들을 한 번씩 방문하는 것이다. 그래프 탐색은 아주 중요하다. 많은 문제들이 단순히 그래프의 노드를 탐색하는 것으로 해결된다. 
                      <hr>
                      예 
                      <ul>
                        <li>도시를 연결하는 그래프가 있을 때, 특정 도시에서 다른 도시로 갈 수 있는지 없는지를 그래프를 특정노드에서 탐색하여 보면 알 수 있다. </li>
                        <li>전자회로에서 특정 단자와 단자가 서로 연결되어 있는지 연결되어 있지 않느지를 탐색을 통하여 알 수 있다. </li>
                      </ul>
                      <hr>
                      <ul>
                        <li>깊이 우선 탐색 ( DFS  : depth first search ) : 트리를 생각하면 이해하기 쉽다. 트리를 탐색할 때 시작 정점에서 한 방향으로 계속 가다가 더이상 갈 수 없게 되면 가장 가까운 갈림길로 돌아와서 다른 방향으로 다시 탐색을 진행하는 방법과 유사</li>
                        <li>너비 우선 탐색 ( DFS  : breath first search ) : 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져있는 정점을 나중에 방문하는 순회 방법이다.  </li>
                      </ul>
                      <hr>
                      깊이 우선 탐색 ( 인접 행렬 버전 )  <br>
                      <pre> 
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h> 

#define TRUE 1
#define FALSE 0
#define MAX_VERTICES 50

typedef struct GraphType {
  int n;
  int adj_map[MAX_VERTICES][MAX_VERTICES];
} GraphType;

int visited[MAX_VERTICES];

// 그래프 초기화 
void init(GraphType* g){
  int r, c;
  g -> n = 0;
  for ( r = 0; r &lt; MAX_VERTICES; r ++)
    for ( c = 0; c &lt; MAX_VERTICES; c ++)
      g -> adj_mat[r][c] = 0;
}

// 정점 삽입 연산 
void insert_vertex(GraphType* g, int start, int end){
  if(((g -> n ) + 1 ) > MAX_VERTICES){
    fprintf(stderr, "그래프: 정점의 개수 초과");
    return;
  } 
  g -> n ++;
}

// 간선 삽입 연산 
void insert_edge(GraphType* g, int start, int end){
  if( start >= g -> n ||  end >= g -> n ){
    fprintf(stderr, "그래프 : 정점 번호 오류");
    return;
  }
  g -> adj_mat[start][end] = 1;
  g -> adj_mat[end][start] = 1;
}

// 인접 행렬로 표현된 그래프에 대한 깊이 우선 탐색 
void dfs_mat(GraphType* g, int v){
  int w;
  visited[v] = TRUE; // 정점 v의 방문 표시 
  printf("정점 %d ->", v); // 방문한 정점 출력
  for ( w = 0; w &lt; g -> n ) // 인접 정점 탐색
    if ( g -> adj_mat[v][w] && !visited[w] )
      dfs_mat(g,w); // 정점 w에서 DFS 새로 시작 
}

int main(void){
  GraphType *g;
  g = (GraphType *)malloc((sizeof(GraphType)));
  init(g);
  for( int i = 0; i &lt; 4 ; i ++ ){
    insert_vertex(g,i);
  }
  insert_vertex(g,0,1);
  insert_vertex(g,0,2);
  insert_vertex(g,0,3);
  insert_vertex(g,1,2);
  insert_vertex(g,2,3);

  printf("깊이 우선 탐색\n");
  dfs_mat(g,0);
  printf("\n");
  free(g);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>깊이 우선 탐색의 구현</strong>
                      <hr>
                      그래프가 인접리스트로 표현되었을 경우의 깊이 우선 탐색 프로그램이다. 인접 리스트는 다수의 연결 리스트로 구성되는데, 각 연결 리스트의 노드는 데이터 필드와 링크 필드로 이루어지는데, 데이터 필드에는 
                      인접 정점의 번호가 저장되고 링크 필드에는 다음 인접 정점을 가리키는 포인터가 저장된다. 
                      <pre>
                        <code class="C" > 
int visited[MAX_VERTICES];

// 인접 리스트로 표현된 그래프에 대한 깊이 우선 탐색 
void dfs_list(GraphType* g, int v){
  GraphNode* w;
  visited[v] = TRUE;
  printf("정점 %d -> ", v);                      // 정점 V의 방문 표시 
  for ( w = g -> adj_list[v]; w; w = w -> link){ // 인접 정점 탐색 
    if ( !visited[w -> vertex])
      dfs_list(g, w -> vertex); // 정점 w에서 DFS 새로 시작 
  }
}
                        </code>
                      </pre>
                      <hr>
                      <strong>명시적인 스택을 이용한 깊이 우선 탐색의 구현</strong>
                      <pre>
                        <code class="C" >
DFS-iterative(G, v):

    스택 S를 생성한다. 
    S.push(v)
    while (not is_empty(S)) do 
        v = S.pop();
        if ( v가 방문되지 않았으면 )
            v를 방문되었다고 표시 
            for all u ∈ ( v에 인접한 정점 ) do 
                if ( u가 아직 방문되지 않았으면 )
                    S.push(u)

  스택을 하나 생성하여서 시작 정점을 스택에 넣는다. 이어서 스택에서 하나의 정점을 꺼내서 탐색을 시작한다. 정점을 
  방문한 후에 정점의 모든 인접 정점들을 스택에 추가한다. 스택에 하나도 남지 않을 때 까지 알고리즘은 계속된다.   
  
                        </code>
                      </pre>
                      깊이 우선 탐색은 그래프의 모든 간선을 조사하므로 정점의 수가 n이고 간선의 수가 e인 그래프인 경우, 그래프가 인접 리스트로 표현되어 있다면 시간 복잡도가 O(n+e) 이고, 
                      인접행렬로 표시되어 있다면 O(n^2)이다. 이는 희소 그래프인 경우 깊이 우선 탐색은 인접 리스트의 사용이 인접 행력보다 시간적으로 유리함을 뜻한다. 
                      <hr>
                      <strong>너비우선탐색</strong><br>
                      너비 우선 탐색은 시작 정점으로부터 가까운 정점을 먼저 방문하고 멀리 떨어져 있는 정점을 나중에 방문하는 순회 방법이다. 
                      <pre>
                        <code class="C" >
breadth_first_search(v):
  
    v를 방문되었다고 표시:
    큐 Q에 정점 v 를 삽입;
    while ( Q가 공백이 아니면 ) do 
      Q에서 정점 w를 삭제;
        for all u ∈ ( w에 인접한 정점 ) do 
          if ( u 가 아직 방문되지 않았으면 )
            then u를 큐에 삽입;
              u를 방문되었다고 표시;
                        </code>
                      </pre>
                      <hr>
                      <strong>너비 우선 탐색의 구현(인접행렬버전)</strong><br>
                      너비 우선 탐색은 큐를 사용하여야 깊이 우선 탐색보다 코드가 복잡해진다. 
                      <pre>
                        <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define TRUE 1
#define FALSE 0
#define MAX_QUEUE_SIZE 10

typedef int element;

typedef struct { // 큐 타입
  element queue[MAX_QUEUE_SIZE];
  int front, rear;
} QueueType;

// 오류 함수 
void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
} 

// 공백 상태 검출 함수 
void queue_init(QueueType *q){
  q -> front = q -> rear = 0;
}

// 공백 상태 검출 함수 
void is_empty(QueueType *q){
  return ( q -> front == q -> rear );
}

// 포화 상태 검출 함수 
void is_full(QueueType *q){
  return ((q -> rear + 1) % MAX_QUEUE_SIZE == q -> front );
}

// 삽입 함수 
void enqueue(QueueType *q, element item){
  if(is_full(q)){
    error("큐가 포화 상태 입니다. ");
  }

  q -> rear = ( q -> rear + 1 ) % MAX_QUEUE_SIZE;
  q -> queue[q -> rear] = item;
}

// 삭제함수 
element dequeue(QueueType *q){
  if(is_empty(q)){
    error("큐가 공백 상태입니다.");
  }
  q -> front = ( q -> front + 1) % MAX_QUEUE_SIZE;
  return q -> queue[q -> front];
}

#define MAX_VERTICES 50
typedef struct GraphType {
  int n;
  int adj_mat[MAX_VERTICES][MAX_VERTICES];
} GraphType;

int visited[MAX_VERTICES];

// 그래프 초기화
void graph_init(GraphType* g){
  int r, c;
  g -> n = 0;
  for ( r = 0; r &lt; MAX_VERTICES ; r ++){
    for ( c = 0; c &lt; MAX_VERTICES ; c ++ ){
      g -> adj_mat[r][c] = 0;
    }
  }
}

// 정점 삽입 연산
void insert_vertex(GraphType* g, int v){
  if(((g -> n) + 1)  > MAX_VERTICES ){
    fprintf(stderr, "그래프: 정점의 개수 초과");
    return;
  }
  g -> n ++;
}

// 간선 삽입 연산 
void insert_edge(GraphType* g, int start, int end){
  if ( start >= g -> n || end >= g -> n ) {
    fprintf(stderr, "그래프: 정점 번호 오류");
    return;
  }
  g -> adj_mat[start][end] = 1;
  g -> adj_mat[end][start] = 1;
}

void bfs_mat(GraphType* g, int v){
  int w;

  QueueType q;

  queue_init(&q);

  visited[v] = TRUE;
  printf("%d 방문 -> ", v);
  enqueue(&q, v);
  while(!is_empty(&q)){
    v = dequeue(&q);
    for ( w = 0; w &lt; g -> n ; w ++){
      if( g -> adj_mat[v][w] && !visited[w]) {
        visited[w] = TRUE;
        printf("%d 방문 ->", w);
        enqueue(&q , w);
      }
    }
  }
}

int main(void){
  GraphType *q;
  g = (GraphType *)malloc(sizeof(GraphType));
  graph_init(g);
  for ( int i = 0 ; i &lt; 6 ; i ++){
    insert_vertex(g, i);
  }
  insert_edge(g, 0, 2); 
  insert_edge(g, 2, 1);
  insert_edge(g, 2, 3);
  insert_edge(g, 0, 4);
  insert_edge(g, 4, 5);
  insert_edge(g, 1, 5);

  printf("너비 우선 탐색\n");
  bfs_mat(g, 0);
  free(g);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>너비 우선 탐색의 구현(인접 리스트 버전)</strong>
                      <pre>
                        <code class="C" > 
void bfs_list(GraphType* g, int v){
  GraphNod* w;
  QueueType q;

  init(&q);                                            // 큐 초기화 
  visited[v] = TRUE;                                   // 정점 v 방문 표시 
  printf("%d 방문 -> ", v);
  enqueue(&q, v);                                      // 시작 정점을 큐에 저장 
  while(!is_empty(&q)) {
    v = dequeue(&q);                                   // 큐에 저장된 정점 탐색 
    for ( w = g -> adj_list[v] ; w; w = w -> link ){   // 인접 정점 탐색
      if(!visited[w -> vertex]){                       // 미방문 정점 탐색
        visited[w -> vertex] = TRUE;                   // 방문 표시
        printf("%d 방문 -> ", w -> vertex);
        enqueue(&q , w -> vertex);                     // 정점을 큐에 삽입
      }
    }
  }
}
                        </code>
                      </pre>
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading19">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse19" aria-expanded="false" aria-controls="collapse19">
                        그래프 II
                      </button>
                    </h2>
                  </div>
                  <div id="collapse19" class="collapse" aria-labelledby="heading19" data-parent="#accordionExample">
                    <div class="card-body">
                      신장 트리란 그래프 내의 모든 정점을 포함하는 트리다. 신장 트리는 특수한 형태이므로 모든 정점들이 연결되어 있어야 하고 또한 사이클을 포함해서는 안된다. 
                      따라서 신장 트리는 그래프에 있는 n개의 정점을 정확히 ( n - 1) 개의 간선으로 연결하게 된다. 하나의 그래프에서는 많은 신장 트리가 존재 가능하다. 
                      <hr>
                      신장 트리는 깊이 우선이나 너비 우선 탐색 도중에 사용된 간선만 모으면 만들 수 있다. 신장 트리를 만들려면 깊이 우선이나 너비 우선 탐색때 사용한 간선들을 표시하면 된다. 
                      <pre>
                        <code class="C" >
depth_first_search(v):

    v를 방문되었다고 표시; 
    for all u ∈ ( v에 인접한 정점 ) do 
        if ( u가 아직 방문되지 않았으면 )
            then ( v, u )를 신장 트리 간선이라고 표시;
                depth_first_search(u);                      
                        </code>
                      </pre>
                      <hr>
                      <strong>최소 비용 신장 트리</strong>
                      <hr>
                      통신망 , 도로망, 유통망은 간선에 가중치가 부여된 네크워크로 표현될 수 있다. 가중치는 길이 , 구축 비용, 전송 시간등을 나타낸다. 이러한 도로망, 통신망, 유통망을 가장 적은 비용으로 
                      구축하고자 한다면, 네트워크에 있는 모든 정점들을 가장 적은 수의 간선과 비용으로 연결하는 최소 비용 신장 트리가 필요하게 된다. 최소 비용 신장 트리는 신장 트리 중에서 사용된 간선들의 
                      가중치 합이 최소인 신장 트리를 말한다. 
                      응용의 예 <br>
                      <ul>
                        <li>도로건설 - 도시들을 모두 연결하면서 도로의 길이가 최소가 되도록 하는 문제</li>
                        <li>전기회로 - 단자들을 모두 연결하면서 전선의 길이가 가장 최소가 되도록 하는 문제</li>
                        <li>통신 - 전화선의 길이가 최소가 되도록 전화 케이블 망을 구성하는 문제</li>
                        <li>배관 - 파이프를 모두 연결하면서 파이프의 총 길이가 최소가 되도록 연결하는 문제</li>
                      </ul>
                      <hr>
                      <strong>Kruskal의 MST 알고리즘</strong> <br>
                      Kruskal의 알고리즘은 탐욕적인 방법을 이용한다. 탐욕적인 방법은 알고리즘 설계에서 있어서 중요한 기법 중의 하나이다. 탐욕적인 방법이란 선택할 때마다 
                      그 순간 가장 좋다고 생각되는 것을 선택함으로써 최종적인 해답에 도달하는 방법이다. 
                      <br>
                      탐욕적인 알고리즘에서 순간의 선택은 그 당시에는 최적이다. 하지만 최적이라고 생각했던 지역적인 해답들을 모아서 최종적인 해답을 만들었다고 해서, 
                      그 해담이 반드시 전역적으로 최적이라는 보장은 없다. 따라서 탐욕 적인 방법은 항상 최적의 해답을 주는지를 검증해야 한다. 다행히 Kruskal의 알고리즘은 최적의 
                      해답을 주는 것으로 증명되어 있다. Kruskal의 알고리즘은 최소 비용 신장 트리가 최소 비용의 간선으로 구성됨과 동시에 사이클을 포함하지 않는다는 조건에 근거하여, 
                      각 단계에서 사이클을 이루지 않는 최소 비용 간선을 선택한다. 이러한 과정을 반복함으로써 네트워크의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구할 수 잇다. 
                      <pre>
                        <code class="C" >
# Krusal의 MST 알고리즘 ( 코드는 별도로 작성필요 )

// 최소비용 신장 트리를 구하는 Krusal의 알고리즘 
// 입력 : 가중치 그래프 G = ( V , E), n은 노드의 개수 
// 출력 : Et, 최소 비용 신장 트리를 이루는 간선들의 집합 

                        </code>
                      </pre>
                      <img src="./Kruskal.jpg" alt="" class="img-thumbnail" srcset=""><br>
                      Kruskal 의 알고리즘을 이용하여 최소 비용 신장 트리를 만드는 과정을 보여준다. 먼저 간선들을 가중치의 오름차순으로 정렬한다. <br>
                      간선의 양끝 정점이 같은 집합에 속하면 간선을 추가하였을 경우, 사이클이 형성된다. <br>
                      간선이 서로 다른 집합에 속하는 정점을 연결하면 사이클이 형성되지 않는다. 

                      <hr>
                      <strong>union-find 연산</strong><br>
                      union-find 연산은 Kruskal의 알고리즘에서만 사용되는 것이 아니고 일반적으로 널리 사용된다. union(x,y) 연산은 원소 x 와 원소 y가 속해있는 
                      집합을 입력으로 받아 2개의 집합의 합집합을 만든다. find(x) 연산은 원소 x가 속해있는 집합을 반환한다. 
                      <br>
                      union-find 연산의 구현 <br>
                      집합을 구현하는 데는 여러가지 방법이 있을 수 있다. 즉 비트 벡터, 배열, 연결 리스트를 이용하여 구현될 수 있다. 그러나 가장 효율적인 방법은 트리형태를 사용하는 것이다. <br>
                      우리는 부모 노드만 알면 되므로 "부모 포인터 표현"을 사용한다. "부모 포인터 표현"이란 각 노드에 대해 그 노드의 부모에 대한 포인터만 저장하는 것이다. 이것은 일반적인 목적에는 부적합하다. 
                      즉 노드의 가장 왼쪽 자식 또는 오른쪽 자식을 찾는 것과 같은 중요한 작업에는 부적절하기 때문이다. 
                      <pre>
                        <code class="C" >
UNION(a, b) :
    root1 = FIND(a);
    root2 = FIND(b);
    if root1 != root2 
        parent[root1] = root2;
    
    FIND(curr);  // curr의 루트를 찾는다. 
    if ( parent[curr] == -1 )
        return curr;
    while( parent[curr] != -1 ) curr = parent[curr];
    return curr;                  
                        </code>
                      </pre>

                      <pre>
                        <code class="C" >
int parent[MAX_VERTICES]; // 부모 노드 

void set_init(int n) 
{
  for ( int i = 0; i &lt; n ; i ++){
    parent[i] = -1;
  }
}

// curr 가 속하는 집합을 반환한다. 
int set_find(int curr)
{
  if ( parent[curr] == -1){
    return curr;
  }
  while(parent[curr] != -1 ) curr = parent[curr];
  return curr;
}

// 두개의 원소가 속한 집합을 합친다. 
void set_union(int a, int b){
  int root1 = set_find(a);
  int root2 = set_find(b);
  if ( root1 != root2 ){
    parent[root1] = root2;
  }
}
                        </code>
                      </pre>
                      <hr>
                      <strong>kruskal 알고리즘 구현</strong>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define TRUE 1
#define FALSE 0

#define MAX_VERTICES 100
#define INF 1000

void set_init(int n){
  for ( int i = 0; i &lt; n ; i ++ ){
    parent[i] = -1;
  }
}

// curr 가 속하는 집합을 반환한다. 
int set_find(int curr){
  if(parent[curr] == -1){
    return curr;
  }
  while( parent[curr] != 1 ) curr = parent[curr];
  return curr;
}

// 두개의 원소가 속한 집합을 합친다. 
void set_union(int a, int b){
  int root1 = set_find(a);
  int root2 = set_find(b);
  if ( root1 != root2 )
    parent[root1] = root2;
}

struct Edge {
  int start, end, weight;
};

typedef struct GraphType {
  int n;
  struct Edge edges[2 * MAX_VERTICES];
} GraphType;

void graph_init(GraphType* g){
  g -> n = 0;
  for(int i = 0; i &lt; 2 * MAX_VERTICES ; i ++){
    g -> edge[i].start = 0
    g -> edge[i].end = 0;
    g -> edge[i].weight = INF;
  }
}

// 간선 삽입 연산 
void insert_edge(GraphType* g){
  g -> edge[i].start = 0
  g -> edge[i].end = 0;
  g -> edge[i].weight = INF;
  g -> n ++;
}

// qsort()에 사용되는 함수 
int compare(const void* a, const void* b){
  struct Edge* x = (struct Edge*)a;
  struct Edge* y = (struct Edge*)b;
  return ( x -> weight - y -> weight );
}

// kruskal의 최소 비용 신장 트리 프로그램 
void kruskal(GraphType *g){
  int edge_accepted = 0; // 현재까지 선택된 간선의 수 
  int uset, vset;        // 정점 u 와 정점 v 의 집합번호 
  struct Edge e;

  set_init(g -> n); // 집합 초기화 
  qsort(g -> edges, g -> n, sizeof(struct Edge), compare);

  printf("크루스칼 최소 신장 트리 알고리즘 \n");
  int i = 0;
  while ( edge_accepted &lt; ( g -> n - 1)) // 간선의 수 
  {
    e = g -> edges[i];
    uset = set_find(e.start);
    vset = set_find(e.end);
    if(uset != vset){
      printf("간선 (%d,%d) %d 선택 \n", e.start, e.end, e.wegiht );
      edge_accepted ++;
      set_union(uset, vset);
    }
    i ++;
  }
}

int main(void) {
  GraphType *g;

  g = (GraphType *) malloc(sizeof(GraphType));
  graph_init(g);

  insert_edge(g, 0, 1, 29);
  insert_edge(g, 1, 2, 16);
  insert_edge(g, 2, 3, 12);
  insert_edge(g, 3, 4, 22);
  insert_edge(g, 4, 5, 27);
  insert_edge(g, 5, 0, 10);
  insert_edge(g, 6, 1, 15);
  insert_edge(g, 6, 3, 18);
  insert_edge(g, 6, 4, 25);

  kruskal(g);
  free(g);
  return 0;
}

                        </code>
                      </pre>
                      <hr>
                      <strong>시간 복잡도 분석</strong><br>
                      Kruskal의 알고리즘의 시간 복잡도는 간선들을 정렬하는 시간에 좌우된다. 따라서 효율적인 정렬 알고리즘을 사용한다면 Kruskal의 알고리즘의 시간 복잡도는 |e|log2|e|이다. 
                      <hr>
                      <strong>Prim의 MST 알고리즘 </strong><br>
                      Prim의 알고리즘은 시작 정점에서부터 출발하여 신장 트리 집합을 단게적으로 확장해 나가는 방법이다. 시작 단계에서는 시작 정점만이 신장 트리 집합에 포함된다. Prim의 방법은 앞 단계에서 만들어진 신장 트리 집합에, 인접한 정점들 중에서 최저 간선으로 연결된 정점을 선택하여 
                      트리를 확장한다. 이 과정은 트리가 n-1개의 간선을 가질 때까지 계속된다. Kruskal 의 알고리즘과 비교를 해보면 먼저 Kruskal의 알고리즘은 간선을 기반으로 하는 알고리즘인 반면 Prim의 알고리즘은 정점을 기반으로 하는 알고리즘이다. 또한 Kruskal의 알고리즘에서는 이전 단계에서 만들어진 
                      신장 트리와는 상관 없이 무조건 최저 간선만을 선택하는 방법인었던게 반하여 Prim 알고리즘은 이전 단계에서 만들어진 신장 트리를 확장하는 방식이다. 
                      <pre>
                        <code class="C" >
// 최소 비용 신장 트리를 구하는 Prim의 알고리즘 
// 입력 : 네트워크 G = ( V, E ), S 는 시작 정점 
// 출력 : Vt , 최소 비용 신장 트리를 이루는 정점들의 집합 

                        </code>
                      </pre>
                      <strong>Prim의 알고리즘의 구현 </strong><br>
                      <pre>
                        <code class="C" >
// 최소 비용 신장 트리를 구하는 Prim의 알고리즘 
// 입력 : 네트워크 G = ( V , G ) , s 는 시작 정점 
// 출력 : 최소 비용 신장 트리를 이루는 정점들의 집합                           

                        </code>
                      </pre>
                      정점들이 트리 집합에 추가되면서 distance 값은 변경된다. 다음에 우선 순위 큐 Q 가 하나 필요하다. 배열로 구현할 수도 있고 아니면 히프를 사용하면 보다 효율적인 프로그램이 될 것이다. 우선 순위 큐에 모든 정점을 삽입한다. 이때의 우선 순위는 distance 배열 값이 된다. 다음은 while 루프로 우선순위 큐에서 가장 작은 distnace 값을 가지는 
                      정점을 끄집어 낸다. 바로 이정점이 트리 집합에 추가된다. 여기서는 그냥 화면에 이 정점의 번호를 출력하기로 하는 것으로 만족하자. 
                    다음에는 트리 집합에 새로운 정점 u가 추가되었으므로 u에 인접한 정점 v 들의 distance 값을 변경시켜준다. 즉 기존의 distance[v] 값 보다 간선 ( u , v )의 가중치 값이 적으면 간선 ( u, v) 의 가중치 값으로 dist[v]를 변경시킨다. Q에 있는 모든 정점들이 소진될 때까지 이것을 되풀이 하면 된다. 한번 선택된 정점은 Q에서 삭제되므로 
                    다시 선택되지는 않음을 명심하라. 그리고 트리 집합에 인접하지 않는 정점들의 distance 값은 무한대이므로 역시 선택되지 않을 것이다. 코드를 간단하게 하기 위하여 오류 처리를 생략했음을 유의해야 한다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define TRUE 1
#define FALSE 0
#define MAX_VERTICES 100
#define INF 1000L

typedef struct GraphType {
  int n ;
  int weight[MAX_VERTICES][MAX_VERTICES];
} GraphType;

int selected[MAX_VERTICES];
int distance[MAX_VERTICES];

// 최소 dist[v] 값을 갖는 정점을 반환 
int get_min_vertex(int n){
  int v, i;
  for ( i = 0; i &lt; n; i ++){
    if(!selected[i]){
      v = i;
      break;
    }
  }

  for ( i= 0; i &lt; n ; i ++ ){
    if ( !selected[i] && ( distance[i] &lt; distance[v])) v = i;
  }

  return (v);
}

void prim(GraphType* g, int s){
  int i, u, v;

  for( u = 0; u &lt; g -> n ; u ++){
    distance[u] = INF;
  }
  distance[s] = 0;
  for ( i = 0; i &lt; g -> n ; i ++ ){
    u = get_min_vertex(g -> n);
    selected[u] = TRUE;
    if(distance[u] == INF) return;
    printf("정점 %d 추가 \n", u);
    for( v = 0; v &lt; g -> n ; v ++){
      if ( g -> weight[u][v] != INF ){
        if(!selected[v] && g -> wegiht[u][v] &lt; distance[v]){
          distance[v] = g -> weight[u][v];
        }
    }
  }
}

int main(void){
  GraphType g = { 7, 
    {
      { 0,   29,  INF, INF, INF, 10,  INF }
      { 29,  0,   16,  INF, INF, INF, 15 }
      { INF, 16,  0,   12,  INF, INF, INF }
      { INF, INF, 12,  0,   22,  INF, 18 }
      { INF, INF, INF, 22,  0,   27,  25 }
      { 10,  INF, INF, INF, 27,  0,   INF }
      { INF, 15,  INF, 18,  25,  INF, 0 } 
    }
  };

  prim(&g, 0);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>최단 경로</strong><br>
                      최단 경로 문제는 네트워크에서 정점 i 와 정점 j를 연결하는 졍로 중에서 간선들의 가중치 합이 최소가 되는 경로를 찾는 문제이다. 간선의 가중치는 비용, 거리, 시간 등을 나타낸다.  <br>
                      지도를 나타내는 그래프에서 정점은 각 도시들을 나타내고 가중치는 한 도시에서 다른 도시로 가는 거리를 의미한다. 여기서의 문제는 도시 u에서 도시 v로 가는 거리 중에서 전체 길이가 최소가 되는 경로르 찾는 것이다. <br>
                      2가지의 알고리즘이 있다. <br>
                      <ul>
                        <li>Dijkstra</li>
                        <li>Floyd</li>
                      </ul>
                      <hr>
                      <strong>Dijkstra</strong><br>
                      Dijkstra의 최단 경로 알고리즘은 네트워크에서 하나의 시작 정점으로부터 모든 다른 정점까지의 최단 경로를 찾는 알고리즘이다. 최단 경로는 경로이 길이 순으로 구해진다. 먼저 집합 S를 시작 정점 v로부터의 최단 경로가 
                      이미 발견된 정점들의 집합이라고 하자. Dijkstra의 알고리즘에서는 시작 정점에서 집합 S에 있는 정점만을 거쳐서 다른 정점으로 가는 최단 거리를 기록하는 배열이 반드시 있어야 한다. 이 1차원 배열을 distance 라고 한다. 
                      시작정점을 v 이라하면 distance [v] = 0 이고 다른 정점에 대한 distance 값은 시장 정점과 해당 정점간의 가중치값이 된다. 
                      가중치는 보통 가중치 인접 행력에 저장되므로 가중치 인접 행렬을 weight이라 하면 distance[w] = weight [v][w] 가 된다. 정점 v에서 정점 w로의 직접 간선이 없을 경우에는 무한대의 값을 저장한다. 
                      시작단계에서는 아직 최단 경로가 발견된 정점이 없으므로 S = { v } 일 것이다. 측 처음에는 시작정점 v를 제외하고는 최단거리가 알려진 정점이 없다. 알고리즘이 진행되면서 최단거리가 발견되는 정점들이 
                      S에 하나씩 추가될 것이다. 
                      <pre>
                        <code class="C" >
// 입력 : 가중치 그래프 G, 가중치는 음수가 아님. 
// 출력 : distance 배열, distance[u] 는 v에서 u까지의 최단 거리이다. 
shortest_path( G, V ) :

    S &lt;- {v}
    for 각 정점 w ∈ G do 
        distance[w] &lt;- weight[v][w];
    while 모든 정점이 S에 포함되지 않으면 do 
        u &lt;- 집합 S에 속하지 않은 정점 중에서 최소 distance 정점;
        S &lt;- S ∪ {u}
        for u에 인접하고 S에 있는 각 정점 z do 
            if distance[u] + weight[u][z] &lt; distance[z] 
                then distance[z] &lt;- distance[u] + weight[u][z];                          
                        </code>
                      </pre>
                      <hr>
                      Dijkstra의 알고리즘 구현 <br>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;limits.h>

#define TRUE 1
#define FALSE 0
#define MAX_VERTICES 100
#define INF 1000000 

typedef struct GraphType {
  int n;
  int weight[MAX_VERTICES][MAX_VERTICES];
} GraphType;

int distance[MAX_VERTICES];
int found[MAX_VERTICES];

int choose(int distance[], int n, int found[])
{
  int i, min, minpos;
  min = INT_MAX;
  minpos = -1;
  for ( i = 0; i &lt; n; i ++){
    if( distance[i] &lt; min && !found[i]){
      min = distance[i];
      minpos = i;
    }
  }
  return minpos;
}

void print_status(GraphType* g)
{
  static int step = 1;
  printf("STEP %d : ", step ++);
  printf("distance : ");
  for ( int i = 0; i &lt; g -> n ; i ++ ){
    if( distance[i] == INF ){
      printf(" * ");
    }else{
      printf("%2d", distance[i] );
    }
  }
  printf("\n");
  ptinff(" found : ");
  for ( int i = 0; i &lt; g -> n ; i ++ ){
    printf("%2d ", found[i]);
  }
  printf("\n\n");
}

void shortest_path(GraphType* g, int start)
{
  int i, u, w;
  for ( i = 0; i &lt; g -> n; i ++){
    distance[i] = g -> weight[start][i];
    found[i] = FALSE;
  }
  found[start] = TRUE;
  distance[start] = 0;
  for ( i = 0; i &lt; g -> n -1 ; i++){
      print_status(g);
      u = choose(distance, g -> n, found);
      found[u] = TRUE;
      for ( w = 0; w &lt; g -> n ; w ++){
        if(!found[w]){
          if(distance[u] + g -> wegiht[u][w] &lt; distance[w] )
            distance[w] = distance[u] + g -> weight[u][w];
        }
      }
  }
}

int main(void) 
{
  GraphType g = {

  };

  shortest_path(&g, 0);
  return 0;
}

                        </code>
                      </pre>
                      네트워크에 n개의 정점이 있다면, 최단 경로 알고 리즘은 주반복문을 n번 반복하고 내부 반복문을 2n번 반복하므로 O(n^2) 의 복잡도를 가진다. 
                      <hr>
                      <strong>Floyd 의 최단 경로 알고리즘 </strong><br>
                      그래프에 존재하는 모든 정점 사이의 최단 경로를 구하려면 Dijkstra의 알고리즘을 정점의 수만큼 반복 실행하면 된다. 그러나 모든 정점 사이의 최단 거리를 구하려면 
                      더 간단하고 좋은 알고리즘이 존재한다. Floyd의 최단 경로 알고리즘은 그래프에 존재하는 모든 정점 사이의 최단 경로를 한 번에 모두 찾아주는 알고리즘이다. 
                      <pre>
                        <code class="C" >
floyd(G):

    for k &lt;- to n - 1 
        for i &lt;- 0 to n - 1
            for j &lt;- 0 to n - 1
                A[i][j] = min(A[i][j], A[i][k] + A[k][j])
                        </code>
                      </pre>
                      <img src="./Floyd_001.jpg" class="img-thumbnail" alt="" srcset="">
                      <ul>
                        <li>
                          정점 k를 거쳐서 가지 않는 경우 : <br>
                          A^k[i][j]는 k보다 큰 정점은 통화하지 않으므로 이경우 최단 거리는 A^k-1[i][j] 가 된다. 
                        </li>
                        <li>
                          정점 k를 통과하는 경우 : <br>
                          이 경우 i에서 k까지의 최단거리 A^k-1[i][k]에다가 k에서 j까지의 최단거리인 A^k-1[j][k]를 더한 값이 될 것이다. 
                        </li>
                      </ul>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define TRUE 1
#define FALSE 0
#define MAX_VERTICES 100
#defind INF 1000000 /* 무한대 ( 연결이 없는 경우 ) */

typedef struct GraphType {
  int n;
  int weight[MAX_VERTICES][MAX_VERTICES];
} GraphType;

int A[MAX_VERTICES][MAX_VERTICES];

void printA(GraphType *g){
  int i, j;
  printf("=====================================\n");
  for ( i = 0; i &lt; g -> n ; i ++){
    for( j = 0; j &lt; g -> n ; j ++){
      if(A[i][j] == INF ){
        printf(" * ");
      }else{
        printf("%3d", A[i][j]);
      }
      printf("\n");
    }  
  }
  printf("=====================================\n")
}

void floyd(GraphType *g){
  int i, j, k;
  for ( i = 0 ; j &lt; g -> n ; i ++)
    for ( j = 0 ; j &lt; g -> n ; j++)
      A[i][j] = g -> weight[i][j];
  printA(g);

  for ( k = 0; k &lt; g -> n ; k ++ ) {
    for ( i = 0; i &lt; g -> n ; i ++ )
      for ( j = 0; j &lt; g -> n ; j ++ )
        if( A[i][k] + A[k][j] &lt; A[i][j] ) 
          A[i][j] = A[i][k] + A[k][j];
  
    printA(g);
  }
}

int main(void){
  GraphType g = {


  }

  floyd(&g);

  return 0;
}

                        </code>
                      </pre>
                      두 개의 정점 사이의 최단 경로를 찾는 Dijkstra의 알고리즘은 시간 복잡도가 O(n^2)이므로, 모든 정점 쌍의 최단 경로를 구하려면 Dijkstra의 알고리즘을 
                      n 번 반복해야 하므로 전체 복잡도는 O(n^3)이 된다. 한 번에 모든 정점 간의 최단 경로를 구하는 Floyd의 알고리즘은 3중 반복문이 실행되므로 시간 
                      복잡도가 O(n^3)으로 표현되고, 이는 Dijkstra의 알고리즘과 비교해 차이는 없다고 할 수 있다. 
                      <hr>
                      <strong>위상 정렬</strong><br>
                      큰 프로젝트는 많은 작업으로 나누어서 수행하게 된다. 이 경우 전체 프로젝트는 각각의 작업이 완료되어야만 끝나게 된다. 컴퓨터 관련 전공에서
                      과목을 수강하는 것도 비슷하다. 성공적으로 학위를 취득하려면 각각의 교과목들을 순서에 따라 성공적으로 수강하여야만 한다. 
                      예를 들어 자료구조를 수강하라면 먼저 전산한 개론과 이산 수학을 수강하여야 한다. 즉 선수 과목은 과목의 선행 관계를 표현하게 된다. 그래프를 사용하면 이 같은 각각의 
                      과목들 간의 선행 관계를 명확하게 표현 할 수 있다. 이러한 방향 그래프에서 간선 &lt; u , v > 가 있다면 정점 u 는 정점 v를 선행한다고 말한다. 
                      방향 그래프에 존재하는 각 정점들의 선행 순서를 위배하지 않으면서 모든 정점을 나열하는 것을 방향 그래프의 위상 정렬이라고 한다. 
                      <hr>
                      방향 그래프를 대상으로 위상 정렬을 하기 위한 알고리즘은 간단하다. 먼저 진입 차수가 0인 정점을 선택하고, 선택한 정점과 여기에 부착된 모든 간선을 삭제한다. 
                      이와 같은 진입 차수 0인 정점의 선택과 삭제 과정을 반복해서 모든 정점이 선택/삭제 되면 알고리즘이 종료된다. 진입 차수가 0인 정점이 여러 개 존재할 경우 
                      어느 정점을 선택하여도 무방하다. 이 과정에서 선택되는 정점의 순서를 위상 순서라고 한다. 위의 과정 중에 그래프에 남아 있는 정점 중에 진입 차수 0인 정점 
                      이 없다면, 이러한 그래프로 표현된 프로젝트는 실행 불가능한 프로젝트가 되고 위상 정렬 알고리즘은 중단된다. 
                      <pre>
                        <code class="C" >
// Input : 그래프 G = ( V , E )
// Output :  위상 정렬 순서 

topo_sort(G)

for i &lt;- to n-1 do 
    if( 모든 정점이 선행 정점을 가지면 )
        then 사이클이 존재하고 위상 정렬 불가 
    선행 정점을 가지지 않는 정점 v 선택;
    v를 출력;
    v와 v에서 나온 모든 간선들을 그래프에서 삭제;
                        </code>
                      </pre>

                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define TRUE 0
#define FALSE 0
#define MAX_VERTICES 50

typedef struct GraphNode {
  int vertex;
  struct GraphNode *link;
} GraphNode;

typedef struct GraphType {
  int n;
  GraphNode *adj_list[MAX_VERTICES];
} GraphType;

// 그래프 초기화 
void graph_init(GraphType *g){
  int v;
  g -> n = 0;
  for ( v = 0 ;  v &lt; MAX_VERTICES ; v ++ ){
    g -> adj_list[v] = NULL;
  }
}

// 정점 삽입 연산 
void insert_vertex(GraphType *g, int v){
  if(((g -> n) + 1) > MAX_VERTICES ){
    fprintf(stderr, "그래프: 정점의 개수 초과");
    return;
  }
  g -> n ++;
}

// 간선 삽입 연산, v를 u의 인접 리스트에 삽입한다. 
void insert_edge(GraphType *g, int v ){
  GraphNode *node;
  if( u >= g -> n || v >= g -> n ) {
    fprintf(stderr, "그래프 : 정점 번호 오류 ");
    return;
  }
  node = (GraphNode *)malloc(sizeof(GraphNode));
  node -> vertex = v;
  node -> link = g -> adj_list[u];
  g -> adj_list[u] node;
}                       

#define MAX_STACK_SIZE 100
typedef int element;
typedef struct {
  element stack[MAX_STACK_SIZE];
  int top;
}

// 스택 초기화 변수 
void init(StackType *s){
  s -> top = -1;
}

// 공백 상태 검출 함수 
int is_empty(StackType *s){
  return ( s -> top == -1 );
}

// 포화 상태 검출 함수 
int is_full(StackType *s){
  return ( s -> top == ( MAX_STACK_SIZE - 1 )) ;
}

// 삽입 함수 
void push(StackType *s, element item){
  if(is_full(s)){
    fprintf(stderr, " 스택 포화 에러 \n");
    return;
  }
  else s -> stack[(s -> top) --];
}

// 삭제함수 
element pop(StackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return s -> stack[(s->top)--];
}

// 위상 정렬을 수행한다. 
int topo_sort(GraphType *g){
  int i;
  StackType s;
  GraphNode *node;

  // 모든 정점의 진입 차수를 계산 
  int *in_degree = (int*)malloc(g -> n * sizeof(int));
  for ( i = 0 ; i &lt; g -> n ; i ++){
    in_degree[i] = 0;
  }
  for( i = 0; i &lt; g -> n ; i ++){
    GraphNode *node = g -> adj_list[i];
    while( node != NULL ){
      in_degree[node -> vertex] ++;
      node = node -> link;
    }
  }

  // 진입 차수가 0인 정점을 스택에 삽입 
  int(&s);
  for( i = 0; i &lt; g -> n ; i ++){
    if ( in_degree[i] == 0 ) push(&s, i);
  }

  // 위상 순서를 생성 
  while(!is_empty(&s)){
    int w;
    w = pop(&s);
    printf("정점 %d -> ", w); // 정점 출력 
    node = g -> adj_list[w];  // 각 정점의 진입 차수를 변경 
    while ( node != NULL){
      int u = node -> vertex;
      in_degree[u]--;
      if ( in_degree[u] == 0 ) push(&s, u);
      node = node -> link;
    }
  }
  free(in_degree);
  printf("\n");
  return ( i == g -> n );
}

int main(void) {
  GraphType g;

  graph_init(&g);
  insert_vertex(&g, 0);
  insert_vertex(&g, 1);
  insert_vertex(&g, 2);
  insert_vertex(&g, 3);
  insert_vertex(&g, 4);
  insert_vertex(&g, 5);
  
  // 정점 0의 인접 리스트 생성
  insert_edge(&g, 0, 2);
  insert_edge(&g, 0, 3);

  // 정점 1의 인접 리스트 생성
  insert_edge(&g, 1, 3);
  insert_edge(&g, 1, 4);

  // 정점 2의 인접 리스트 생성
  insert_edge(&g, 2, 3);
  insert_edge(&g, 2, 5);

  // 정점 3의 인접 리스트 생성 
  insert_edge(&g, 3, 5);

  // 정점 4의 인접 리스트 생성 
  insert_edge(&g, 4, 5);

  // 위상 정렬
  topo_sort(&g);

  // 동적 메모리 반환 코드 생략 
  return 0;
}
                        </code>
                      </pre>
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading9">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse9" aria-expanded="false" aria-controls="collapse9">
                         정렬 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse9" class="collapse" aria-labelledby="heading9" data-parent="#accordionExample">
                    <div class="card-body">
                      정렬은 물건을 크기 순으로 오름차순이나 내림차순으로 나열하는 것을 의미한다. 예를 들어 책들은 제목순이나 저자순, 또는 발간 연도순으로 정렬이 가능하다. 사람도 나이나 키, 이름등을 이용하여 정렬할 수 있다. 
                      물건 뿐만 아니라 어떤 형태의 것도 서로 비교만 가능하면 정렬 할 수 있다. 
                      <hr>
                      일반적으로 보통 정렬시켜야 될 대상은 레코드라고 분린다. 레코드는 다시 필드라고 하는 단위로 나누어진다. 예를 들어 학생들의 레코드라면 이름, 학번, 주소, 전화번호 등이 
                      필드가 될 것이다. 여러 필드 중에서 특별히 레코드와 레코드를 식별해주는 역할을 하는 필드를 키라고 한다. 학생들의 레코드의 경우에는 학번이 키가 될 수 있다. 정렬이란 결국 
                      레코드들을 키값의 순서로 재배열하는 것이다. 
                      <hr>
                      정렬 알고리즘을 평가하는 효율성의 기준으로는 정렬을 위해 필요한 비교 연산의 횟수와 이동 연산의 횟수다. 
                      <hr>
                      <ul>
                        <li>단순하지만 비효율적인 방법 <br>
                          삽입 정렬, 선택 정렬, 버블 정렬 등 
                        </li>
                        <li>
                          복잡하지만 효율적인 방법 <br>
                          퀵 정렬, 히프 정렬, 합병 정렬, 기수 정렬 등 
                        </li>
                        <li>
                          안정성을 충족하는 방법 <br>
                           삽입 정렬 , 버블 정렬, 합병 정렬 등 
                        </li>
                      </ul>
                      <hr>
                      <strong>선택 정렬</strong> <br>
                      선택 정렬은 가장 이해하기귀 쉬운 정렬 방법이다. 먼저 왼쪽 리스트와 오른쪽 리스트, 두 개의 리스트가 있다고 가정하자. 왼쪽 리스트에는 정렬이 완료된 숫자들이 
                      들어가게 되며 오른쪽 리스트에는 정렬되지 않은 숫자들이 들어 있다. 선택 정렬은 오른쪽 리스트에서 가장 작은 숫자를 선택하여 왼쪽 리스트로 이동하는 작업을 되풀이 한다. 
                      선택 정렬은 오른쪽 리스트가 공백 상태가 될 때 까지 이 과정을 되풀이 하는 정렬 기법이다. 
                      <hr>
                      위와 같은 방식은 정렬을 위해서 정렬할 대상과 동일한 메모리 공간이 필요하기 때문에 추가 메모리를 요구하지 않는 제자리 정렬(in-place sorting) 방법을 이용한다. 
                      <hr>
                      선택 정렬 알고리즘 <br>
                      <pre>
                        <code class="C" >
selection_sort(A, n) :

for i &lt;- 0 to n - 2 do 
    least &lt;- A[i], A[i+1], ... , A[n-1] 중에서 가장 값의 인덱스 ;
    A[i] 와 A[least] 의 교환;
    i ++;
                        </code>
                      </pre>
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading1700">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#heading1700" aria-expanded="false" aria-controls="heading1700">
                        
                      </button>                    
                    </h2>
                  </div>
                  <div id="heading1700" class="collapse" aria-labelledby="heading1700" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                  </div>   
              </div>               
            </div>
            <div class="card-footer small text-muted"></div>
          </div>
          
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
    

    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

 

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>
  </body>

</html>


