<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">C ++/C</h6>
            <a class="dropdown-item" href="../cc/cc_001.html">C++ 의 시작</a>
            <a class="dropdown-item" href="../cc/c_001.html">C 의 시작</a>
            <a class="dropdown-item" href="../cc/c_002.html">C 의 기본</a>
            <a class="dropdown-item" href="../cc/c_003.html">자료구조</a>
            <a class="dropdown-item" href="../cc/c_004.html">Redis 분석하기</a>
            <a class="dropdown-item" href="../cc/cc_003.html"></a>
            <a class="dropdown-item" href="../cc/cc_004.html"></a>
            <a class="dropdown-item" href="../cc/cc_005.html"></a>
            <a class="dropdown-item" href="../cc/cc_006.html"></a>
            <a class="dropdown-item" href="../cc/cc_007.html"></a>
            <a class="dropdown-item" href="../cc/cc_008.html"></a>          
            <a class="dropdown-item" href="../cc/cc_009.html"></a>
            <a class="dropdown-item" href="../cc/cc_010.html"></a>
            <a class="dropdown-item" href="../cc/cc_011.html"></a>
            <a class="dropdown-item" href="../cc/cc_012.html"></a>
            <a class="dropdown-item" href="../cc/cc_013.html"></a>
            <a class="dropdown-item" href="../cc/cc_014.html"></a>
            <a class="dropdown-item" href="../cc/cc_015.html"></a>
            <a class="dropdown-item" href="../cc/cc_016.html"></a>
            <a class="dropdown-item" href="../cc/cc_017.html"></a>
            <a class="dropdown-item" href="../cc/cc_018.html"></a>
            <a class="dropdown-item" href="../cc/cc_019.html"></a>
            <a class="dropdown-item" href="../cc/cc_020.html"></a>
            <a class="dropdown-item" href="../cc/cc_021.html"></a>
            <a class="dropdown-item" href="../cc/cc_022.html"></a>
            <a class="dropdown-item" href="../cc/cc_023.html"></a>
            <a class="dropdown-item" href="../cc/cc_024.html"></a>
            <a class="dropdown-item" href="../cc/cc_025.html"></a>
            <a class="dropdown-item" href="../cc/cc_026.html"></a>
            <a class="dropdown-item" href="../cc/cc_027.html"></a>
            <a class="dropdown-item" href="../cc/cc_028.html"></a>
            <a class="dropdown-item" href="../cc/cc_029.html"></a>
            <a class="dropdown-item" href="../cc/cc_030.html"></a>
            <a class="dropdown-item" href="../cc/cc_031.html"></a>
            <a class="dropdown-item" href="../cc/cc_032.html"></a>
            <a class="dropdown-item" href="../cc/cc_033.html">알아두기</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>

          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
                자료구조 
            </div>
            <div class="card-body">
              <div class="accordion" id="accordionExample">
                  <div class="card">
                    <div class="card">
                      <div class="card-header" id="headingThree">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                            시간 복잡도 함수
                          </button>
                        </h2>
                      </div>
                      <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordionExample">
                        <div class="card-body">
                          알고리즘 분석의 2가지 측면
                          <ul>
                            <li>알고리즘 수행 시간 분석 : 시간 복잡도</li>
                            <li>알고리즘이 사용하는 기억 공간 분석 : 공간 복잡도</li>
                          </ul>
                          <hr>
                          <strong>시간 복잡도</strong><br>
                          동일한 조건에서, 똑같은 일을 하는데 알고리즘 A가 30개의 연산을 수행하였고, 알고리즘 B가 300개의 연산을 수행하였다면, 
                          알고리즘 B가 알고리즘 A보다 수행하는 연산의 수가 더 많다. 따라서 알고리즘 A가 효율적인 알고리즘이라고 할 수 있는데, 이것이 시간 복잡도의 기본 개념이다.  
                          <br>
                          연산들의 수행 횟수는 프로그램에서 주어지는 입력의 개수 n에 따라 변하게 된다. 따라서 일반적으로 연산의 수행횟수는 고정된 숫자가 아니라 n에 대한 함수가 된다. 
                          연산의 수를 입력의 개수 n의 함수로 나타낸 것을 시간 복잡도 함수라고 하고 T(n)으로 표기한다. 
                          <hr>
                          <div class="card-group">
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 A</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
sum &lt;- n * n;
                                    </code>
                                  </pre>
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 1회, 나눗셈 연산 1회 => 총 2회 
                              </div>
                            </div>
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 B</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
for i &lt;- 1 to n do  
  sum &lt;- sum + n;
                                    </code>
                                  </pre>
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 n회, 덧셈 연산 n회 => 총 2n회 
                              </div>
                            </div>
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 C</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
for i &lt;- 1 to n do 
  for j &lt;- 1 to n do 
    sum &lt;- sum + 1;                                      
                                    </code>
                                  </pre>                                  
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 n*n, 덧셈 연산 n*n => 2n^2 회 
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>  
                    <div class="card">
                      <div class="card-header" id="heading7">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse7" aria-expanded="false" aria-controls="collapse7">
                            빅오 표기법 
                          </button>
                        </h2>
                      </div>
                      <div id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#accordionExample">
                        <div class="card-body">
                          일반적으로 입력의 개수 n과 시간 복잡도 함수 T(n)의 관계는 상당히 복잡할 수 있다. 하지만 자료가 많은 경우에는 차수가 가장 큰 항이 가장 영향을 크게 미치고
                          다른 항들은 상대적으로 무시될 수있다. 
                          예를 들어 <br>
                          <pre class="C" >
                            <code>
T(n) = n^3 + n + 1
                            </code>
                          </pre>
                          위의 항에서 n이 10000일 때, n^3의 값이 전체의 값을 주도한다는 것을 알 수 있다. 따라서 시간 복잡도 함수에서 차수가 가장 큰 항만을 고려하면 충분하다. <br>
                          시간 복잡도 함수 에서 중요한 것은 n이 증가하였을 때, 연산의 총횟수가 n에 비례하여 증가하는지, n^2에 비례하여 증가하는지, 아니면 다른 추세를 가지는지가 더 중요하다. <br>
                          정확한 연산의 개수 보다 알고리즘의 일반적인 증가 추세가 더 중요하다. 2n과 4n + 1의 차이는 n이 커지게 되면 미미하다고 할 수 있다. 따라서 시간 복잡도 함수에서 불필요한 정보를 
                          제거하여 알고리즘 분석을 더욱 쉽게 할 목적으로 시간복잡도를 표시하는 방법을 빅오 표기법이라고 한다. 즉 알고리즘이 n에 비례하는 수행 시간을 가진다고 말하는 대신에 알고리즘 A의 
                          시간 복잡도 합수가 O(n)이라고 한다. 
                          <hr>
                          <div class="alert alert-primary" role="alert">
                            빅오표기법 : 정의 
                            <hr>
                            두 개의 함수 f(n)과 g(n)이 주어졌을 때 모든 n > n0에 대해여 |f(n)| &lt;= c|g(n)|을 만족하는 2개의 상수 c와 n0가 존재하면 f(n)=O(g(n)) 이다. 
                          </div>
                          빅오 표기법에서 중요한 것은 알고리즘의 일반적인 증가 추세가 중요하다는 것이다. 
                          <div class="alert alert-primary" role="alert">
                            빅오 표기법 예제 
                            <hr>
                            f(n)=5이면 O(1)이다. <br>
                            f(n)=2n+1이면 O(n)이다. <br>
                            f(n)=3n^2+100이면 O(n^2)이다. <br>
                            f(n)=5*2^n이면 O(n^2)이다. <br>
                            f(n)=5*2^n+10n^2 + 100이면 O(2^n)이다. <br>
                            f(n)=7n-3이면 O(n) <br>
                            8n^2logn + 5n^2 + n = O(n^2logn) <br>
                          </div>
                          기본 연산의 횟수가 다향식으로 표현되었을 경우 다항식의 최고차항만을 남기고 다른 항들과 상수항을 버리는 것이다. <br>
                          최고 차항의 계수도 버리고 단치 최고차항의 차수만을 이용한다. 
                          <hr>
                          <ul>
                            <li>O(1) : 상수형</li>
                            <li>O(logn) : 로그형</li>
                            <li>O(n) : 선형</li>
                            <li>O(nlogn) : 선형 로그형</li>
                            <li>O(n^2) : 2차형 </li>
                            <li>O(n^3) : 3차형</li>
                            <li>O(2^n) : 지수형</li>
                            <li>O(n!) : 팩토리얼형</li>
                          </ul>
                          <hr>
                          또한 위의 순서대로 알고리즘의 수행시간에 걸리는 순서도 같이 확인할 수 있다. 
                          아래로 내려가면 갈수록 걸리는 시간이 커진다. 
                          <hr>
                          <img src="./bigograph.PNG" class="img-fluid" alt="" srcset="">
                          <hr>
                          빅오 표기법 이외의 표기법
                          <hr>
                          <ul>
                            <li>빅오메가 표기법 : 어떤 함수의 하한을 표기하는 방법 </li>
                            <li>빅세타 표기법 : 동일한 함수로 상한과 하한을 만들 수 있는 경우 </li>
                          </ul>
                          표기법 중에 가장 정밀한 것은 빅세타 표기법이다. 
                          <hr>
                          똑같은 알고리즘도 주어지는 입력의 집합에 따라 다른 수행 시간을 보일 수 있다. 즉 특정한 자료 집합이 주어지면 다른 자료 집합보다 더 빨리 수행할 수 있다. 
                          <ul>
                            <li>최악의 경우는 자료집합 중에서 알고리즘의 수행시간이 가장  오래 걸리는 경우이다. </li>
                            <li>최선의 경우는 수행시간이 가장 적은 경우이다. </li>
                            <li>평균적인 경우는 알고리즘의 모든 입력 고려하고 각 입력이 발생하는 확률을 고려하여 평균적인 수행시간이 의미한다. </li>
                          </ul>
                          <hr>
                          우리가 구하려는 데이터의 자료구조에 따라 빅오 표기법의 복잡도가 상이해질 수 있는데, 아래의 코드를 보면 
                          <pre class="C" >
                            <code>
// 최선의 경우는 찾고자 하는 숫자가 배열의 맨 처음에 있는 경우이다. 따라서 빅오 표기법은 O(1)
// 최악의 경우는 찾고자 하는 숫자가 맨 마지막이 있는 경우이다. 따라서 빅오 표기법으로는 O(n)
int seq_search(int list[], int key ){
  int i;
  for ( i = 0; i&lt; n ; i ++){
    if(list[i] == key){
      return i;
    }
  }
}
                            </code>
                          </pre>
                        </div>
                      </div>
                    </div> 
                    
                <div class="card">
                  <div class="card-header" id="heading10">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse10" aria-expanded="false" aria-controls="collapse10">
                        순환 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse10" class="collapse" aria-labelledby="heading10" data-parent="#accordionExample">
                    <div class="card-body">
                      어떤 알고리즘이나  함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법이다. 
                      <hr>
                      <strong>순환의 예</strong>
                      순환은 본질적으로 순환적인 문제나 그러한 자료구조를 다루는 프로그램에 적합하다. 
                      <pre class="C" >
                        <code>
int factorial(int n){
  if( n &lt;= 1) return(1);
  else return (n*factorial(n-1))
}                     

// 위의 코드를 아래의 Factorial 기준대로 정의하는 방법 

/*
  factorial(3) = 3 * factorial(2);
               = 3 * 2 * factorial(1);
               = 3 * 2 * 1
               = 3 * 2
               = 6
*/
                        </code>
                      </pre>
                      <hr>
                      <strong>순환의 동작 원리</strong>
                      <hr>
                      순환을 이해하기 위하여 먼저 함수 호출의 과정을 살펴보면, 프로그래밍 언어에서 하나의 함수가 자기 자신을 다시 호출하는 것은 다름 함수를 호출하는 것과 동일하다. 즉 복귀 주소가 시스템 스택에 저장되고
                      호출되는 함수를 위한 매개변수와 지역 변수를 스택으로부터 할당 받는다. 이러한 함수를 위한 시스템 스택에서의 공간을 활성 레코드라 한다. 이러한 준비가 끝나면 호출된 함수의 시작위치로 점프하여 수행을 시작한다. 
                      만약 호출한 함수가 끝나게 되면 시스템 스택에서 복귀주소를 추출하여 호출한 함수로 되돌아가게 된다. 
                      <hr>
                      <strong>순환 알고리즘의 구조</strong>
                      <pre class="C" >
                        <code>
int factorial( int n )
{
  if ( n &lt;= 1 ) return (1);

  return ( n * factorial(n-1));
}
                        </code>
                      </pre>
                      <hr>
                      <strong>순환 &lt;-> 반복</strong>
                      <hr>
                      반복이란 for나 while 등의 반복구조로 되풀이 하는 방법이다. 반복을 제어하는 변수를 사용하여 일정횟수 동안 반복 시킬수도 있고 어떤 조건이 만족될 때까지 반복시킬 수도 있다. 
                      반복은 간명하고 효율적으로 되풀이를 구현하는 방법이다. 
                      반면에 때로는 반복을 사용하게 되면 지나치게 복잡해지는 문제들도 존재한다. 이런 경우에는 순환이 좋은 해결책이 될 수 있다. 순환은 주어진 문제를 해결하기 위하여 자신을 다시 호출하여 
                      수행하는 방식이다. 순환은 본질적으로 순환적인 문제나 그러한 자료구조를 다루는 프로그램에 적합하다. 
                      <br>
                      문제의 크기가 순환이 진행될수록 작아지는 것에 유의해야 한다. 
                      <br>
                      기본적으로 반복과 순환은 문제 해결 능력이 같으며 많은 경우에 순환 알고리즘을 반복 버전으로 , 반복 알고리즘을 순환 버전으로 바꾸어 쓸 수 있다. 특히 순환 호출이 끝에서 이루어지는 순환을 꼬리 순환이라고 하는데, 
                      이를 반복 알고리즘으로 쉽게 바꾸어 쓸 수 있다. 
                      <hr>
                      <strong>순환의 원리</strong>
                      <hr>
                      분할 정복 : 주어진 문제를 더 작은 동일한 문제들로 분해하여 해결하는 방법을 분할 정복이라 한다. <br>
                      순환은 알고리즘 정의가 순환적으로 되어 있는 경우에 유리한 방법이다. 예를 들어 팩토리얼 함수 계산, 피보나치 수열, 이항계수 계산, 이진 트리 알고리즘, 이진 탐색, 하노이 탑 문제들은 순환 알고리즘을 쓰는 것이 자연스러운 알고리즘이다. 
                      <hr>
                      <strong>순환 알고리즘의 성능</strong><br>
                      순환 알고리즘과 반복 알고리즘의 시간 복잡도는 같지만 순환 호출의 경우 여분의 기억공간이 더 필요하고 또한 함수를 호출하기 위해서는, 함수의 매개변수들을 
                      스택에 저장하는 것과 같은 사전 작업이 상당히 필요하다. 따라서 수행시간도 더 걸린다. 결론적으로 순환 알고리즘은 이해하기 쉽다는 것과 쉽게 프로그램 할 수 있다는 장점이 있는 
                      대신 수행 시간과 기억 공간의 사용에 있어서는 비효율적인 경우가 많다. 
                      <hr>
                      거듭제곱 값 계산 
                      <pre class="C" >
                        <code>
// 반복에 의한 방식                           
double slow_power(double x, int n){
  int i;
  double result = 1.0;

  for( i = 0; i &lt; n; i ++ ){
    return = result * x;
    return (result);
  }
}
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
// 순환에 의한 방식      
// 한번의 호출 할 때마다 문제의 크기는 약 절반으로 줄어든다.                      
power(x , n) : 
  if n == 0 
    then return 1;
  else if n이 짝수 
    then return power(x^2, n/2);
  else if n이 홀수 
    then return x * power(x^2, (n-1)/2);
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
// 순환적인 거듭 제곱 계산 
// 순환을 사용하게 되면 단순하게 작성이 가능하며 가독성이 높아진다. 그러나 똑같은 계산을 몇번씩 반복한다면 아주 단순한 경우라 할지라도 
// 계산 시간이 엄청나게 길어질 수 있다. 
double power(double x, int n ){
  if ( n == 0) return 1;
  else if ( (n%2) == 0) 
    return power(x*X, n/2 )
  else return x * power(x*x, (n-1)/2);
}
                        </code>
                      </pre>
                      <hr>
                      <strong>피보나치 수열</strong> <br>
                      <img src="./pibonacci_sequence.PNG" class="img-thumbnail" alt="" srcset=""> <br>
                      피보나치 수열은 이탈리아 수학자가 발견한 수열로서 한 쌍의 토끼가 번식하는 상황을 수열로 만든 것이다. 
                      <br>
                      <pre class="C" >
                        <code>
// 순환적인 피보나치 수열 계산
int fib(int n){
  if ( n == 0) return 0;
  if ( n == 1) return 1;
  return ( fib(n-1) + fib(n-2));
}
                        </code>
                      </pre>
                      위의 코드는 단순하고 이해하기 쉽지만 굉장히 비효율 적인 코드이다. 
                      fib(6)을 구하기 위해서  fib() 함수가 25번이나 호출되는 것에 유의해야 한다. 근본적인 이유는 중간에 계산되었던 값을 기억하지 않고 
                      다시 계산하기 때문이다. 
                      <br>
                      T(n) = T(n-1) + T(n-2) + C 의 순환적인 수식을 이용하면 시간 복잡도 O(2^n)이 도출된다. 
                      이것은 O(2^n)의 복잡도 패턴이라 할 수 있다. 
                      피보나치 수열을 계산하는데 순환을 사용하는 것이 아닌 반복을 사용하게 되면 제일 좋은 결과를 얻을 수 있었다. 
                      <pre class="C" >
                        <code>
int fib_iter(int n){
  if ( n == 0 ) return 0;
  if ( n == 1 ) return 1;

  int pp = 0;
  int p = 1;
  int result = 0;

  for( int i = 2 ; i &lt; n; i ++){
    result = p + pp;
    pp = p;
    p = result;
  }
  return result 
}
                        </code>
                      </pre>
                      <hr>
                      <strong>하노이 탑</strong>
                      순환의 사용에 가장 적합한 예제가 바로 하노이 탑 문제이다. <br>
                      하노의 탑을 해결하기 위한 알고리즘 <br>
                      <pre class="C" >
                        <code>
// 막대 from에 쌓여있는 n개의 원판을 막대 tmp를 사용하여 막대  to로 옮긴다. 
void hanoi_tower(int n, char from, char tmp, char to ){
  if ( n == 1) {
    from에 있는 한 개의 원판을 to로 옮긴다. 
  } else {
    1. from의 맨 밑의 원판을 제외한 나머지 원판을 tmp로 옮긴다. 
    2. from에 있는 한 개의 원판을 to로 옮긴다. 
    3. tmp의 원판들을 to로 옮긴다. 
  }
}

// 코드 예제
#include &lt;stdio.h>
void hanoi_tower( int n , char from, char tmp, char to ){
  if ( n ==  1) printf("원판 1을 %C에서 %c으로 옮긴다. \n" , from, to );
  else {
    hanoi_tower( n - 1, from, to tmp );
    printf("원판 %d 을 %C에서 %c으로 옮긴다. \n" , from, to );
    hanoi_tower( n - 1, tmp, from, to );
  }
}

int main(void){
  hanoi_tower( 4, 'A' , 'B' , 'C');
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <pre class="C" >
                        <code>
//  순환 호출이 맨끝에서 이루어지는 형태의 순환으로, 꼬리 순환의 경우, 알고리즘은 쉽게 반복적인 형태로 변환이 가능하다.                           
return n*factorial(n - 1);

// 머리 순환(head recursion)의 경우나 방금 살펴본 하노이 탑의 문제 처럼 여러 군데에서 자기 자신을 호출하는 경우는 쉽게 반복적인 코드로 바꿀 수 없다. 
return factorial(n - 1)*n;
                        </code>
                      </pre>

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading11">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse11" aria-expanded="false" aria-controls="collapse11">
                        배열, 구조체, 포인터 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse11" class="collapse" aria-labelledby="heading11" data-parent="#accordionExample">                        
                    <div class="card-body">
                      <strong>배열</strong><br>
                      <pre class="C" >
                        <code>
객체 : &lt; 인덱스, 값 > 쌍의 집합 
연산 : 
  - create(size) ::= size개의 요소를 저장할 수 있는 배열 생성 
  - get(A, i) ::= 배열 A의 i 번째 요소 반환. 
  - set(A, i, v) ::= 배열 A의 i 번째 위치에 값 v 저장. 
                        </code>
                      </pre>
                      컴파일러에서 배열 요소에 대한 메모리 주소 구현 방식 <br>
                      <ul>
                        <li>list[0] : 기본주소=base</li>
                        <li>list[1] : base + 1*sizeof(int)</li>
                        <li>...</li>
                      </ul>
                      우리가 프로그램에서 list[i]라고 적으면 컴파일러는 주소 base + i*sizeof(int)에 있는 값을 가져온다. 
                      <hr>
                      <strong>구조체</strong><br>
                      복잡한 객체에는 다양한 타입의 데이터들이 한데 묶여져서 있다. 배열이 타입이 같은 데이터의 모임이라면 구조체는 타입이 다른 데이터를 묶는 방법이다. <br>
                      <pre class="C" >
                        <code>
struct 구조체이름 {
  항목1;
  항목2;
  ...
}

// 구조체 변수 선언 방식 
struct 구조체이름 구조체변수;
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
#include &lt;stdio.h>

typedef struct studentTag {
  char name[10];
  int age;
  double gpa;
} student; 

int main(void) {
  student a = { "kim", 30, 4.3 };
  student b = { "park", 21, 4.2 };
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>배열의 응용  : 다항식</strong><br>
                      <ul>
                        <li>
                          <strong>첫번째 방법</strong><br>
                          <pre class="C" >
                            <code>
10x^5 + 0 * x^4 + 0 * x^3 + 0 * x^2 + 6 * x + 3 


#define MAX_DEGREE 101 

typedef struct {
  int degree;
  float coef[MAX_DEGREE];
} polynomial 

polynomial a = { 5, { 10, 0 , 0, 0, 6 , 3}}
                            </code>
                          </pre>
                        </li>
                        <li>
                          <strong>두번째 방법</strong><br>
                          <pre class="C" >
                            <code>
#define MAX_TERMS 101

typedef struct {
  float coef;
  int expon;
} terms[MAX_TERMS];
int avail; 

terms[MAX_TERMS] = {{ 8,3 }, { 7,1 } , { 1, 0 } , { 10, 3 } , { 3 , 2 } , { 1 , 0 } }
                            </code>
                          </pre>
                        </li>
                        <li>
                          <strong>희소 행렬</strong><br>
                          <pre class="C" >
                            <code>
// 희소 행렬의 표현 방법 #1
#define MAX_ROWS 100
#define MAX_COLS 100
int matrix[MAX_ROWS][MAX_COLS];


// 희소 행렬의 표현방법 #2
struct matrix {
  int x,
  int y, 
  char value
}

int main(){
  struct matrix m[100] = { { .x = 1 , .y= 1 , .value = 'G' }, ... }
}
                            </code>
                          </pre>
                        
                        </li>
                        <li>
                          <strong>전치 행렬 계산법</strong>
                          <pre class="C" >
                            <code>
#define ROWS 3
#define COLS 3

// 행렬 전치 함수 - 첫번째 방식 
void matrix_transpose(int A[ROWS][COLS], int B[ROWS][COLS]){
  for ( int r = 0 ; r &lt; ROWS ; r ++){
    for ( int c = 0 ; c &lt; COLS ; c ++){
      B[c][r] = A[r][c];
    }
  }
}

// 행렬 전치 함수 - 두번째 방식 
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_TERMS 100
typedef struct {
  int row;
  int col;
  int value;
}

typedef struct SparseMatrix {
  element data[MAX_TERMS];
  int rows;
  int cols;
  int terms;
} SparseMatrix;

SparseMatrix matrix_transpose2(SparseMatrix a){
  SparseMatrix b;

  int bindex;
  b.rows = a.rows;
  b.cols = a.cols;
  b.terms = a.terms;

  if(a.terms > 0){
    bindex = 0;
    for ( int c = 0 ; c &lt; a.cols ; r ++){
      for ( int i = 0 ; i &lt; a.terms ; i ++){
        if(a.data[i].col == c){
          b.data[bindex].row = a.data[i].col;
          b.data[bindex].col = a.data[i].row;
          b.data[bindex].value = a.data[i].value;
        }
      }
    }
  }
  return b;
}
                            </code>
                          </pre>
                        </li>
                      </ul>
                      <strong>Pointer</strong><br>
                      포인터는 다른 변수의 주소를 가지고 있는 변수이다. 모든 변수는 메모리 공간에 저장되고 메모리의 각 바이트에는 주소가 매겨져 있다. 
                      이 주소가 포인터에 저장된다. 주소는 컴퓨터에 따라 다를 수 있으므로 포인터 변수는 정확한 숫자보다는 그냥 화살표로 그려진다. 
                      <ul>
                        <li>널 포인터</li>
                        <li></li>
                      </ul>
                      배열과 포인터의 관계 : 배열의 이름은 배열의 시작부분을 가리키는 포인터이다. <br>
                      배열의 이름이 점선으로 그려져 있는 이유는 실제로 컴파일러가 배열의 이름에 공간을 할당하지는 않기 때문이다. 대신에 배열의 이름이 있는 곳을 배열의 첫번째 요소의 
                      주소로 대치한다. 따라서 배열의 이름이 포인터이기 때문에 배열이 함수의 매개변수로 전달 될 때 사실을 포인터가 전달되는 것이다. 
                      <hr>
                      <strong>동적 메모리 할당</strong>
                      <pre class="C" >
                        <code>
int *p;
// malloc() 함수가 반환했던 포인터 값을 잊어버리면 안된다는 것이다. 포인터 값을 잊어버리면 동적 메모리를 반환할 수 없다. 
// malloc()은 시스템의 메모리가 부족해서 요구된 메머리를 할당할 수 없으면 NULL을 반환한다. 
p = ( int * )malloc(sizeof(int));
*p = 1000;
free(p);                          
                        </code>
                      </pre>
                      동적 메모리가 할당되는 공간을 히프라고 한다. 히프는 운영체제가 사용되지 않는 메모리 공간을 모아 놓은 곳이다. 필요한 만큼 할당을 받고 또 필요한 대에 사용하고 반납하기 때문에 
                      메모리를 매우 효율적으로 사용할 수 있다. 
                      <hr>
                      <strong>구조체와 포인터</strong><br>
                      우리는 구조체에 포인터를 선언하고 포인터를 통하여 구조체 멤버에 접근할 수 있다. 여기에서 하나 주의할 것은 포인터를 통하여 구조체의 멤버에 접근하는 편리한 표기법 "->"이다. <br>
                      <pre class="C" >
                        <code>
// (*ps).i 보다 ps -> i 라고 쓰는 것이 더 편리하다. 

typedef struct studentTag {
  char name[10];
  int age;
  double gpa;
} student;

int main(void) {
  student s*;

  s = (student *)malloc(sizof(student));
  if ( s == NULL ){
    fprintf(stderr, "메모리가 부족해서 할당할 수 없습니다. \n");
    exit(1);
  } 

  strcpy(s -> name,  "Park");
  s -> age = 20;

  free(s);
  return 0;
}

                        </code>
                      </pre>

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading13">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse13" aria-expanded="false" aria-controls="collapse13">
                        스택   
                      </button>
                    </h2>
                  </div>
                  <div id="collapse13" class="collapse" aria-labelledby="heading13" data-parent="#accordionExample">
                    <div class="card-body">
                      스택에서의 입출력은 맨 위에서만 일어나고 스택의 중간에서는 데이터를 삭제할 수 없다. 
                      스택에서 입출력이 이루어지는 부분을 스택 상단이라고 하고 반대쪽인 바닥부분을 스택 하단이라고 한다. 스택에 저장되는 것을 요소라 부른다. 
                      <hr>
                      후입 선출 ( LIFO : Last In First Out )
                      <hr>
                      함수는 실행이 끝나면 자신을 호출한 함수로 되돌아가야한다. 이때 스택이 사용되는데, 즉 복귀할 주소를 기억하는데 사용된다. 
                      <hr>
                      추상 자료형 스택 
                      <pre class="C" >
                        <code>
- 객체 : 0개 이상의 원소를 가지는 유한 선형 리스트 
- 연산 : 
  create(size)  ::= 최대크키가 size인 공백 스택을 생성한다. 
  is_full(s) ::= 
    if(스택의 원소수 == false) return TRUE;
    else return FALSE;
  is_empty(s)   ::= 
    if(스택의 원소수 == 0) return TRUE;
    else return FALSE;
  push(s, item) ::=
    if( is_full(s) ) retirm ERROR_STACKFULL;
    else 스택의 맨 위에 item을 추가한다. 
  pop(s) ::=
    if ( is_empty(s) ) return ERROR_STACKEMPTY;
    else 스택의 맨 위의 원소를 제거해서 반환한다.
  peeck(s) ::=
    if( is_empty(s) ) return ERROR_STACKEMPTY;
    else 스택의 맨 위의 원소를 제거하지 않고 반환한다.                          

                        </code>
                      </pre>
                      Stack은 기본적으로 Push와 Pop의 두가지 연산으로 이루어져있고, 실제 Stack에서 허용하는 Item 갯수가 가득찼는지 pop을 했을 때 더 빼낼 아이템이 없는지를
                      체크하기 위한 Validation이 존재한다. 
                      <hr>
                      <strong>스택의 구현</strong><br>
                      <pre class="C" >
                        <code>
is_empty(S):
  if top == -1
    then return TRUE
    then return FALSE 

is_full(S):
  if top >= ( MAX_STACK_SIZE )
    then return TRUE 
    then return FALSE 

// push에서는 먼저 top의 값을 증가하는 것에 유의하라. top이 가리키는 위치는 마지막으로 삽입되었던 요소이므로 top을 증가시키지 않고 삽입하면 마지막 요소가 지워지게 된다. 
push(S,x):
  if is_full(S)
    then error "overflow"
    else top &lt;- top + 1
         stack[top] &lt;- x

// pop 연산은 스택에서 하나의 요소를 제거하는 여산으로 top이 가리키는 요소를 스택에서 꺼내어 외부로 건네주는 연산이다. 
// 먼저 요소를 제거하기 전에 스택이 비어있는지 검사행한다. 
pop(S, x) :
  if is_empty(S)
    then error "underflow"
    else e &lt;- stack[top]
        top &lt;- top-1
        return e
                        </code>
                      </pre>
                      <hr>
                      <strong>전역변수를 이용하여 구현하는 방법</strong>  
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

// 스택이 전역 변수로 구현된다. 
#define MAX_STACK_SIZE 100
typedef int element;
element stack[MAX_STACK_SIZE];
int top = -1;

// 공백 상태 검출 함수 
int is_empty()
{
  return ( top == -1 );
}

// 포화 상태 검출 함수 
int is_full()
{
  return ( top == ( MAX_STACK_SIZE - 1));
}

// 삽입 함수 
void push(element item){
  if(is_full()){
    fprintf(stderr, "스택 포화 에러\n");
    return;
  }
  else stack[++top] = item;
}

// 삭제 함수 
element pop(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return stack[top--];
}

// 피크함수 
element peek(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return statck[top];
}

int main(void){
  push(1);
  push(2);
  push(3);
  printf("%d\n", pop());
  printf("%d\n", pop());
  printf("%d\n", pop());
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택의 요소를 구조체로 하기 </strong><br>
                      <pre class="C" >
                        <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_STACK_SIZE 100
#defind MAX_STRINC 100

typedef stuct {
  int student_no;
  char name[MAX_STRING];
  char address[MAX_STRING];
} element;

element stack[MAX_STACK_SIZE];
int top = -1;

// 공백 상태 검출 
int is_empty(){
  return ( top == -1);
}

// 포화 상태 검출 함수 
int is_full(){
  return ( top == (MAX_STACK_SIZE - 1));
}

// 삽입 함수 
void push(element itme){
  if(is_full()){
    fprintf(stderr, "스택 포화 에러\n");
    exit(1);
  }
  else stack[++top] = item;
}

// 삭제 함수 
element pop(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러 \n");
    exit(1);
  }
  else return stack[top--];
}

// 피크 함수 
element peek(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return stack[top];
}

int main(void){
  element ie = {
    20190001,
    "Hong",
    "Seoul"
  };

  element oe;

  push(ie);
  oe = pop();

  printf("학번 : %d\n", oe.student_no);
  printf("이름 : %d\n", oe.name);
  printf("주소 : %d\n", oe.address);

  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>함수의 매개변수로 전달하는 방법</strong>
                      <hr>
                      <pre>
                        <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

// 차후에 스택이 필요하면 여기만 복사하여 붙인다. 
// ===== 스택 코드의 시작 =====
#define MAX_STACK_SIZE 100

typedef int element;
typedef struct {
  element data[MAX_STACK_SIZE];
  int top;
} StackType;


// 스택 초기화 함수 
void init_stack(StackType *s){
  return ( s -> top == -1);
}

// 공백상태 검출 함수
int is_empty(StackType *s){
  return ( s -> top == -1);
}

// 포화 상태 검출 함수 
int is_full(StackType *s){
  return ( s -> top == ( MAX_STACK_SIZE - 1));
}

// 삽입함수 
void push(StackType *s, element item){
  if(is_full(s)){
    fprinf(stderr, "스택 포화 에러\n");
    return;
  }
  else{
    s -> data[++(s-> top)] = item;
  }
}

// 삭제함수 
element pop(StackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return s->data[(s->top)X-UA-Compatible]
}

// 피크함수 
element peek(StackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return s ->data[s->top];
}
// ===== 스택 코드의 끝 =====

// C언어에서의 함수 매개변수 전달 방식이 기본적으로 Call By Value이기 때문에, 구조체를 함수의 매개변수로 전달하는 경우, 구조체의 원본이 전달되는 것이 아니라 구조체의 복사본이 전달된다. 
// 따라서 함수 안에서는 복사본을 수정하여도 원본에는 영향을 주지 못한다. 그러나 원본에 대한 포인터를 전달하면 원본을 변경할 수 있다. 

int main(void){
  StackType s;

  init_stack(&s);
  push(&s, 1);
  push(&s, 2);
  push(&s, 3);
  printf("%d\n", pop(&s));
  printf("%d\n", pop(&s));
  printf("%d\n", pop(&s));
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택을 동적할 메모리 할당으로 생성</strong>
                      <pre class="C" >
                        <code>
int main(void){
  StackType *s;
  s = (StackType *)malloc(sizeof(StackType));
  init_stack(s);
  push(s, 1);
  push(s, 2);
  push(s, 3);
  printf("%d\n", pop(s));
  printf("%d\n", pop(s));
  printf("%d\n", pop(s));
  free(s);
}
                        </code>
                      </pre>
                      <hr>
                      <strong>동적배열스택</strong>
                      <hr>
                      <pre class="C" >
                        <code>
typedef int element;
typedef struct {
  element *data;
  int capacity;
  int top;
} StackType;

// 스택 생성 함수 
void int_stack(StackType *s){
  s -> top = -1;
  s -> capacity = 1;
  s -> data = (element *)malloc(s -> capacity*sizeof(element));
}

// 스택 삭제 함수 
void delete(StackType *s){
  free(s);
}

void push(StackType *s, element item){
  if(is_full(s)){
    s -> capacity *= 2;
    s -> data = (element *)realloc(s->data, s->capacity * sizeof(element));
  }
  s -> data[++(s->top)] = item;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>동적 배열 스택 프로그램</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_STACK_SIZE 100

typedef int element;
typedef struct {
  element *data;
  int capacity;
  int top;
} StackType;

// 스택 생성 함수 
void init_stack(StackType *s){
  s -> top = -1;
  s -> capacity = 1;
  s -> data = (element *)malloc(s -> capacity * sizeof(element));
}

// 공백 상태 검출 함수 
int is_empty(StackType *s){
  return ( s -> top == -1 );
}

// 포화상태 검출 함수 
int is_full(StackType *s)
{
  return ( s -> top == (MAX_STACK_SIZE -1 ));
}

void push(StackType *s, element item){
  if(is_full(s)){
    s -> capacity *= 2;
    s -> data = ( element *)realloc(s -> data, s -> capacity * sizeof(element));
  }
  s -> data[++(s->top)] = item;
}

// 삭제 함수 
element pop(StackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return s -> data[(s->top)--];
}

int main(void){
  StackType s;
  init_stack(&s);
  push(&s, 1);
  push(&s, 2);
  push(&s, 3);
  printf("%d \n", pop(&s));
  printf("%d \n", pop(&s));
  printf("%d \n", pop(&s));
  free(s.data);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택의 활용 : 괄호 검사 문제 </strong>
                      <hr>
                      <ul>
                        <li>왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.</li>
                        <li>같은 종류의 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.</li>
                        <li>서로 다른 종류의 왼쪽 괄호와 오른쪽 괄호 쌍은 서로를 교차하면 안된다.</li>
                      </ul>
                      <pre>
                        <code class="C" >
check_matching(expr);

while(입력 expr의 끝이 아니면)
ch &lt;- expr의 다음 글자 
switch(ch)
    case '(' : case '[' : case '{' :
        ch를 스택에 삽입 
        break
    case ')' : case ']' : case '}' :
        if ( 스택이 비어 있으면 )
            then 오류 
            else 스택에서 open_ch 를 꺼낸다
                if ( ch와 open_ch가 같은 짝이 아니면 )
                    then 오류 보고 
    break
if( 스택이 비어 있지 않으면 )
    then 오류                                           
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#define MAX_STACK_SIZE 100

typedef char element;
element stack[MAX_STACK_SIZE];

int check_matching(const char *in){
  StackType s;
  char ch, open_ch;
  int i, n = strlen(in);
  init_stack(&s);

  for ( i = 0; i &lt; n ; i ++){
    ch = in[i];
    switch(ch){
      case '(' : case '[' : case '{' :
        push(&s, ch);
        break;
      case ')' : case ']' : case '}' :
        if(is_empty(&s)) return 0;
        else {
          open_ch = pop(&s);
          if((open_ch == '(' && ch != ')' ) ||
            (open_ch == '[' && ch != ']' ) ||
            (open_ch == '{' && ch != '}' ) 
          ){
            return 0;
          }
          break;
        }  
    }
  }
  if(!is_empty(&s)) return 0;
  return 1;
}

int main(void){
  char *p = "{ A[(i+1)]=0; }";
  if(check_matching(p) == 1)
    printf("%s 괄호검사성공\n", p);
  else 
    printf("%s 괄호검사실패\n", p);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택의 응용 : 후위 표기 수식의 계산</strong>
                      <hr>
                            
                      <pre>
                        <code class="C" >
calc_posfix:
    스택 s를 생성하고 초기화한다. 
    for item in 후위표기식 do 
        if ( item이 피연산자이면 )
            push(s, item)
        else if ( item이 연산자 op이면 )
            second &lt;- pop(s)
            first &lt;- pop(s)
            result &lt;- first op second // op 는 +-*/ 중의 하나 
            push(s, result)
        final_result &lt;- pop(s);                                  
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_STACK_SIZE 100

typedef char element;

int eval(char exp[]){
  int op1, op2, value , i = 0;
  int len = strlen(exp);
  char ch;
  StackType s;

  init_stack(&s);
  for( i = 0; i &lt; len ; i ++){
    ch = exp[i];
    if( ch != '+' && ch != '-' && ch != '*' && ch != '/' ){
      value = ch - '0';
      push(&s, value);
    }else {
      op2 = pop(&s);
      op1 = pop(&s);
      switch ( ch ) {
        case '+' : push(&s, op1 + op2); break;
        case '-' : push(&s, op1 - op2); break;
        case '*' : push(&s, op1 * op2); break;
        case '/' : push(&s, op1 / op2); break;
      }
    }
  }
  return pop(&s);
}

int main(void){
  int result;
  printf("후위표기식은 82/3-32*+\n");
  result = eval("82/3 - 32 *+");
  printf("결과값은 %d\n", )
}
                        </code>
                      </pre>
                      <hr>
                      <strong>중위 표기 수식을 후위 표기 수식으로 전환</strong>
                      <hr>
                      <pre>
                        <code class="c">
infix_to_postfix(exp);

스택 s를 생성하고 초기화 
while ( exp에 처리할 문자가 남아 있으면 )
    ch &lt;- 다음에 처리할 문자 
    switch ( ch )
    case 연산자 : 
        while ( peek(s)의 우선순위 >= ch의 우선순위 ) do 
            e &lt;- pop(s)
            e를 출력 
        push(s, ch);
        break;
    case 왼쪽 괄호 : 
        push(s, ch);
        break;
    case 오른쪽 괄호 : 
        e &lt;- pop(s);
        while( e != 왼쪽괄호 ) do 
            e를 출력 
            e &lt;- pop(s);
        break;
    case 피연산자 : 
        ch를 출력
        break;

while( not is_empty(s) ) do 
    e &lt;- pop(s)
    e를 출력 
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_STACK_SIZE 100

typedef char element;

int prec(char op)
{
  switch(op) {
    case '(' : case ')' : return 0;
    case '+' : case '-' : return 1;
    case '*' : case '/' : return 2;
  }
  return -1;
}

void infix_to_postfix(char exp[]){
  int i = 0;
  char ch, top_op;
  int len = strlen(exp);
  StackType s;

  init_stack(&s);
  for ( i = 0; i &lt; len; i ++){
    ch = exp[i];
    switch(ch) {
      case '+' : case '-' : case '*' : case '/' : 
        while ( !is_empty(&s) && (prec(ch) &lt;= prec(&s)))
          prinf("%sc", pop(&s));
        push(&s, ch);
        break;
      case '(' :
        push(&s, ch);
        break;
      case ')' :
        top_op = pop(&s);
        while ( top_op != '('){
          printf("%c", top_op);
          top_op = pop(&s);
        }
        break;
      default:
        printf("%c", pop(&s));
        break;
    }
  }
  while( !is_empty(&s))
    printf("%c", pop(&s));
}

init main(void){
  char *s = "(2+3)*4+9";
  printf("중위 표시 수식  %s \n", s);
  printf("후위 표시 수식 ");
  infix_to_postfix(s);
  printf("\n");
}
                        </code>
                      </pre>
                      <hr>
                      <strong>미로 탐색 프로그램</strong>
                      <hr>
                      <pre>
                        <code class="C" >
maze_search();

스택 s과 출구의 위치 x, 현재 생쥐의 위치를 초기화 
while( 현재의 위치가 출구가 아니면 ) do 
    현재 위치를 방문한 것으로 표기 
    if( 현재위치의 위, 아래, 왼쪽, 오른쪽 위치가 아직 방문되지 않았고 갈 수 있으면 )
        then 그 위치들을 스택에 push 
    if( is_empty(s) )
        then 실패 
    else 스택에서 하나의 위치를 꺼내어 현재 위치로 만든다. 
성공;                           
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#define MAX_SIZE 6

typedef struct {
  short r;
  short c;
} element;

element here = { 1, 0}, entry = { 1, 0 };

void push_loc(StackType *s, int r, int c){
  if( r &lt; 0 || c &lt; 0) return;
  if( maze[r][c] != '1' && maze[r][c] != '.' ) {
    element tmp;
    tmp.r = r;
    tmp.c = c;
    push(s, tmp);
  }
}

void maze_print(char maz[MAZE_SIZE][MAZE_SIZE]){
  print("\n");
  for( int r = 0; r &lt; MAZE_SIZE; r++){
    for( int c = 0; c &lt; MAZE_SIZE; c++){
      print("%c", maze[r][c]);
    }
    printf("\n");
  }
}

int main(void){
  int r,c;
  StackType s;

  init_stack(&s);
  here = entry;
  while ( maze[here.r][here.c] != 'x'){
    r = here.r;
    c = here.c;
    maze[r][c] = '.';
    maze_print(maze);
    push_loc(&s. r - 1, c);
    push_loc(&s. r + 1, c);
    push_loc(&s. r , c - 1);
    push_loc(&s. r , c + 1);
    if(is_empty(&s)){
      printf("실패\n");
      return;
    }
    else 
      here = pop(&s);
  }
  printf("성공\n");
  return 0;
}
                        </code>
                      </pre>
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading14">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse14" aria-expanded="false" aria-controls="collapse14">
                        큐
                      </button>
                    </h2>
                  </div>
                  <div id="collapse14" class="collapse" aria-labelledby="heading14" data-parent="#accordionExample">
                    <div class="card-body">
                      스택의 경우, 나중에 들어온 데이터가 먼저 나가는 구조인데 반하여 큐는 먼저 들어온 데이터가 먼저 나가는 구조로 이러한 특성을 선입선출(First In First Out)이라고 한다. 
                      <hr>
                      <strong>ADT : 큐</strong>
                      <hr>
                      <pre>
                        <code class="C" >
객체 : 0개 이상의 요소들로 구성된 선형 리스트 

연산 : 
    create(max_size) ::=
        최대 크기가 max_size 인 공백큐를 생성한다. 
    is_empty(q) ::= 
        if(size == max_size) return TRUE;
        else return FALSE;
    is_full(q) ::=
        if(size == max_size ) return TRUE;
        else return FALSE;
    enqueue(q, e) ::=
        if( is_full(q) ) queue_full 오류;
        else q의 끝에 e를 추가한다. 
    dequeue(q) ::=
        if( is_empty(q) ) queue_empty 오류:
        else q의 맨 앞에 있는 e를 제거하여 반환한다. 
    peek(q) ::=
        if( is_empty(q) ) queue_empty 오류;
        else q의 맨 앞에 있는 e를 읽어서 반환한다.                       

                        </code>
                      </pre>
                      <hr>
                      많이 이용되는 분야는 컴퓨터를 이용하여 현실 세계의 실제 상황을 시뮬레이션 하는 것이다, 예를 들면 은행에서 기다리는 사람들의 대기열, 공항에서 이륙하는 비행기들, 인터넷에서 전송되는 데이터 패킷들을 모델링하는 데 큐가 이용된다. 
                      큐는 운영체제에서도 중요하게 사용된다. 예를 들면 운영체제에는 인쇄 작업큐가 존재한다. 프린터는 속도가 늦고 상대적으로 컴퓨터의 CPU는 속도가 빠르기 때문에 CPU는 빠른 속도로 인쇄 데이터를 만든 다음, 인쇄 작업 큐에 저장하고
                      다른 작업으로 넘어간다. 
                      <hr>
                      <strong>선형 큐</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_QUEUE_SIZE 5

typedef int element;
typedef struct {
  int front;
  int rear;
  element data[MAX_QUEUE_SIZE];
} QueueType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

void init_queue(QueueType *q){
  q -> rear = -1;
  q -> front = -1;
}

void queue_print(QueueType *q){
  for ( int i = 0; i &lt; MAX_QUEUE_SIZE; i ++ ) {
    if ( i &lt;= q -> front || i > q -> rear ){
      printf(" | ");
    }else{
      printf("%d | ", q -> data[i]);
    }
  }
  printf("\n");
}

int is_full(QueueType *q){
  if( q -> rear == MAX_QUEUE_SIZE - 1 )
    return 1;
  else 
    return 0;
}

int is_empty(QueueType *q){
  if( q -> front ==  q -> rear )
    return 1;
  else 
    return 0;
}

void enqueue(QueueType *q, int item){
  if(is_full(q)) {
    error("큐가 포화상태입니다. ")
    return;
  }
  q -> data[++(q->rear)] = item;
}

int dequeue(QueueType *q){
  if(is_empty(q)){
    error("큐가 공백상태입니다. ");
    return 1;
  }
  int item = q -> data[++(q->front)];
  return item;
}

int main(void){
  int item = 0;
  QueueType q;

  init_queue(&q);

  enqueue(&q, 10); queue_print(&q);
  enqueue(&q, 20); queue_print(&q);
  enqueue(&q, 30); queue_print(&q);

  item = dequeue(&q); queue_print(&q);
  item = dequeue(&q); queue_print(&q);
  item = dequeue(&q); queue_print(&q);
  return 0;
}


                        </code>
                      </pre>
                      <hr>
                      <strong>원형큐</strong>
                      <hr>
                      <pre>
                        <code class="C" >
* 원형큐에서의 삽입 알고리즘 
enqueue(Q, x):
    rear &lt;- ( rear + 1) % MAX_QUEUE_SIZE;
    Q[rear] &lt;- x;                          

* 원형큐에서의 삭제 알고리즘
    front &lt;- ( front + 1) % MAX_QUEUE_SIZE;
    return Q[front];                          
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_QUEUE_SIZE 5
typedef int element;
typedef struct {
  element data[MAX_QUEUE_SIZE];
  int front;
} QueueType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

void init_queue(QueueType *q)
{
  q -> front = q -> rear = 0;
}

int is_empty(QueueType *q)
{
  return ( q -> front == q -> rear);
}

int is_full(QueueType *q){
  return ((q -> rear + 1)% MAX_QUEUE_SIZE == q -> front);
}

void queue_print(QueueType *q){
  printf("QUEUE(front=%d rear=%d) = " , q -> front, q -> rear );
  if(!is_empty(q)) {
    int i = q -> front;
    do {
      i = ( i + 1) % ( MAX_QUEUE_SIZE );
      printf("%d | " , q -> data[i]);
      if( i == q -> rear ){
        break;
      }
    } while ( i != q -> front );
  }

  printf("\n");
}

void enqueue(QueueType *q, element item){
  if(is_full(q))
    error("큐가 포화상태입니다. ");
  q -> rear = ( q -> rear + 1) % MAX_QUEUE_SIZE;
  q -> data[q->rear] = item;
}

element dequeue(QueueType *q){
  if(is_empty(q)){
    error("큐가 공백상태입니다.");
  }
  q -> front = ( q -> front + 1) % MAX_QUEUE_SIZE;
}

element peek(QueueType *q){
  if(is_empty(q))
    error("큐가 공백상태입니다.");
  return q -> data[(q->front+1 ) % MAX_QUEUE_SIZE;
}

int main(void){
  QueueType queue;
  int element;

  init_queue(&queue);
  printf("--데이터 추가 단계--\n");
  while(!is_full(&queue)){
    printf("정수를 입력하시오 : ");
    scanf(%d, &element);
    enqueue(&queue, element);
    queue_print(&queue);
  }
  printf("큐는 포화상태입니다. \n\n");

  printf("--데이터 삭제 단계--\n");
  while(!is_empty(&queue)){
    element = dequeue(&queue);
    printf("꺼내진 정수 : %d \n", element);
    queue_print(&queue);
  }
  printf("큐는 공백상태입니다. \n");
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>Queue의 버퍼</strong>
                      <hr>
                      <p>
                        버퍼란? <br>
                        버퍼란 임시 저장 공간을 의미합니다. 임시 저장 공간이라고 해서 생뚱맞게 보일 수 있지만 정확히 말하면 A와 B가 서로 입출력을 수행하는 데에 있어서 속도차이를 극복하기 위해 사용하는 임시 저장 공간을 의미합니다. <br>
                        프로그래밍에서의 버퍼는 거의 대부분 CPU와 보조 기억 장치 사이에서 사용되는 임시저장 공간을 의미합니다. 버퍼라는 것은 속도차가 큰 대상이 입출력을 수행할 때 효율성을 위해 사용하는 임시 저장공간이라고 할 수 있겠습니다. 
                      </p>
                      <pre>
                        <code class="C" >
큐를 버퍼처럼 사용할 수 잇는데, 

#include &lt;stdio.h>
#include &lt'stdlib.h>

int main(void){
  QueueType queue;
  int element;

  init_queue(&queue);
  srand(time(NULL));

  for(int i = 0; i &lt; 100; i++ ){
    if(rand() % 5 == 0){
      enqueue(&queue , rand()%100);
    }
    queue_print(&queue);
    if(rand() % 10 == 0){
      int data = dequeue(&queue);
    }
    queue_print(&queue);
  }
  return 0;
}
                        </code>
                      </pre>
                      <p>
                        랜덤한 수(난수)를 생성하는 함수 <br>
                        <ul>
                          <li>
                            int rand(void)
                            <br>
                            랜덤한 숫자를 반환합니다. 
                            그 범위는 0 ~ RAND_MAX 까지 인데요. RAND_MAX 라는 것은 stdlib.h 헤더파일에 매크로로 작성되어 있습니다. <br>
                            RAND_MAX = 32767 <br>
                          </li>
                          <li>
                            void srand(unsigned int seed) <br>
                            rand 함수에 사용될 수를 초기화 한다. 이 초기화를 매개변수로 받는 seed값을 이용해서 합니다. <br>
                          </li>
                          <li>
                            time_t time(time_t* timer); <br>
                            UCT 기준 1970년 1월 1일 0시 0분 0초 부터 경과된 시간을 초(sec)로 반환하는 함수 
                          </li>
                        </ul>
                      </p>
                      <p>
                        매크로(#define) <br>
                        매크로란 어떤 것을 대신하여 사용하는 이름을 말한다. 즉, 어떤 특정한 값이나 처리 명령어를 하나의 이름을 부여하고 그 특정한 값이나 처리 명령어를 사용할 때 부여한 이름을 사용하여 대신 코딩하는 것을 말합니다. 
                        <pre>
                          <code class="C" >
#include &lt;stdio.h>

#define MAIN main(int argc, char *argv[])
#define BEGIN {
#define END } 
#define OUTPUT printf

MAIN
BEGIN
OUTPUT("Hello World! \n");
END
                          </code>
                        </pre>
                      </p>
                      <hr>
                      <Strong>덱(double-ended queue)</Strong> <br>
                      덱은 double-ended queue이 줄임말로서 큐의 전달과 후단에서 모두 삽입과 삭제가 가능한 큐를 의미한다. 그렇지만 여전히 중간에 삽입하거나 삭제하는 것은 허용하지 않는다. 
                      <hr>
                      <pre>
                        <code class="C" >
객체 : n개의 element형의 요소들의 순서 있는 모임 
연산 :
    create() ::= 덱을 생성한다. 
    init(dq) ::= 덱을 초기화한다. 
    is_empty(dq) ::= 덱이 공백상태인지를 검사한다. 
    is_full(dq) ::= 덱이 포화 상태 인지를 검사한다. 
    add_front(dq, e) ::= 덱의 앞에 요소를 추가한다. 
    add_rear(dq, e) ::= 덱의 뒤에 요소를 추가한다. 
    delete_front(dq) ::= 덱의 앞에 있는 요소를 반환한 다음 삭제한다. 
    delete_rear(dq) ::= 덱의 뒤에 있는 요소를 반환한 다음 삭제한다. 
    get_front(q) ::= 덱의 앞에서 삭제하지 않고 앞에 있는 요소를 반환한다.
    get_rear(q) ::= 덱의 뒤에서 삭제하지 않고 뒤에 있는 요소를 반환한다. 
                        </code>
                      </pre>
                      <hr>
                      배열을 이용한 덱의 구현 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_QUEUE_SIZE 5
typedef int element;
type struct {
  element data[MAX_QUEUE_SIZE];
  int fornt, rear;
} DequeType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

void init_deque(DequeType *q){
  q -> front = q -> rear = 0;
}

void is_empty(DequeType *q){
  return ( q -> front == q -> rear );
}

int is_full(DequeType *q){
  return ((q->rear + 1) % MAX_QUEUE_SIZE == q -> front );
}

void deque_print(DequeType *q){
  printf("DEQUE(fornt=%d rear=%d) = ", q -> front, q -> rear );
  if(!is_empty(q)){
    int i = q -> front;
    do {
      i = ( i + 1 ) % ( MAX_QUEUE_SIZE );
      printf("%d | ", q -> data[i]);
      if ( i == q -> rear )
        break;
    } while ( i != q -> front );
  }
  printf("\n");
}

void add_rear(DequeType *q, element item){
  if(is_full(q))
    error("큐가 포화상태입니다.");
  q -> rear = ( q -> rear + 1 ) % MAX_QUEUE_SIZE;
  q -> data[q -> rear ] = item;
}

element delete_front(DequeType *q){
  if(is_empty(q))
    error("큐가 공백상태입니다.");
  q -> front ( q -> front + 1) % MAX_QUEUE_SIZE;
  return q -> data[q->front];
}

element get_front(DequeType *q){
  if(is_empty(q))
    error("큐가 공백상태입니다.");
  return q -> data[( q -> front + 1) % MAX_QUEUE_SIZE];
}

void add_front(DequeType *q, element val){
  if ( is_full(q) )
    error("큐가 포화상태입니다.");
  q -> data[q -> front] = val;
  q -> front = ( q -> front - 1 + MAX_QUEUE_SIZE) % MAX_QUEUE_SIZE;
}

element delete_rear(DequeType *q){
  int prev = q -> rear;
  if(is_empty(q))
    error("큐가 공백상태입니다.");
  q -> rear = ( q -> rear - 1 + MAX_QUEUE_SIZE) % MAX_QUEUE_SIZE;
  return q -> data[prev];
}

element get_rear(DequeType *q){
  if(is_empty(q))
    error("큐기 공백 상태입니다. ");
  return q -> data[q -> rear];
}

int main(void){
  DequeType queue;

  init_deque(&queue);
  for ( int i = 0; i &lt; 3 ; i ++ ){
    add_front(&queue, i);
    deque_print(&queue);
  }
  for ( int 1 = 0; i &lt; 3 ; i ++ ){
    delete_rear(&queue);
    delete_print(&queue);
  }
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      큐는 주로 컴퓨터로 큐잉이론에 따라 시스템의 특성을 시물레이션하여 분석하는 데 이용한다. 큐잉 모델은 고객에 대한 서비스를 수행하는 서버와 서비스를 받는 고객들로 이루어진다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef struct {
  int id;
  int arrival_time;
  int service_time;
} element;

int main(void){
  int minutes = 60;
  int total_wait = 0;
  int total_customers = 0;
  int service_time = 0;
  int service_customer;
  QueueType queue;
  init_queue(&queue);

  srand(time(NULL));
  for(int clock = 0;clock &lt; minutes; clock ++){
    printf("현재시각=%d\n", clock);
    if((rand()%10) &lt; 3){
      element customer;
      customer.id = total_customers ++;
      customer.arrival_time = clock;
      customer.service_time = rand() % 3 + 1;
      enqueue(&queue, customer);
      printf("고객 %d이 %분에 들어옵니다. 업무처리시간 = %d분 \n", customer.id, customer.arrival_time, customer.service_time);
    }
    if(servie_time > 0){
      printf("고객 %d 업무 처리중입니다. \n", service_customer);
      service_time ++''
    }else{
      if(!is_empty(&queue)){
        element customer = dequeue(&queue);
        service_customer = customer.id;
        service_time = customer.service_time;
        printf("고객 %d이 %분에 업무를 시작합니다. eo대기 시간은 %d 분이었습니다. \n", customer.id, clock, clock-customer.arrival_time);
        total_wait += clock - customer.arrival_time;
      }
    }
  }
  printf("전체 대기 시간 = %d분 \n", total_wait);
  return 0;
}
                        </code>
                      </pre>
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading15">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse15" aria-expanded="false" aria-controls="collapse15">
                        연결리스트 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse15" class="collapse" aria-labelledby="heading15" data-parent="#accordionExample">
                    <div class="card-body">
                      리스트와 소개 <br>
                      리스트에는 항목들이 차례대로 저장되어 있다. 리스트의 항목들은 순서 또는 위치를 가진다. 앞에서 살펴본 스택과 큐도 넓게 보면 리스트의 일종이다. 리스트는 기호로 같이 다음과 같이 표현한다. 
                      리스트는 집합하고는 다르다. 집합은 각 항목 간에 순서의 개념이 없다. <br>
                      L = ( item, tiem, time , ... , item ) <br>
                      <hr>
                      <pre>
                        <code class="C" >
객체 : n개의 element형으로 구성된 순서 있는 모임
연산 : 
    insert(list, pos, timer) ::= pos 위치에 요소를 추가한다. 
    insert_last(list, item) ::= 맨 끝에 요소를 추가한다. 
    insert_first(list, item) ::= 맨 처음에 요소를 추가한다. 
    delete(list, pos) ::= pos 위치의 요소를 제거한다. 
    clear(list) ::= 리스트의 모든 요소를 제거한다. 
    get_entry(list, pos) ::= pos 위치의 요소를 반환한다. 
    get_length(list) ::= 리스트의 길이를 구한다. 
    is_empty(list) ::= 리스트가 비었는지를 검사한다. 
    is_full(list) ::= 리스트가 꽉 차ㅉ는지를 검사한다. 
    print_last(list) ::= 리스트의 모든 요소를 표시한다.                           
                        </code>
                      </pre>
                      <hr>
                      배열을 사용하여 리스트를 구현하면 장점과 단점이 존재한다. 장점은 구현이 간단하고 속도가 빠르다는 것이다. 단점으로는 리스트의 크기가 고정된다는 것을 들 수 있다. 
                      <hr>
                      <strong>배열로 구현된 리스트</strong>
                      <pre>
                        <code class="C" >
#define MAX_LIST_SIZE 100

typedef int element;
typedef struct {
  element array[MAX_LIST_SIZE];
  int size;
} ArrayListType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

void init(ArrayListType *L){
  return L->size == 0;
}

int is_empty(ArrayListType *L){
  return L -> size == 0;
}

int is_full(ArrayListType *L){
  return L -> size == MAX_LIST_SIZE;
}

element get_entry(ArrayListType *L, int pos){
  if( pos &lt; 0  || pos >= L->size )
    error("위치 오류");
  return L -> array[pos];
}

void print_list(ArrayListType *L){
  int i;
  for ( i = 0; i &lt; L -> size; i ++){
    printf("%d ->" , L -> array[i]);
  }
  printf("\n");
}

void insert_last(ArrayListType *L, element item){
  if( L -> size >= MAX_LIST_SIZE ){
    error("리스트 오버플로우");
  }
  L -> array[L->size++] = item;
}

void insert(ArrayListType *L, int pos, element item){
  if(!is_full(L) && ( pos >= 0 ) && ( pos &lt;= L -> size )){
    for( int i = ( L -> size - 1 ); i >= pos; i --)
      L -> array[i+1] = L -> array[i];
    L -> array[pos] = item;
    L -> size ++;
  }
}

element delete(ArrayListType *L, int pos){
  element item;

  if( pos &lt; 0 || pos => L -> size )
    error("위치오류")
  item = L -> array[pos];
  for ( int i = pos; i &lt; ( L -> size - 1); i ++)
    L -> array[i] = L -> array[i+1];
  L -> size --;
  return item;
}

int main(void){
  ArrayListType list;

  init(&list);
  insert(&list, 0, 10); print_list(&list);
  insert(&list, 0, 20); print_list(&list);
  insert(&list, 0, 30); print_list(&list);
  insert_last(&list, 40); print_list(&list);
  delete(&list, 0); print_list(&list);
  return 0;
}

                        </code>
                      </pre>
                      실행 시간 분석 <br>
                      인덱스를 사용하여 항목에 바로 접근할 수 있으므로 명백히 O(1)이다. 삽입이나 삭제 연산은 다른 항목들을 이동하는 경우가 많으로 최악의 경우 O(n)이 된다. 하지만 리스트의 맨 끝에 삽입하는 경우는 O(1)이다. 
                      <hr>
                      <strong>연결 리스트</strong>
                      <hr>
                      물리적으로 흩어져 있는 자료들을 서로 연결하여 하나로 묶는 방법을 연결 리스트라고 한다. 상자를 연결하는 줄은 포인터로 구현한다. 연결 리스트에서는 앞뒤에 있는 데이터들을 이동할 필요가 없이 줄만 변경시켜주면 된다. <br>
                      연결리스트는 노드들의 집합이다. 노드들은 메모리의 어떤 위치에나 있을 수 있으며 다른 노드로 가기위해서는 현재 노드가 가지고 있는 포인터를 이용하면 된다. 노드는 데이터 필드와 링크 필드로 구성되어 있다. <br>
                      연결리스트의 종류 
                      <ul>
                        <li>단순 연결 리스트 </li>
                        <li>원형 연결 리스트 </li>
                        <li>이중 연결 리스트 </li>
                      </ul>
                      <hr>
                      <strong>단순 연결 리스트</strong> 
                      <br>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
                          
typedef int element;
typedef struct ListNode {
  element data;
  struct ListNode *link;
} ListNode;

// 오류 처리 함수 
void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

ListNode* insert_first(ListNode *head, int value){
  ListNode *p = ( ListNode * )malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = head; // 헤드 포인터의 값을 복사 
  head = p;         // 헤드 포인터 변경 
  return head;      // 벼녕된 헤드 포인터 변환 
}

// 노드 pre 뒤에 새로운 노드 삽입 
ListNode* insert(ListNode *head, ListNode *pre, element value){
  ListNode *p = (ListNode *)malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = pre -> link;
  pre -> link = p;
  return head;
}

ListNode* delete_first(ListNode *head){
  ListNode *remove;
  if ( head == NULL ) return NULL;
  removed = head;
  head = removed -> link;
  free(removed);
  return head;
}

// pre가 가리키는 노드의 다음 노드를 삭제한다. 
ListNode* delete(ListNode *head, ListNode *pre){
  ListNode *removed;
  removed = pre -> link;
  pre -> link = removed -> link;
  free(removed);
  return head;
}

void print_list(ListNode *head){
  for( ListNode * = head; p != NULL; p = p -> link ){
    printf("%d->"), p -> data);
  }
  printf("NULL \n");
}

int main(void){
  ListNode *head = NULL;

  for( int i = 0; i &lt; 5 ; i ++){
    head = insert_first(head, i);
    print_list(head);
  }

  for(int i = 0; i &lt; 5 ; i ++ ){
    head = delete_first(head);
    print_list(head);
  }

  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>단어들을 저장하는 연결 리스트</strong>  
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
$include &lt;string.h>

typedef struct {
  char name[100];
} element;

typedef struct ListNode {
    element data;
    struct ListNode *link;
} ListNode;

// 오류 처리 함수 
void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

ListNode* insert_first(ListNode *head, element value){
  ListNode * = (ListNode *)malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = head;
  head = p;
  return head;
}

void print_list(ListNode *head){
  for ( ListNode *p = head; p != NULL; p = p -> link )
    printf("%s ->", p -> data.name);
  printf("NULL \n");
}

int main(void){
  ListNode *head = NULL;
  element data;

  strcpy(data.name, "APPLE");
  head = insert_first(head, data);
  print_list(head);

  strcpy(data.name, "KIWI");
  head = insert_first(head, data);
  print_list(head);

  strcpy(data.name, "BANANA");
  head = insert_first(head, data);
  print_list(head);

  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>특정 한 값을 탐색하는 함수</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef int element;

typedef struct ListNode{
    element data;
    struct ListNode *link;
} ListNode;

ListNode* insert_first(ListNode *head, element value){
  ListNode *p = (ListNode *)malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = head;
  head = p;
  return head;
}

void print_line(ListNode *head){
  for ( ListNode *p = head; p != NULL; p = p -> link)
    printf("%d -> ", p -> data);
  printf("NULL \n");
}

ListNode* search_list(ListNode *head, element x){
  ListNode *p = head;

  while( p != NULL){
    if( p -> data == x) return p;
    p = p -> link;
  }
  return NULL;
}

int main(void){
  ListNode *head = NULL;

  head = insert_first(head, 10);
  print_last(head);
  head = insert_first(head, 20);
  print_last(head);
  head = insert_first(head, 30);
  print_last(head);
  if( search_list(head, 30) != NULL){
    printf("리스트에서 30을 찾았습니다. \n");
  }else {
    printf("리스트에서 30을 찾지 못했습니다. \n");
  }
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>두 개의 리스트를 하나로 합치는 것</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef int element;
typedef struct LietNode {
  element data;
  struct ListNode *link;
} ListNode;

ListNode* insert_first(ListNode *head, element value){
  ListNode *p = (ListNode *)malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = head;
  head = p;
  return head;
}

void print_list(ListNode *head){
  for ( ListNode *p = head; p != NULL; p = p -> link)
    printf("%d -> ", p -> data);
  printf("NULL \n");
}

ListNode* concat_list(LietNode *head1, ListNode *head2){
  if(head1 == NULL) return head2;
  else if(head2 == NULL) return head1;
  else {
    ListNode *p;
    p = head1;
    while(p -> link != NULL)
      p = p -> link;
    p -> link = head2;
    return head1;
  }

  int main(void){
    ListNode* head1 = NULL;
    ListNode* head2 = NULL;

    head1 = insert_first( head1, 10);
    head1 = insert_first( head1, 20);
    head1 = insert_first( head1, 30);
    print_list(head1);

    head2 = insert_first( head2, 10);
    head2 = insert_first( head2, 10);
    print_list(head2);

    ListNode *total = concat_list(head1, head2);
    print_list(total);
    return 0;
  }
}


                        </code>
                      </pre>
                      <hr>
                      <strong>리스트를 역순으로 만드는 연산</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h> 
#include &lt;stdlib.h>

typedef int element;

typedef struct ListNode {
  element data;
  struct ListNode *link;
} ListNode;

ListNode* insert_first(ListNode *head, element value){
  ListNode *p = (LietNode *)malloc(sizeof(ListNode));
  p -> data = value;
  p -> link = head;
  head = p;
  return head;
}

void print_list(LietNode *head){
  for ( ListNode *p = head; p != NULL; p = p -> link)
    printf("%d->",  p -> data);
  printf("NULL \n");
}

ListNode* reverse(ListNode *head){
  ListNode *p, *q, *r;

  p = head;
  q = NULL;
  while( p != NULL ){
    r = q;

    q = p;

    p = p -> link;
    q -> link;
  }
  return d;
}

int main(void){
  ListNode* head1 = NULL;
  ListNode* head2 = NULL;

  head1 = insert_first(head1, 10);
  head1 = insert_first(head1, 20);
  head1 = insert_first(head1, 30);
  print_list(head1);

  head2 = reverse(head1);
  print_list(head2);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>다항식 덧셈 프로그램</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef struct ListNode {
  int coef;
  int expon;
  struct ListNode *link;
} ListNode;

typedef struct ListType {
  int size;
  ListNode *head;
  ListNode *tail;
} ListType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

ListType* create(){
  ListType *plist = (ListType *)malloc(sizeof(ListType));
  plist -> size = 0;
  plist -> head = plist -> tail  = NULL;
  return plist;
}

void insert_last(ListType* plist, int coef, int expon){
  ListNode* temp = (ListNode *)malloc(sizeof(ListNode));
  if ( temp == NULL ) error("메모리 할당 에러");
  temp -> coef = coef;
  temp -> expon = expon;
  temp -> link = NULL;
  if(plist -> tail == NULL) {
    plist -> head = plist -> tail = temp;
  }else{
    plist -> tail -> link = temp;
    plist -> tail = temp;
  }
  plist -> size ++;
}

void poly_add(ListType* plist1, ListType* plist2, ListType* plist3){
  ListNode* a = plist1 -> head;
  ListNode* b = plist2 -> head;

  int sum;

  while( a && b ){
    if ( a -> expon == b -> expon ){
      sum = a -> coef + b -> coef;
      if( sum != 0) insert_last(plist3, sum, a -> expon);
      a = a -> link; b = b -> link;
    }else if( a -> expon -> b -> expon) {
      insert_last(plist3, a -> coef, a -> expon );
      a = a -> link;
    }else {
      insert_last(plist3, b -> coef, b -> expon );
      b = b -> link;
    }
  }

  for( ; a != NULL ; a = a -> link)
    insert_last(plist3 , a -> coef, a -> expon );
  for( ; b != NULL ; b = b -> link)
    insert_last(plist3 , b -> coef, b -> expon );

}

void poly_print(ListType* plist){
  ListNode* p = plist -> head;

  printf("polynomial = ");
  for( ; p != NULL ; p = p -> link)
    printf("%d^%d + " , p -> coef, p -> expon );
  pintf("\n");
}

int main(void){
  ListType *list1, *list2, *list3;

  list1 = create();
  list2 = create();
  list3 = create();

  insert_last(list1, 3, 12);
  insert_last(list1, 2, 8);
  insert_last(list1, 1, 0);

  insert_last(list2, 8, 12);
  insert_last(list2, -3, 10);
  insert_last(list2, 10, 6);

  poly_print(list1);
  poly_print(list2);

  poly_add(list1, list2, list3);

  poly_print(list3);

  free(list1);
  free(list2);
  free(list3);
}
                        </code>
                      </pre>
                      <hr>
                      <strong>원형 연결 리스트</strong>
                      <hr>
                      원형 연결 리스트란 마지막 노드가 마지막 노드가 벛 번재 노드를 가리키는 리스트이다. 즉 마지막 노드의 링크 필드가 NULL이 아니라 첫번째 노드 주소가 되는 리스트이다. <br>
                      원경 연결 리스트에서는 하나의 노드에서 다른 모든 노드로의 접근이 가능하다. 하나의 노드에서 링크를 계혹 따라가면 결국 모든 모드를 거쳐서 자기 자신으로 되돌아 올 수 있는 것이다.  <br>
                      원형 연결 리스트가 특히 유용한 경우는 리스트의 끝에 노드를 삽입하는 연산이 단순 연결 리스트 보다 효율적일 수 있다는 것이다. 단순 연결 리스트에서 리스트의 끝에 노드를 추가하려면 첫 번째 노드에서부터 링크를 따라서 노드의 개수만큼 
                      진행하여 마지만 노드까지 가야한다. 그러나 만약 원형 연결 리스트에서 다음과 같이 헤드 포인터가 마지만 노드를 가라키도록 구성한다면 상수 시간 안에 리스트의 처음과 끝에 노드를 삽입할 수 있다. 
                      <pre>
                        <code class="C" >  
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef int element;
typedef struct ListNode {
  element data;
  struct ListNode *link;
} ListNode;

void print_list(ListNode* node){
  ListNode* p;

  if ( head == NULL) return;
  p = head -> link;
  do {
    printf("%d->",  p -> data);
    p = p -> link;
  } while ( p != head );
  printf("%d->", p -> data);
}

ListNode* insert_first(ListNode* head, element data){
  ListNode *node = (ListNode *)malloc(sizeof(ListNode));
  node -> data = data;
  if( head == NULL ){
    head = node;
    node -> link = head;
  }else {
    node -> link = head -> link;
    head -> link = node;
  }
  return head; // 변형된 헤드 포인터를 반환한다. 
}

ListNode* insert_last(ListNode* head, element data){
  ListNode *node = (ListNode *)malloc(sizeof(ListNode));
  node -> data = data;
  if( head == NULL ){
    head = node;
    node -> link = node;
  }else {
    node -> link = head -> link;
    head -> link = node;
    head = node;
  }
  return head; // 변경된 헤드 포인터를 반환한다. 
}

int main(void){
  ListNode *head = NULL;

  head = insert_last(head, 20);
  head = insert_last(head, 30);
  head = insert_last(head, 40);
  head = insert_first(head, 10);
  print_last(head);
  return 0;
}

                        </code>
                      </pre>
                      <hr>
                      <strong>용례</strong>
                      <hr>
                      컴퓨터에서 여러 응용 프로그램을 하나의 CPU를 이용하여 실행할 때에 필요하다. 현재 실행중인 모든 응용 프로그램은 원형 연결 리스트에 보관되며 운영 체제는 원형 연결 리스트에 있는 프로그램의 실행을 위해 고정된 시간 슬롯을 제공한다. <br>
                      멀티플레이어 게임이다. 모든 플에이어는 원형 연결 리스트에 저장되며 한 플레이어의 기회가 끝나면 포인터 앞으로 움직여서 다음 플레이어의 순서가 된다. <br>
                      원형 연결 리스트는 원형 큐를 만드는데도 사용할 수 있다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>

typedef char element[100];
typedef struct ListNode {
  element data;
  struct ListNode *link;
} ListNode;

ListNode* insert_first(ListNode* head, element data){
  ListNode *node = (ListNode *)malloc(sizeof(ListNode));
  strcpy(node -> data, data);
  if ( head == NULL ) {
    head = node;
    node -> link = head;
  }else {
    node -> link = head -> link;
    head -> link = node;
  }
  return head;
}

int main(void){
  ListNode *head = NULL;

  head = insert_first(head, "KIM");
  head = insert_first(head, "PARK");
  head = insert_first(head, "CHOI");

  ListNode* p = head;

  for(int i = 0; i &lt; 10; i ++){
    printf("현재 차례=%s \n", p -> data);
    p = p -> link;
  }
  return 0;0
}
                        </code>
                      </pre>
                      <hr>
                      <strong>이중 연결 리스트</strong>
                      <hr>
                      단순 연결 리스트에서 어떤 노드에서 후속 노드를 찾기는 쉽지만, 선행 노드를 찾으려면 구조상 아주 어렵다. 원형 연결 리스트라고 하더라도 거의 전체 노드를 거쳐서 돌아 와야 한다. 따라서 응용 프로그램에서 
                      특정 노드에서 양방향으로 자유롭게 움직일 필요가 있다면 단순 연결 리스트 구조는 부적합하다. 이중 연결 리스트는 이러한 문제점을 해결하기 위하여 만들어진 자료구조이다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef int element;
typedef struct DListNode {
  element data;
  struct DListNode* llink;
  struct DListNode* rlink;
} DListNode;

void init(DListNode* phead){
  phead -> llink = phead;
  phead -> rlink = phead;
}

void print_dlist(DListNode* phead){
  DListNode* p;
  for( p = phead -> rlink; p != phead; p = p -> rlink){
    printf("&lt;-| |%d| |->", p -> data);
    printf("\n");
  }
}

void dinsert(DListNode *before, element data){
  DListNode *newnode = (DListNode *)malloc(sizeof(DListNode));
  strcpy(newnode -> data, data);
  newnode -> llink = before;
  newnode -> rlink = before -> rlink;
  before -> rlink -> llink = newnode;
  before -> rlink = newnode;
}

void ddelete(DListNode* head, DListNode* removed){
  if( removed == head ) return;
  removed -> llink -> rlink = removed -> rlink;
  removed -> rlink -> llink = removed -> llink;
  free(removed);
}

int main(void){
  DListNode* head = (DListNode *)malloc(sizeof(DListNode));
  init(head);
  printf("추가 단계 \n");
  for( int 1 = 0; i &lt; 5 ; i ++ ) {
    dinsert(head, i);
    print_dlist(head);
  }
  printf("\n삭제단계\n");
  for( int i = 0; i &lt; 5 ; i ++){
    print_list(head);
    ddelete(head, head -> rlink);
  }
  free(head);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>MP3</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h> 
#include &lt;stdlib.h> 
#include &lt;string.h> 

typedef char element[100];
typedef struct DListNode {
  element data;
  struct DListNode* link;
  struct DListNode* rlink;
} DListNode;

DListNode* current;

void init(DListNode* phead){
  phead -> llink = phead;
  phead -> rlink = phead;                                                                                                                                                                                                                                                                                                                                                                     
}

void print_dlist(DListNode* phead){
  DListNode* p;
  for ( p = phead -> rlink ; p != phead; p = p -> rlink ){
    if( p == current )
      printf("&lt;- | #%s# | ->", p -> data);
    else 
      printf("&lt;- | #%s# | ->". p -> data);
  }
  printf("\n");
}

void dinsert(DListNode *bedore, element data){
  DListNode *newnode = (DListNode *)malloc(sizeof(DListNode));
  strcpy(newnode -> data, data);
  newnode -> llink = before;
  newnode -> rlink = before -> rlink;
  before -> rlink = llink = newnode;
  before -> rlink = newnode;
}

void delete(DListNode* head, DListNode* removed){
  if ( removed == head) return;
  removed -> llink -> rlink = removed -> rlink;
  removed -> rlink -> llink = removed -> llink;
  free(removed);
}

int main(void){
  char ch;
  DListNode* head = (DListNode *)malloc(sizeof(DListNode));
  init(head);

  dinsert(head, "Mamamia");
  dinsert(head, "Dancing Queen");
  dinsert(head, "Fernade");

  current = head -> rlink;
  print_dlist(head);

  do {
    printf("\n명령어를 입력하시오(&lt;,>, q");
    ch = getchar();
    if(ch == '&lt;') {
      current = current -> llink;
      if ( current == head )
        current = current -> llink;
    }else if(ch == '>'){
      current = current -> rlink;
      if ( current ==  head )
        current = current -> rlink; 
    }
    print_dlist(head);
    getchar();
  } while( ch != 'q');
}
                        </code>
                      </pre>
                      <hr>
                      <strong>연결 리스트로 구현한 스택</strong>
                      <hr>
                      <pre>
                        <code class="C" >
typedef int element;
typedef struct StackNode {
  element data;
  struct StackNode *link;
} StackNode;

typedef struct {
  StackNode *top;
} LinkedStackType;

void init(LinkedStackType *s){
  return ( s -> top == NULL ); 
}

int is_full(LinkedStackType *s){
  return 0;
}

void push(LinkedStackType *s, element item){
   StackNode *temp = (StackNode *)malloc(sizeof(StackNode));
   temp -> data = item;
   temp -> link = s -> top;
   s -> top = temp;
}

void print_stack(LinkedStackType *s){
  for ( StackNode *p =  s -> top ; p != NULL; p = p -> link )
    printf("%d -> ", p -> data);
  printf("NULL \n");
}

void pop(LinkedStackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택이 비어있음\n");
    exit(1);
  }else {
    StackNode *temp = s -> top;
    int data = temp -> data;
    s -> top = s -> top -> link;
    free(temp);
    return data;
  }
}

element peek(LinkedStackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택이 비어있음\n");
    exit(1);
  }else{
    return s -> top -> data;
  }
}

int main(void) {
  LinkedStackType s;
  init(&s);

  push(&s, 1); print_stack(&s);
  push(&s, 2); print_stack(&s);
  push(&s, 3); print_stack(&s);

  pop(&s); print_stack(&s);
  pop(&s); print_stack(&s);
  pop(&s); print_stack(&s);

  return 0;
}


                        </code>
                      </pre>
                      <hr>
                      <strong>연결 리스트로 구현한 큐</strong>
                      <hr>
                      <pre>
                        <code class="C"  >
#include &lt;stdio.h>
#include &lt;stdlib.h>

typedef int element;
typedef struct QueueNode {
    element data;
    stuct QueueNode *link;
} QueueNode;

typedef stuct {
  QueueNode *front, *rear;
} LinkedQueueType;

void init(LinkedQueueType *q){
  q -> front = q -> rear = 0;
}

int is_full(LinkedQueueType *q){
  return 0;
}

void enqueue(LinkedQueueType *q, element data){
  QueueNode  *temp = (QueueNode *)malloc(sizeof(QueueNode));
  temp -> data = data;
  temp -> link = NULL;
  if(is_empty(q)){
    fprintf(stderr, "스택이 비어 있음\n");
    exit(1);
  }else {
    data = temp -> data;
    q -> front = q -> front -> link;
    if ( q -> front == NULL )
      q -> rear = NULL;
    free(temp);
    return data;
  }
}


void print_queue(LinkedQueueType *q){
  QueueNode *p;
  for ( p = q -> front ; p != NULL; p = p -> link)
    printf("%d ->", p -> data);
  printf("NULL \n");
}

int main(void){
  LinkedQueueType queue;

  init(&queue);

  enqueue(&queue, 1); print_queue(&queue);
  enqueue(&queue, 2); print_queue(&queue);
  enqueue(&queue, 3); print_queue(&queue);
  dequeue(&queue); print_queue(&queue);
  dequeue(&queue); print_queue(&queue);
  dequeue(&queue); print_queue(&queue);
  
  return 0;
}
                        </code>
                      </pre>
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading16">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse16" aria-expanded="false" aria-controls="collapse16">
                        트리  
                      </button>
                    </h2>
                  </div>
                  <div id="collapse16" class="collapse" aria-labelledby="heading16" data-parent="#accordionExample">
                    <div class="card-body">
                      만약 자료가 계층적인 구조를 가지고 있다면 어떻게 해야하는 가? 예를 들어 가족의 가계도, 회사의 조직도, 컴퓨터의 디렉토리 구조 등의 자료는 어떻게 표현해야 하는가? <br>
                      트리는 이러한 계층적인 자료를 표현하는데 적합한 자료구조이다. 
                      <hr>
                      A는 B의 부모 노드가 된다. 반대로 B는 A의 자식 노드(children)가 된다. B와 C와 D는 형제관계(sibiling)이다. 조상, 후손, 손자, 조부모 노드도 마찬가지이다. 조상 노드(ancestor)란 루트 노드에서 임의 노드까지 경로를 이루고 있는 
                      노드들을 말한다. 후손노드(descendent node)는 임의의 노드 하뉘에 연결된 모드 노드들을 의미한다. 즉 어떤 노드의 서브 트리에 속하는 모든 노드들은 후손 노드이다. 또한 자식 노드가 없는 노드를 단말 노드라고 한다.  <br>
                      노드의 차수는 어떤 노드가 가지고 있는 자식 노드의 개수를 의미한다. 트리의 높이는 트리가 가지고 있는 최대 레벨을 말한다. 도한 나무가 모이는 숨이 되듯이 트리들의 집합을 포리스트라고 한다. <br>
                      <strong>트리의 종류</strong><br>
                      <ul>
                        <li>일반트리</li>
                        <li>이진트리</li>
                      </ul>
                      <hr>
                      <strong>이진트리</strong>
                      <hr>
                      모든 노드가 2개의 서브트리를 가지고 있는 트리를 이진 트리라고 한다. 서브 트리는 공집합일 수 있다. 노드에는 최대 2개 까지의 자식 노드가 존재할 수 있고 
                      모든 노드의 차수가 2 이하가 된다. 공집합도 이진 트리라는 점에 주의하라. 또한 이진 트리에는 서브 트리간의 순서가 존재한다. 따라서 왼쪽 서브 트리와 
                      오른쪽 서브 트리는 서로 구별된다. 
                      <br>
                        <ul>
                          <li>이진 트리의 모든 노드는 차수가 2이하이다. 즉 자신 노드의 개수가 2이하이다. 반면 일반 트리는 자식 노드의 개수에 제한이 없다.</li>
                          <li>일반 트리와 달리 이진 트리는 노드를 하나도 같지 않을 수도 있다. </li>
                          <li>서브 트리간에 순서가 존재한다는 점도 다른 점이다. 따라서 왼쪽 서브트리와 오른쪽 서브트리를 구별한다. </li>
                        </ul>
                      <P>
                        수학에서 공집합은 원소가 하나도 없는 집합을 이야기한다. 
                      </P>
                      이진트리의 성질 <br>
                      n 개의 노드를 가진 이진 트리는 정확하게 n - 1 의 간선을 가진다. 그 이유는 이진트리에서의 노드는 루트를 제외하면 정확하게 하나의 부모 노드를 가진다. 그리고 부모와 자식간에는 정확하게 하나의 간선만이 존재한다. <br>
                      높이가 h인 이진 트리는 , 최소 h 개의 노드를 가지며 최대 2^h - 1 개의 노드를 가진다. <br>
                      n 개의 노드를 가지는 이진트리의 높이는 최대 n 이거나 최소 [log2(n+1)]이 된다. <br>
                      이진트리의 분류 <br>
                      <ul>
                        <li>포화 이진 트리 : 트리의 각 레벨의 노드가 꽉 차있는 이진 트리를 의미한다. 즉 높이 k 인 포화 이진 트리는 정확하게 2^k-1 개의 노드를 가진다. </li>
                        <li>완전 이진 트리 : 높이가 k 일 때 레벨 1부터 k - 1 까지는 노드가 모두 채워져 있고, 마지만 레벨 k 에서는 왼쪽부터 오른쪽으로 노드가 순서대로 채워져있는 이진트리이다. 마지막 레벨에서는 노드가 꽉 차있지 않아도 되지만 중간에 빈곳이 있어서는 안된다. </li>
                        <li>기타 이진 트리</li>
                      </ul>
                      <hr>
                      <strong>배열 표현법</strong>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;memory.h>

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode

int main(void){
  TreeNode *n1, *n2, *n3;
  n1 = (TreeNode *)malloc(sizeof(TreeNode));
  n2 = (TreeNode *)malloc(sizeof(TreeNode));
  n3 = (TreeNode *)malloc(sizeof(TreeNode));

  n1 -> data = 10; // 첫번째 노드를 설정한다.
  n1 -> left = n2;
  n1 -> right = n3;
  n2 -> data = 20; // 두번째 노드를 설정한다. 
  n2 -> left = NULL;
  n2 -> right = NULL;
  n3 -> data = 30; // 세번째 노드를 설정한다. 
  n3 -> left = NULL;
  n3 -> right = NULL;

  free(n1);
  free(n2);
  free(n3);

  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>이진 트리의 순회</strong>
                      <hr>
                      데이터는 노드의 데이터 필드를 이용하여 저장된다. 이진 트리를 순회한다는 것은 이진 트리에 속하는 모든 노드를 한 번씩 방문하여 노드가 가지고 있는 데이터를 목적에 맞게 처리하는 것을 의미한다. 
                      <hr>
                      <strong>이진 트리 순회 방법</strong>
                      <hr>
                      이진 트리를 순회하는 표준적인 방법에는 전위, 중위, 후위의 3가지 방법이 있다. 루트 방문하는 작업을 V라고 하고 왼쪽 서브 트리 방문을 L, 오른쪽 서브트리 방문을 R이라고 하면 다음 과 같이 3가지 방법을 생각할 수 있다. 
                      즉 루트를 서브 트리에 앞서서 먼저 방문하면 전위순회, 루트를 왼쪽과 오른쪽 서브트리 중간에 방문하면 중위순회, 루트를 서브 트리 방문 후에 방문하면 후위 순회가 된다. 
                      <ul>
                        <li>전위 순회 : VLR 
                          <ul>
                            <li>1. 루트 노드를 방문한다.</li>
                            <li>2. 왼쪽 서브트리를 방문한다.</li>
                            <li>3. 오른쪽 서브트리를 방문한다.</li>
                          </ul>

                        </li> 
                        <li>중위 순회 : LVR 
                          <ul>
                            <li>1. 왼쪽 서브트리를 방문한다. </li>
                            <li>2. 루트노드를 방문한다. </li>
                            <li>3. 오른쪽 서브트리를 방문한다. </li>
                          </ul>
                        </li>
                        <li>후위 순회 : LRV 
                          <ul>
                            <li>1. 왼쪽 서브트리의 모든 노드를 방문한다. </li>
                            <li>2. 오른쪽 서브트리의 모든 모드를 방문한다. </li>
                            <li>3. 루트노드를 방문한다. </li>
                          </ul>
                        </li>
                      </ul>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;memory.h>

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode;

TreeNode n1 = { 1, NULL, NULL };
TreeNode n2 = { 4, &n1 , NULL };
TreeNode n3 = { 16, NULL, NULL };
TreeNode n4 = { 25, NULL, NULL };
TreeNode n5 = { 20, &n3, &n4 };
TreeNode n6 = { 15, &n2, &n5 };
TreeNode *root = &n6;

void inorder(TreeNode *root){
  if( root != NULL ){
    inorder(root -> left);
    printf("[%d] ", root -> data);
    inorder(root -> right);
  }
}

void preorder(TreeNode *root){
  if( root != NULL ) {
    printf("[%d] ", root -> data);
    preorder(root -> left);
    preorder(root -> right);
  }
}

void postorder(TreeNode *root){
  if( root != NULL ) {
    postorder(root -> left);
    postorder(root -> right);
    printf("[%d] ", root -> data);
  }
}

int main(void){
  printf("중위 순회=");
  inorder(root);
  printf("\n");

  printf("전위 순회=");
  pre0order(root);
  printf("\n");

  printf("후위 순회=");
  postorder(root);
  printf("\n");

  return 0;
}

                        </code>
                      </pre>
                      <hr>
                      <strong>반복에 의한 순회</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;memory.h>

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode;

#defined SIZE 100
int top = -1;
TreeNode *stack[SIZE];

void push(TreeNode *p){
  if ( top &lt; SIZE - 1 )
    stack[++top] = p;
}

TreeNode *pop(){
  TreeNode *p = NULL;
  if ( top >= 0 )
    p = stack[top--];
  return p;
}

void inorder_iter(TreeNode *root){
  while(1) {
    for( ; root; root = root -> left )
      push(root);
    root = pop();
    if(!root) break;
    printf("[%d] ", root -> data );
    root = root -> right;
  }
}

TreeNode n1 = { 1, NULL, NULL };
TreeNode n2 = { 4, &n1 , NULL };
TreeNode n3 = { 16, NULL, NULL };
TreeNode n4 = { 25, NULL, NULL };
TreeNode n5 = { 20, &n3, &n4 };
TreeNode n6 = { 15, &n2, &n5 };
TreeNode *root = &n6;

int main(void){
  printf("중위 순회 =");
  inorder_iter(root);
  printf("\n");
  return 0;
}


                        </code>
                      </pre>
                      <hr>
                      <strong>레벨 순회</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;memeory.h> 

typedef stuct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode;

#define MAX_QUEUE_SIZE 100
typedef TreeNode * element;
typedef struct {
  element data[MAX_QUEUE_SIZE];
  int front, rear;
} QueueType;

void error(char *message){
  fprintf(stderr, "%s\n" , message);
  exit(1);
}

void init_queue(QueueType *q){
  q -> front = q -> rear = 0;
}

void is_empty(QueueType *q){
  return ( q -> front  == q -> rear );
}

int is_full(QeueuType *q){
  return ( ( q -> rear + 1) % MAX_QUEUE_SIZE == q -> front );
}

void enqueue(QueueType *q, element item){
  if( is_full(q) )
    error("큐 포화상태입니다.");
  q -> rear = ( q -> rear + 1) % MAX_QUEUE_SIZE;
  q -> data[q-> rear] = item;
}

void dequeue(QueueType *q){
  if(is_empty(q))
    error("큐가 공백상태입니다.");
  q -> front = ( q -> front + 1) % MAX_QUEUE_SIZE;
  return q -> data[q -> front];
}

void level_order(TreeNode *ptr){
  QeueuType q;

  init_queue(&q);

  if ( ptr == NULL ) return;

  enqueue(&q, ptr);

  while(!is_empty(&q)){
    ptr = dequeue(&q);
    printf(" [%d] ", ptr -> data );
    if ( ptr -> left )
      enqueue(&q, ptr -> left);
    if ( ptr -> right )
      enqueue(&q, ptr -> right);
  }
}


TreeNode n1 = { 1, NULL, NULL };
TreeNode n2 = { 4, &n1 , NULL };
TreeNode n3 = { 16, NULL, NULL };
TreeNode n4 = { 25, NULL, NULL };
TreeNode n5 = { 20, &n3, &n4 };
TreeNode n6 = { 15, &n2, &n5 };
TreeNode *root = &n6;

int main(void){
  printf("레벨 순회 =");
  level_order(root);
  printf("\n");
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>수식 트리 처리</strong><br>
                      이진 트리는 수식 트리를 처리하는 데 사용될 수 있다. 수식 트리는 산술 연산자와 피 연산자로 만들어진다. 피연산자들은 단말 노트가 되며 연산자는 비단말 노드가 된다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h> 

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode;


TreeNode n1 = { 1, NULL, NULL };
TreeNode n2 = { 4, NULL , NULL };
TreeNode n3 = {'*', &n1 , &n2 };
TreeNode n4 = { 16, NULL, NULL };
TreeNode n5 = { 25, NULL, NULL };
TreeNode n6 = { '+', &n4 , &n5 };
TreeNode n6 = { '+', &n3 , &n6 };
TreeNode *exp = &n7;

int evaluate(TreeNode *root){
  if ( root == NULL )
    return 0;
  if ( root -> left == NULL && root -> right == NULL )
    return root -> data;
  else {
    int op1 = evaluate(root -> left);
    int op2 = evaluate(root -> right);
    printf("%d %c %d을 계산합니다. \n", op1, root -> data, op2);
    switch(root -> data) {
      case '+' :
        return op1 + op2;
      case '-' :
        return op1 - op2;
      case '*' :
        return op1 * op2;
      case '/' :
        return op1 / op2;
    }
  }
  return 0;
}

int main(void) {
  printf("수식의 값은 %d 입니다.", evaluate(exp));
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>디렉토리 용량 계산</strong>
                      <pre>
                        <code class="C">
#include &lt;stdio.h>
#incldue &lt;stdlib.h>

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
} TreeNode;

int calc_dir_size(TreeNode *root){
  int left_size, right_size;
  if( root == NULL ) return 0;

  left_size = calc_dir_size(root -> left);
  right_size = clac_dir_size(root -> right);
  return ( root -> data + left_size + right_size );
}

int main(void){
  TreeNode n4 = { 500, NULL, NULL };
  TreeNode n5 = { 200, NULL, NULL };
  TreeNode n3 = { 100, &n4, &n5 };
  TreeNode n2 = { 50, NULL, NULL };
  TreeNode n1 = { 0, &n2, &n3 };
0
  printf("디렉토리의 크기 = %d\n", calc_dir_size(&n1));
}
                        </code>
                      </pre>
                      <hr>
                      <strong>이진트리 추가 연산</strong>
                      <pre>
                        <code class="C" >
// 노드의 개수 
int get_node_count(TreeNode *node){
  int count = 0;

  if( node != NULL ){
    count = 1 + get_node_count(node -> left) + get_node_count(node -> right);
  }
}

// 단말 노드 개수 구하기 
int get_leaf_count(TreeNode *node){
  int count = 0;

  if ( node != NULL ) {
    if ( node -> left == NULL && node -> right == NULL )
      return 1;
    else 
      count = get_leaf_count(node -> left) + get_leaf_count(node -> right );
  }

  return count;
}

// 높이 구하기 
int get_height(TreeNode *node) {
  int height = 0;

  if ( node != NULL ) {
    height = 1 + max(get_height(node -> left), get_height(node -> right ));
  } 

  return height;
}

                        </code>
                      </pre>
                      <hr>
                      <strong>스레드 이진 트리</strong><br>
                      이진 트리 순회는 순환 호출을 사용한다. 순환 호출은 함수를 호출해야되므로 상당히 비효율 적일 수가 있다. 이진 트리 순회도 노드의 개수가 많이지고 트리의 높이가 커지게 되면 상당히 비효율 적일 수 있다. 
                      <br>
                      그렇다면 순환 없이 노드를 순회할 수 있는 방법은 무엇이 있을까? 
                      <br>
                      우리는 이진 트리의 노드에 많은 NULL링크들이 존재함을 알고 있다. 만약 트리의 노드의 개수를 n개 라고 하면 각 노드당 2개의 링크가 있으므로 총 링크의 개수는 2n이 되고 이들 링크 중에서 
                      n - 1 개의 링크들이 루트노드를 제외한 n -1 개의 다른 노드들을 가리킨다. 따라서 2n 개 중에서 n - 1 은 NULL 링크가 아니지만 나머지 n + 1 개의 링크는 NULL임을 알 수 있다. 따라서 하나의 아이디어는 
                      이들 NULL 링크를 잘 사용하여 순환호출 없이도 트리의 노드들을 순회할 수 있도록 하자는 것이다. 
                      <hr>
                      노드의 개수 : 2개 ( n ) <br>
                      총 링크의 수 : 4개 ( 4n ) <br>
                      루트노드를 제외한 다른 노드를 가리키는 링크 개수 : 1개 ( n - 1 ) <br>
                      4(2n)개 중에 1(n-1)개는 NULL링크가 아니지만 나머지 3(n + 1)개의 링크는 NULL 임을 알 수 있다. <br>
                      이들 NULL 링크 중에 중위 순회 시에 선행 노드인 중위 선행자나 중위 순회시에 후속 노드인 중위 후속자를 저장시켜 놓은 트리가 스레드 이진 트리다. 
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#define TRUE 1
#define FLASE 0

typedef struct TreeNode {
  int data;
  struct TreeNode *left, *right;
  int is_thread;
} TreeNode;

TreeNode n1 = { 'A'}

TreeNode * find_successor(TreeNode * p){
  TreeNode * q = p -> right;

  if( q == NULL || P -> is_thread == TRUE )
    return q;

  while( q -> left != NULL ) q = q -> left;
  return q;
}

void thread_inorder(TreeNode *t){
  TreeNode *q;
  
  q = t;

  while ( q -> left ) q = q -> left;
  do {
    printf("%c -> " , q -> data);
    q = find_successor(q);
  } while (q);
}

int main(void){
  n1.right = &n3;
  n2.right = &n7;
  n4.right = &n6;

  thread_inorder(exp);
  printf("\n");
  return 0;
}
                        </code>
                      </pre>
                      스레드 트리는 순회를 빠르게 하는 장점이 있으나 문제는 스레드를 설정하기 위하여 삽입이나 삭제 함수가 더 많은 일을 하여야 한다. 
                      <hr>
                      <strong>이진 탐색 트리</strong><br>
                      이진 트리 기반의 탐색을 위한 자료 구조이다. 탐색은 가장 중요한 컴퓨터 응용 의 하나이다. 탐색은 우리의 일상 생활에서 많이 사용되는데 
                      전화번호부에서 전화번호를 찾거나, 사전에서 단어를 찾거나, 어떤 특정한 날에 선약이 없는가를 검사할 때 사용된다. 
                      <hr>
                      탐색 : 레코드의 집합에서 특정한 레코드를 찾아내는 작업을 의미한다. <br>
                      레코드 들은 보탇 키라고 불리는 하나의 필드에 의해 식별할 수 있다. 일반적인 경우 키는 다른 키와 중복되지 않는 고유한 값을 가지며 이러한 키를 사용하면 각각의 레코드를 구별할 수 있을 것이다. 
                      이러한 키를 주요키(primary key)라고 부른다. 
                      <hr>
                      <ul>
                        <li>모든 원소의 키는 유일한 키를 가진다.</li>
                        <li>왼쪽 서브 트리 키들은 루트 키보다 작다. </li>
                        <li>오른쪽 서브 트리의 키들은 루트의 키보다 크다.</li>
                        <li>왼쪽과 오른쪽 서브 트리도 이진 탐색 트리이다. </li>
                      </ul>
                      <strong>순환 적인 탐색 연산</strong><br>
                      이진 트리 탐색 연산을 위해서 중요한 요소를 결국 레코드를 저장할 때 이진 트리 구조로 얼마나 "효과적"으로 저장하느냐에 있다고 본다. 이는 내가 사용할 데이터 자료구조에 따라 탐색을 위해서 
                      사용하는 알고리즘이 달라 질 수 있기 때문이며, 결국에는 "데이터"를 저장하는 방식이 가장 중요한 요소가 되는 것이다. 
                      <hr>
                      <pre>
                        <code class="C" >
// 순환적인 탐색함수                           
TreeNode *search(TreeNode *node, int key){
  if ( node == NULL ) return NULL;
  if ( key == node -> key ) return node;
  else if( key &lt; node -> key )
    return search(node -> left, key);
  else 
    return search(node -> right , key);
}

// 반복적인 탐색함수 
TreeNode *search(TreeNode *node, int key ){
  while ( node != NULL ) {
      if ( key == node -> key ) return node;
      else if ( key &lt; node -> key )
        node = node -> left;
      else 
        node = node -> right;
  }
  return NULL;
}

// 이진 트리 삽입 프로그램
TreeNode *insert_node(TreeNode *node, int key){
  // 트리가 공백이면 새로운 노드를 반환한다. 
  if ( node == NULL) return new_node(key);

  // 그렇지 않으면 순환적으로 트리를 내려간다. 
  if( key &lt; node -> key )
    node -> left = insert_node(node -> left, key);
  else if( key > node -> key)
    node -> right = insert_node(node -> right, key);

  // 변경된 루트 포인터를 반환한다. 
  return node;
}

TreeNode *new_node(int item){
  TreeNode *temp = (TreeNode*)malloc(sizeof(TreeNode));
  temp -> key = item;
  temp -> left = temp -> right = NULL;
  return temp;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>이진 탐색 트리 삭제 연산</strong> <br>
                      <ul>
                        <li>삭제하려는 노드가 단말 노드 일 경우 </li>
                        <li>삭제하려는 노드가 하나의 왼쪽이나 오른쪽 서브 트리 중 하나만 가지고 있는 경우</li>
                        <li>삭제하려는 노드가 두 개의 서브 트리 모두 가지고 있는 경우 </li>
                      </ul>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h> 

typedef int element;
typedef struct TreeNode {
  element key;
  struct TreeNode *left, *right;
} TreeNode;

TreeNode *search(TreeNode *node, int key){
  if ( node == NULL ) return NULL;
  if ( key == node -> key ) return node;
  else if ( key &lt; node -> key )
    return search(node -> left, key);
  else 
    return search(node -> right, key);
}

TreeNode *new_node(int item){
  TreeNode *item = (TreeNode*)malloc(sizeof(TreeNode));

  temp -> key = item;
  temp -> left = temp -> right = NULL;
  return temp;
}

TreeNode *insert_node(TreeNode *node, int key){
  if ( node == NULL ) return new_node(key);

  if( key &lt; node -> key){
    node -> left = insert_node(node -> left, key);
  }else if(key -> node -> key){
    node -> right = insert_node(node -> right, key);
  }

  return node;
}

TreeNode *min_value_node(TreeNode *node){
  TreeNode *current = node;

  while(current -> left != NULL){
    current = current -> left;
  }

  return current;
}

TreeNode *delete_node(TreeNode *root, int key){
  if(root == NULL) return root;
  // 만약 키가 루트보다 작으면 왼쪽 서브 트리에 있는 것임 
  if(key &lt; root -> key){
      root -> left = delete_node(root -> left, key);
  }else if( key > root -> key ){
    // 만약 키가 루트보다 크면 오른쪽 서브 트리에 있는 것임 
    root -> right = delete_node(root -> right, key);
  }else{ // 키가 루트와 같으면 이 노드를 삭제하면 됨 
    // 첫 번째나 두 번째 경우 
    if ( root -> left == NULL ){
      TreeNode *temp = root -> right;
      free(root);
      return temp;
    }else if ( root -> right == NULL){
      TreeNode *temp = root -> left;
      free(root);
      return temp;
    }

    // 세 번째 경우 
    TreeNode *temp = min_value_node(root -> right);

    // 중외 순회시 후계 노드를 복사한다. 
    root -> key = temp -> key;
    // 중외 순회시 후계 노드를 삭제한다. 
    root -> right = delete_node(root -> right, temp -> key);
  }
  return root;
}

void inorder(TreeNode *root){
  if(root){
    inorder(root -> left);
    printf("[%d]", root -> key);
    inorder(root -> right);
  }
}

int main(void){
  TreeNode *root = NULL;
  TreeNode *tmp = NULL;

  root = insert_node(root, 30);
  root = insert_node(root, 20);
  root = insert_node(root, 10);
  root = insert_node(root, 40);
  root = insert_node(root, 50);
  root = insert_node(root, 60);

  printf("이진 탐색 트리 중위 순회 결과 \n");

  inorder(root);

  printf("\n\n");

  if(search(root, 30) != NULL){
    printf("이진 탐색 트리에서 30을 발견함 \n");
  }else{
    printf("이진 탐색 트리에서 30을 발견 못함 \n");
  }

  return 0;
}
                        </code>
                      </pre>

                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading17">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse17" aria-expanded="false" aria-controls="collapse17">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse17" class="collapse" aria-labelledby="heading17" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading18">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse18" aria-expanded="false" aria-controls="collapse18">
                 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse18" class="collapse" aria-labelledby="heading18" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading19">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse19" aria-expanded="false" aria-controls="collapse19">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse19" class="collapse" aria-labelledby="heading19" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading9">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse9" aria-expanded="false" aria-controls="collapse9">
                         
                      </button>
                    </h2>
                  </div>
                  <div id="collapse9" class="collapse" aria-labelledby="heading9" data-parent="#accordionExample">
                    <div class="card-body">

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading1700">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#heading1700" aria-expanded="false" aria-controls="heading1700">
                        
                      </button>                    
                    </h2>
                  </div>
                  <div id="heading1700" class="collapse" aria-labelledby="heading1700" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                  </div>   
              </div>               
            </div>
            <div class="card-footer small text-muted"></div>
          </div>
          
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
    

    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

 

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>
  </body>

</html>

