<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">C ++/C</h6>
            <a class="dropdown-item" href="../cc/cc_001.html">C++ 의 시작</a>
            <a class="dropdown-item" href="../cc/c_001.html">C 의 시작</a>
            <a class="dropdown-item" href="../cc/c_002.html">C 의 기본</a>
            <a class="dropdown-item" href="../cc/c_003.html">자료구조</a>
            <a class="dropdown-item" href="../cc/c_004.html">Redis 분석하기</a>
            <a class="dropdown-item" href="../cc/cc_003.html"></a>
            <a class="dropdown-item" href="../cc/cc_004.html"></a>
            <a class="dropdown-item" href="../cc/cc_005.html"></a>
            <a class="dropdown-item" href="../cc/cc_006.html"></a>
            <a class="dropdown-item" href="../cc/cc_007.html"></a>
            <a class="dropdown-item" href="../cc/cc_008.html"></a>          
            <a class="dropdown-item" href="../cc/cc_009.html"></a>
            <a class="dropdown-item" href="../cc/cc_010.html"></a>
            <a class="dropdown-item" href="../cc/cc_011.html"></a>
            <a class="dropdown-item" href="../cc/cc_012.html"></a>
            <a class="dropdown-item" href="../cc/cc_013.html"></a>
            <a class="dropdown-item" href="../cc/cc_014.html"></a>
            <a class="dropdown-item" href="../cc/cc_015.html"></a>
            <a class="dropdown-item" href="../cc/cc_016.html"></a>
            <a class="dropdown-item" href="../cc/cc_017.html"></a>
            <a class="dropdown-item" href="../cc/cc_018.html"></a>
            <a class="dropdown-item" href="../cc/cc_019.html"></a>
            <a class="dropdown-item" href="../cc/cc_020.html"></a>
            <a class="dropdown-item" href="../cc/cc_021.html"></a>
            <a class="dropdown-item" href="../cc/cc_022.html"></a>
            <a class="dropdown-item" href="../cc/cc_023.html"></a>
            <a class="dropdown-item" href="../cc/cc_024.html"></a>
            <a class="dropdown-item" href="../cc/cc_025.html"></a>
            <a class="dropdown-item" href="../cc/cc_026.html"></a>
            <a class="dropdown-item" href="../cc/cc_027.html"></a>
            <a class="dropdown-item" href="../cc/cc_028.html"></a>
            <a class="dropdown-item" href="../cc/cc_029.html"></a>
            <a class="dropdown-item" href="../cc/cc_030.html"></a>
            <a class="dropdown-item" href="../cc/cc_031.html"></a>
            <a class="dropdown-item" href="../cc/cc_032.html"></a>
            <a class="dropdown-item" href="../cc/cc_033.html">알아두기</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>

          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
                자료구조 
            </div>
            <div class="card-body">
              <div class="accordion" id="accordionExample">
                  <div class="card">
                    <div class="card">
                      <div class="card-header" id="headingThree">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                            시간 복잡도 함수
                          </button>
                        </h2>
                      </div>
                      <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordionExample">
                        <div class="card-body">
                          알고리즘 분석의 2가지 측면
                          <ul>
                            <li>알고리즘 수행 시간 분석 : 시간 복잡도</li>
                            <li>알고리즘이 사용하는 기억 공간 분석 : 공간 복잡도</li>
                          </ul>
                          <hr>
                          <strong>시간 복잡도</strong><br>
                          동일한 조건에서, 똑같은 일을 하는데 알고리즘 A가 30개의 연산을 수행하였고, 알고리즘 B가 300개의 연산을 수행하였다면, 
                          알고리즘 B가 알고리즘 A보다 수행하는 연산의 수가 더 많다. 따라서 알고리즘 A가 효율적인 알고리즘이라고 할 수 있는데, 이것이 시간 복잡도의 기본 개념이다.  
                          <br>
                          연산들의 수행 횟수는 프로그램에서 주어지는 입력의 개수 n에 따라 변하게 된다. 따라서 일반적으로 연산의 수행횟수는 고정된 숫자가 아니라 n에 대한 함수가 된다. 
                          연산의 수를 입력의 개수 n의 함수로 나타낸 것을 시간 복잡도 함수라고 하고 T(n)으로 표기한다. 
                          <hr>
                          <div class="card-group">
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 A</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
sum &lt;- n * n;
                                    </code>
                                  </pre>
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 1회, 나눗셈 연산 1회 => 총 2회 
                              </div>
                            </div>
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 B</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
for i &lt;- 1 to n do  
  sum &lt;- sum + n;
                                    </code>
                                  </pre>
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 n회, 덧셈 연산 n회 => 총 2n회 
                              </div>
                            </div>
                            <div class="card">
                              <div class="card-body">
                                <h5 class="card-title">알고리즘 C</h5>
                                <p class="card-text">
                                  <pre class="C" >
                                    <code>
for i &lt;- 1 to n do 
  for j &lt;- 1 to n do 
    sum &lt;- sum + 1;                                      
                                    </code>
                                  </pre>                                  
                                </p>
                              </div>
                              <div class="card-footer">
                                연산을 기준으로 대입 연산 n*n, 덧셈 연산 n*n => 2n^2 회 
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>  
                    <div class="card">
                      <div class="card-header" id="heading7">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse7" aria-expanded="false" aria-controls="collapse7">
                            빅오 표기법 
                          </button>
                        </h2>
                      </div>
                      <div id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#accordionExample">
                        <div class="card-body">
                          일반적으로 입력의 개수 n과 시간 복잡도 함수 T(n)의 관계는 상당히 복잡할 수 있다. 하지만 자료가 많은 경우에는 차수가 가장 큰 항이 가장 영향을 크게 미치고
                          다른 항들은 상대적으로 무시될 수있다. 
                          예를 들어 <br>
                          <pre class="C" >
                            <code>
T(n) = n^3 + n + 1
                            </code>
                          </pre>
                          위의 항에서 n이 10000일 때, n^3의 값이 전체의 값을 주도한다는 것을 알 수 있다. 따라서 시간 복잡도 함수에서 차수가 가장 큰 항만을 고려하면 충분하다. <br>
                          시간 복잡도 함수 에서 중요한 것은 n이 증가하였을 때, 연산의 총횟수가 n에 비례하여 증가하는지, n^2에 비례하여 증가하는지, 아니면 다른 추세를 가지는지가 더 중요하다. <br>
                          정확한 연산의 개수 보다 알고리즘의 일반적인 증가 추세가 더 중요하다. 2n과 4n + 1의 차이는 n이 커지게 되면 미미하다고 할 수 있다. 따라서 시간 복잡도 함수에서 불필요한 정보를 
                          제거하여 알고리즘 분석을 더욱 쉽게 할 목적으로 시간복잡도를 표시하는 방법을 빅오 표기법이라고 한다. 즉 알고리즘이 n에 비례하는 수행 시간을 가진다고 말하는 대신에 알고리즘 A의 
                          시간 복잡도 합수가 O(n)이라고 한다. 
                          <hr>
                          <div class="alert alert-primary" role="alert">
                            빅오표기법 : 정의 
                            <hr>
                            두 개의 함수 f(n)과 g(n)이 주어졌을 때 모든 n > n0에 대해여 |f(n)| &lt;= c|g(n)|을 만족하는 2개의 상수 c와 n0가 존재하면 f(n)=O(g(n)) 이다. 
                          </div>
                          빅오 표기법에서 중요한 것은 알고리즘의 일반적인 증가 추세가 중요하다는 것이다. 
                          <div class="alert alert-primary" role="alert">
                            빅오 표기법 예제 
                            <hr>
                            f(n)=5이면 O(1)이다. <br>
                            f(n)=2n+1이면 O(n)이다. <br>
                            f(n)=3n^2+100이면 O(n^2)이다. <br>
                            f(n)=5*2^n이면 O(n^2)이다. <br>
                            f(n)=5*2^n+10n^2 + 100이면 O(2^n)이다. <br>
                            f(n)=7n-3이면 O(n) <br>
                            8n^2logn + 5n^2 + n = O(n^2logn) <br>
                          </div>
                          기본 연산의 횟수가 다향식으로 표현되었을 경우 다항식의 최고차항만을 남기고 다른 항들과 상수항을 버리는 것이다. <br>
                          최고 차항의 계수도 버리고 단치 최고차항의 차수만을 이용한다. 
                          <hr>
                          <ul>
                            <li>O(1) : 상수형</li>
                            <li>O(logn) : 로그형</li>
                            <li>O(n) : 선형</li>
                            <li>O(nlogn) : 선형 로그형</li>
                            <li>O(n^2) : 2차형 </li>
                            <li>O(n^3) : 3차형</li>
                            <li>O(2^n) : 지수형</li>
                            <li>O(n!) : 팩토리얼형</li>
                          </ul>
                          <hr>
                          또한 위의 순서대로 알고리즘의 수행시간에 걸리는 순서도 같이 확인할 수 있다. 
                          아래로 내려가면 갈수록 걸리는 시간이 커진다. 
                          <hr>
                          <img src="./bigograph.PNG" class="img-fluid" alt="" srcset="">
                          <hr>
                          빅오 표기법 이외의 표기법
                          <hr>
                          <ul>
                            <li>빅오메가 표기법 : 어떤 함수의 하한을 표기하는 방법 </li>
                            <li>빅세타 표기법 : 동일한 함수로 상한과 하한을 만들 수 있는 경우 </li>
                          </ul>
                          표기법 중에 가장 정밀한 것은 빅세타 표기법이다. 
                          <hr>
                          똑같은 알고리즘도 주어지는 입력의 집합에 따라 다른 수행 시간을 보일 수 있다. 즉 특정한 자료 집합이 주어지면 다른 자료 집합보다 더 빨리 수행할 수 있다. 
                          <ul>
                            <li>최악의 경우는 자료집합 중에서 알고리즘의 수행시간이 가장  오래 걸리는 경우이다. </li>
                            <li>최선의 경우는 수행시간이 가장 적은 경우이다. </li>
                            <li>평균적인 경우는 알고리즘의 모든 입력 고려하고 각 입력이 발생하는 확률을 고려하여 평균적인 수행시간이 의미한다. </li>
                          </ul>
                          <hr>
                          우리가 구하려는 데이터의 자료구조에 따라 빅오 표기법의 복잡도가 상이해질 수 있는데, 아래의 코드를 보면 
                          <pre class="C" >
                            <code>
// 최선의 경우는 찾고자 하는 숫자가 배열의 맨 처음에 있는 경우이다. 따라서 빅오 표기법은 O(1)
// 최악의 경우는 찾고자 하는 숫자가 맨 마지막이 있는 경우이다. 따라서 빅오 표기법으로는 O(n)
int seq_search(int list[], int key ){
  int i;
  for ( i = 0; i&lt; n ; i ++){
    if(list[i] == key){
      return i;
    }
  }
}
                            </code>
                          </pre>
                        </div>
                      </div>
                    </div> 
                    
                <div class="card">
                  <div class="card-header" id="heading10">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse10" aria-expanded="false" aria-controls="collapse10">
                        순환 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse10" class="collapse" aria-labelledby="heading10" data-parent="#accordionExample">
                    <div class="card-body">
                      어떤 알고리즘이나  함수가 자기 자신을 호출하여 문제를 해결하는 프로그래밍 기법이다. 
                      <hr>
                      <strong>순환의 예</strong>
                      순환은 본질적으로 순환적인 문제나 그러한 자료구조를 다루는 프로그램에 적합하다. 
                      <pre class="C" >
                        <code>
int factorial(int n){
  if( n &lt;= 1) return(1);
  else return (n*factorial(n-1))
}                     

// 위의 코드를 아래의 Factorial 기준대로 정의하는 방법 

/*
  factorial(3) = 3 * factorial(2);
               = 3 * 2 * factorial(1);
               = 3 * 2 * 1
               = 3 * 2
               = 6
*/
                        </code>
                      </pre>
                      <hr>
                      <strong>순환의 동작 원리</strong>
                      <hr>
                      순환을 이해하기 위하여 먼저 함수 호출의 과정을 살펴보면, 프로그래밍 언어에서 하나의 함수가 자기 자신을 다시 호출하는 것은 다름 함수를 호출하는 것과 동일하다. 즉 복귀 주소가 시스템 스택에 저장되고
                      호출되는 함수를 위한 매개변수와 지역 변수를 스택으로부터 할당 받는다. 이러한 함수를 위한 시스템 스택에서의 공간을 활성 레코드라 한다. 이러한 준비가 끝나면 호출된 함수의 시작위치로 점프하여 수행을 시작한다. 
                      만약 호출한 함수가 끝나게 되면 시스템 스택에서 복귀주소를 추출하여 호출한 함수로 되돌아가게 된다. 
                      <hr>
                      <strong>순환 알고리즘의 구조</strong>
                      <pre class="C" >
                        <code>
int factorial( int n )
{
  if ( n &lt;= 1 ) return (1);

  return ( n * factorial(n-1));
}
                        </code>
                      </pre>
                      <hr>
                      <strong>순환 &lt;-> 반복</strong>
                      <hr>
                      반복이란 for나 while 등의 반복구조로 되풀이 하는 방법이다. 반복을 제어하는 변수를 사용하여 일정횟수 동안 반복 시킬수도 있고 어떤 조건이 만족될 때까지 반복시킬 수도 있다. 
                      반복은 간명하고 효율적으로 되풀이를 구현하는 방법이다. 
                      반면에 때로는 반복을 사용하게 되면 지나치게 복잡해지는 문제들도 존재한다. 이런 경우에는 순환이 좋은 해결책이 될 수 있다. 순환은 주어진 문제를 해결하기 위하여 자신을 다시 호출하여 
                      수행하는 방식이다. 순환은 본질적으로 순환적인 문제나 그러한 자료구조를 다루는 프로그램에 적합하다. 
                      <br>
                      문제의 크기가 순환이 진행될수록 작아지는 것에 유의해야 한다. 
                      <br>
                      기본적으로 반복과 순환은 문제 해결 능력이 같으며 많은 경우에 순환 알고리즘을 반복 버전으로 , 반복 알고리즘을 순환 버전으로 바꾸어 쓸 수 있다. 특히 순환 호출이 끝에서 이루어지는 순환을 꼬리 순환이라고 하는데, 
                      이를 반복 알고리즘으로 쉽게 바꾸어 쓸 수 있다. 
                      <hr>
                      <strong>순환의 원리</strong>
                      <hr>
                      분할 정복 : 주어진 문제를 더 작은 동일한 문제들로 분해하여 해결하는 방법을 분할 정복이라 한다. <br>
                      순환은 알고리즘 정의가 순환적으로 되어 있는 경우에 유리한 방법이다. 예를 들어 팩토리얼 함수 계산, 피보나치 수열, 이항계수 계산, 이진 트리 알고리즘, 이진 탐색, 하노이 탑 문제들은 순환 알고리즘을 쓰는 것이 자연스러운 알고리즘이다. 
                      <hr>
                      <strong>순환 알고리즘의 성능</strong><br>
                      순환 알고리즘과 반복 알고리즘의 시간 복잡도는 같지만 순환 호출의 경우 여분의 기억공간이 더 필요하고 또한 함수를 호출하기 위해서는, 함수의 매개변수들을 
                      스택에 저장하는 것과 같은 사전 작업이 상당히 필요하다. 따라서 수행시간도 더 걸린다. 결론적으로 순환 알고리즘은 이해하기 쉽다는 것과 쉽게 프로그램 할 수 있다는 장점이 있는 
                      대신 수행 시간과 기억 공간의 사용에 있어서는 비효율적인 경우가 많다. 
                      <hr>
                      거듭제곱 값 계산 
                      <pre class="C" >
                        <code>
// 반복에 의한 방식                           
double slow_power(double x, int n){
  int i;
  double result = 1.0;

  for( i = 0; i &lt; n; i ++ ){
    return = result * x;
    return (result);
  }
}
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
// 순환에 의한 방식      
// 한번의 호출 할 때마다 문제의 크기는 약 절반으로 줄어든다.                      
power(x , n) : 
  if n == 0 
    then return 1;
  else if n이 짝수 
    then return power(x^2, n/2);
  else if n이 홀수 
    then return x * power(x^2, (n-1)/2);
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
// 순환적인 거듭 제곱 계산 
// 순환을 사용하게 되면 단순하게 작성이 가능하며 가독성이 높아진다. 그러나 똑같은 계산을 몇번씩 반복한다면 아주 단순한 경우라 할지라도 
// 계산 시간이 엄청나게 길어질 수 있다. 
double power(double x, int n ){
  if ( n == 0) return 1;
  else if ( (n%2) == 0) 
    return power(x*X, n/2 )
  else return x * power(x*x, (n-1)/2);
}
                        </code>
                      </pre>
                      <hr>
                      <strong>피보나치 수열</strong> <br>
                      <img src="./pibonacci_sequence.PNG" class="img-thumbnail" alt="" srcset=""> <br>
                      피보나치 수열은 이탈리아 수학자가 발견한 수열로서 한 쌍의 토끼가 번식하는 상황을 수열로 만든 것이다. 
                      <br>
                      <pre class="C" >
                        <code>
// 순환적인 피보나치 수열 계산
int fib(int n){
  if ( n == 0) return 0;
  if ( n == 1) return 1;
  return ( fib(n-1) + fib(n-2));
}
                        </code>
                      </pre>
                      위의 코드는 단순하고 이해하기 쉽지만 굉장히 비효율 적인 코드이다. 
                      fib(6)을 구하기 위해서  fib() 함수가 25번이나 호출되는 것에 유의해야 한다. 근본적인 이유는 중간에 계산되었던 값을 기억하지 않고 
                      다시 계산하기 때문이다. 
                      <br>
                      T(n) = T(n-1) + T(n-2) + C 의 순환적인 수식을 이용하면 시간 복잡도 O(2^n)이 도출된다. 
                      이것은 O(2^n)의 복잡도 패턴이라 할 수 있다. 
                      피보나치 수열을 계산하는데 순환을 사용하는 것이 아닌 반복을 사용하게 되면 제일 좋은 결과를 얻을 수 있었다. 
                      <pre class="C" >
                        <code>
int fib_iter(int n){
  if ( n == 0 ) return 0;
  if ( n == 1 ) return 1;

  int pp = 0;
  int p = 1;
  int result = 0;

  for( int i = 2 ; i &lt; n; i ++){
    result = p + pp;
    pp = p;
    p = result;
  }
  return result 
}
                        </code>
                      </pre>
                      <hr>
                      <strong>하노이 탑</strong>
                      순환의 사용에 가장 적합한 예제가 바로 하노이 탑 문제이다. <br>
                      하노의 탑을 해결하기 위한 알고리즘 <br>
                      <pre class="C" >
                        <code>
// 막대 from에 쌓여있는 n개의 원판을 막대 tmp를 사용하여 막대  to로 옮긴다. 
void hanoi_tower(int n, char from, char tmp, char to ){
  if ( n == 1) {
    from에 있는 한 개의 원판을 to로 옮긴다. 
  } else {
    1. from의 맨 밑의 원판을 제외한 나머지 원판을 tmp로 옮긴다. 
    2. from에 있는 한 개의 원판을 to로 옮긴다. 
    3. tmp의 원판들을 to로 옮긴다. 
  }
}

// 코드 예제
#include &lt;stdio.h>
void hanoi_tower( int n , char from, char tmp, char to ){
  if ( n ==  1) printf("원판 1을 %C에서 %c으로 옮긴다. \n" , from, to );
  else {
    hanoi_tower( n - 1, from, to tmp );
    printf("원판 %d 을 %C에서 %c으로 옮긴다. \n" , from, to );
    hanoi_tower( n - 1, tmp, from, to );
  }
}

int main(void){
  hanoi_tower( 4, 'A' , 'B' , 'C');
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <pre class="C" >
                        <code>
//  순환 호출이 맨끝에서 이루어지는 형태의 순환으로, 꼬리 순환의 경우, 알고리즘은 쉽게 반복적인 형태로 변환이 가능하다.                           
return n*factorial(n - 1);

// 머리 순환(head recursion)의 경우나 방금 살펴본 하노이 탑의 문제 처럼 여러 군데에서 자기 자신을 호출하는 경우는 쉽게 반복적인 코드로 바꿀 수 없다. 
return factorial(n - 1)*n;
                        </code>
                      </pre>

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading11">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse11" aria-expanded="false" aria-controls="collapse11">
                        배열, 구조체, 포인터 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse11" class="collapse" aria-labelledby="heading11" data-parent="#accordionExample">                        
                    <div class="card-body">
                      <strong>배열</strong><br>
                      <pre class="C" >
                        <code>
객체 : &lt; 인덱스, 값 > 쌍의 집합 
연산 : 
  - create(size) ::= size개의 요소를 저장할 수 있는 배열 생성 
  - get(A, i) ::= 배열 A의 i 번째 요소 반환. 
  - set(A, i, v) ::= 배열 A의 i 번째 위치에 값 v 저장. 
                        </code>
                      </pre>
                      컴파일러에서 배열 요소에 대한 메모리 주소 구현 방식 <br>
                      <ul>
                        <li>list[0] : 기본주소=base</li>
                        <li>list[1] : base + 1*sizeof(int)</li>
                        <li>...</li>
                      </ul>
                      우리가 프로그램에서 list[i]라고 적으면 컴파일러는 주소 base + i*sizeof(int)에 있는 값을 가져온다. 
                      <hr>
                      <strong>구조체</strong><br>
                      복잡한 객체에는 다양한 타입의 데이터들이 한데 묶여져서 있다. 배열이 타입이 같은 데이터의 모임이라면 구조체는 타입이 다른 데이터를 묶는 방법이다. <br>
                      <pre class="C" >
                        <code>
struct 구조체이름 {
  항목1;
  항목2;
  ...
}

// 구조체 변수 선언 방식 
struct 구조체이름 구조체변수;
                        </code>
                      </pre>
                      <pre class="C" >
                        <code>
#include &lt;stdio.h>

typedef struct studentTag {
  char name[10];
  int age;
  double gpa;
} student; 

int main(void) {
  student a = { "kim", 30, 4.3 };
  student b = { "park", 21, 4.2 };
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>배열의 응용  : 다항식</strong><br>
                      <ul>
                        <li>
                          <strong>첫번째 방법</strong><br>
                          <pre class="C" >
                            <code>
10x^5 + 0 * x^4 + 0 * x^3 + 0 * x^2 + 6 * x + 3 


#define MAX_DEGREE 101 

typedef struct {
  int degree;
  float coef[MAX_DEGREE];
} polynomial 

polynomial a = { 5, { 10, 0 , 0, 0, 6 , 3}}
                            </code>
                          </pre>
                        </li>
                        <li>
                          <strong>두번째 방법</strong><br>
                          <pre class="C" >
                            <code>
#define MAX_TERMS 101

typedef struct {
  float coef;
  int expon;
} terms[MAX_TERMS];
int avail; 

terms[MAX_TERMS] = {{ 8,3 }, { 7,1 } , { 1, 0 } , { 10, 3 } , { 3 , 2 } , { 1 , 0 } }
                            </code>
                          </pre>
                        </li>
                        <li>
                          <strong>희소 행렬</strong><br>
                          <pre class="C" >
                            <code>
// 희소 행렬의 표현 방법 #1
#define MAX_ROWS 100
#define MAX_COLS 100
int matrix[MAX_ROWS][MAX_COLS];


// 희소 행렬의 표현방법 #2
struct matrix {
  int x,
  int y, 
  char value
}

int main(){
  struct matrix m[100] = { { .x = 1 , .y= 1 , .value = 'G' }, ... }
}
                            </code>
                          </pre>
                        
                        </li>
                        <li>
                          <strong>전치 행렬 계산법</strong>
                          <pre class="C" >
                            <code>
#define ROWS 3
#define COLS 3

// 행렬 전치 함수 - 첫번째 방식 
void matrix_transpose(int A[ROWS][COLS], int B[ROWS][COLS]){
  for ( int r = 0 ; r &lt; ROWS ; r ++){
    for ( int c = 0 ; c &lt; COLS ; c ++){
      B[c][r] = A[r][c];
    }
  }
}

// 행렬 전치 함수 - 두번째 방식 
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_TERMS 100
typedef struct {
  int row;
  int col;
  int value;
}

typedef struct SparseMatrix {
  element data[MAX_TERMS];
  int rows;
  int cols;
  int terms;
} SparseMatrix;

SparseMatrix matrix_transpose2(SparseMatrix a){
  SparseMatrix b;

  int bindex;
  b.rows = a.rows;
  b.cols = a.cols;
  b.terms = a.terms;

  if(a.terms > 0){
    bindex = 0;
    for ( int c = 0 ; c &lt; a.cols ; r ++){
      for ( int i = 0 ; i &lt; a.terms ; i ++){
        if(a.data[i].col == c){
          b.data[bindex].row = a.data[i].col;
          b.data[bindex].col = a.data[i].row;
          b.data[bindex].value = a.data[i].value;
        }
      }
    }
  }
  return b;
}
                            </code>
                          </pre>
                        </li>
                      </ul>
                      <strong>Pointer</strong><br>
                      포인터는 다른 변수의 주소를 가지고 있는 변수이다. 모든 변수는 메모리 공간에 저장되고 메모리의 각 바이트에는 주소가 매겨져 있다. 
                      이 주소가 포인터에 저장된다. 주소는 컴퓨터에 따라 다를 수 있으므로 포인터 변수는 정확한 숫자보다는 그냥 화살표로 그려진다. 
                      <ul>
                        <li>널 포인터</li>
                        <li></li>
                      </ul>
                      배열과 포인터의 관계 : 배열의 이름은 배열의 시작부분을 가리키는 포인터이다. <br>
                      배열의 이름이 점선으로 그려져 있는 이유는 실제로 컴파일러가 배열의 이름에 공간을 할당하지는 않기 때문이다. 대신에 배열의 이름이 있는 곳을 배열의 첫번째 요소의 
                      주소로 대치한다. 따라서 배열의 이름이 포인터이기 때문에 배열이 함수의 매개변수로 전달 될 때 사실을 포인터가 전달되는 것이다. 
                      <hr>
                      <strong>동적 메모리 할당</strong>
                      <pre class="C" >
                        <code>
int *p;
// malloc() 함수가 반환했던 포인터 값을 잊어버리면 안된다는 것이다. 포인터 값을 잊어버리면 동적 메모리를 반환할 수 없다. 
// malloc()은 시스템의 메모리가 부족해서 요구된 메머리를 할당할 수 없으면 NULL을 반환한다. 
p = ( int * )malloc(sizeof(int));
*p = 1000;
free(p);                          
                        </code>
                      </pre>
                      동적 메모리가 할당되는 공간을 히프라고 한다. 히프는 운영체제가 사용되지 않는 메모리 공간을 모아 놓은 곳이다. 필요한 만큼 할당을 받고 또 필요한 대에 사용하고 반납하기 때문에 
                      메모리를 매우 효율적으로 사용할 수 있다. 
                      <hr>
                      <strong>구조체와 포인터</strong><br>
                      우리는 구조체에 포인터를 선언하고 포인터를 통하여 구조체 멤버에 접근할 수 있다. 여기에서 하나 주의할 것은 포인터를 통하여 구조체의 멤버에 접근하는 편리한 표기법 "->"이다. <br>
                      <pre class="C" >
                        <code>
// (*ps).i 보다 ps -> i 라고 쓰는 것이 더 편리하다. 

typedef struct studentTag {
  char name[10];
  int age;
  double gpa;
} student;

int main(void) {
  student s*;

  s = (student *)malloc(sizof(student));
  if ( s == NULL ){
    fprintf(stderr, "메모리가 부족해서 할당할 수 없습니다. \n");
    exit(1);
  } 

  strcpy(s -> name,  "Park");
  s -> age = 20;

  free(s);
  return 0;
}

                        </code>
                      </pre>

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading13">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse13" aria-expanded="false" aria-controls="collapse13">
                        스택   
                      </button>
                    </h2>
                  </div>
                  <div id="collapse13" class="collapse" aria-labelledby="heading13" data-parent="#accordionExample">
                    <div class="card-body">
                      스택에서의 입출력은 맨 위에서만 일어나고 스택의 중간에서는 데이터를 삭제할 수 없다. 
                      스택에서 입출력이 이루어지는 부분을 스택 상단이라고 하고 반대쪽인 바닥부분을 스택 하단이라고 한다. 스택에 저장되는 것을 요소라 부른다. 
                      <hr>
                      후입 선출 ( LIFO : Last In First Out )
                      <hr>
                      함수는 실행이 끝나면 자신을 호출한 함수로 되돌아가야한다. 이때 스택이 사용되는데, 즉 복귀할 주소를 기억하는데 사용된다. 
                      <hr>
                      추상 자료형 스택 
                      <pre class="C" >
                        <code>
- 객체 : 0개 이상의 원소를 가지는 유한 선형 리스트 
- 연산 : 
  create(size)  ::= 최대크키가 size인 공백 스택을 생성한다. 
  is_full(s) ::= 
    if(스택의 원소수 == false) return TRUE;
    else return FALSE;
  is_empty(s)   ::= 
    if(스택의 원소수 == 0) return TRUE;
    else return FALSE;
  push(s, item) ::=
    if( is_full(s) ) retirm ERROR_STACKFULL;
    else 스택의 맨 위에 item을 추가한다. 
  pop(s) ::=
    if ( is_empty(s) ) return ERROR_STACKEMPTY;
    else 스택의 맨 위의 원소를 제거해서 반환한다.
  peeck(s) ::=
    if( is_empty(s) ) return ERROR_STACKEMPTY;
    else 스택의 맨 위의 원소를 제거하지 않고 반환한다.                          

                        </code>
                      </pre>
                      Stack은 기본적으로 Push와 Pop의 두가지 연산으로 이루어져있고, 실제 Stack에서 허용하는 Item 갯수가 가득찼는지 pop을 했을 때 더 빼낼 아이템이 없는지를
                      체크하기 위한 Validation이 존재한다. 
                      <hr>
                      <strong>스택의 구현</strong><br>
                      <pre class="C" >
                        <code>
is_empty(S):
  if top == -1
    then return TRUE
    then return FALSE 

is_full(S):
  if top >= ( MAX_STACK_SIZE )
    then return TRUE 
    then return FALSE 

// push에서는 먼저 top의 값을 증가하는 것에 유의하라. top이 가리키는 위치는 마지막으로 삽입되었던 요소이므로 top을 증가시키지 않고 삽입하면 마지막 요소가 지워지게 된다. 
push(S,x):
  if is_full(S)
    then error "overflow"
    else top &lt;- top + 1
         stack[top] &lt;- x

// pop 연산은 스택에서 하나의 요소를 제거하는 여산으로 top이 가리키는 요소를 스택에서 꺼내어 외부로 건네주는 연산이다. 
// 먼저 요소를 제거하기 전에 스택이 비어있는지 검사행한다. 
pop(S, x) :
  if is_empty(S)
    then error "underflow"
    else e &lt;- stack[top]
        top &lt;- top-1
        return e
                        </code>
                      </pre>
                      <hr>
                      <strong>전역변수를 이용하여 구현하는 방법</strong>  
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

// 스택이 전역 변수로 구현된다. 
#define MAX_STACK_SIZE 100
typedef int element;
element stack[MAX_STACK_SIZE];
int top = -1;

// 공백 상태 검출 함수 
int is_empty()
{
  return ( top == -1 );
}

// 포화 상태 검출 함수 
int is_full()
{
  return ( top == ( MAX_STACK_SIZE - 1));
}

// 삽입 함수 
void push(element item){
  if(is_full()){
    fprintf(stderr, "스택 포화 에러\n");
    return;
  }
  else stack[++top] = item;
}

// 삭제 함수 
element pop(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return stack[top--];
}

// 피크함수 
element peek(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return statck[top];
}

int main(void){
  push(1);
  push(2);
  push(3);
  printf("%d\n", pop());
  printf("%d\n", pop());
  printf("%d\n", pop());
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택의 요소를 구조체로 하기 </strong><br>
                      <pre class="C" >
                        <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_STACK_SIZE 100
#defind MAX_STRINC 100

typedef stuct {
  int student_no;
  char name[MAX_STRING];
  char address[MAX_STRING];
} element;

element stack[MAX_STACK_SIZE];
int top = -1;

// 공백 상태 검출 
int is_empty(){
  return ( top == -1);
}

// 포화 상태 검출 함수 
int is_full(){
  return ( top == (MAX_STACK_SIZE - 1));
}

// 삽입 함수 
void push(element itme){
  if(is_full()){
    fprintf(stderr, "스택 포화 에러\n");
    exit(1);
  }
  else stack[++top] = item;
}

// 삭제 함수 
element pop(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러 \n");
    exit(1);
  }
  else return stack[top--];
}

// 피크 함수 
element peek(){
  if(is_empty()){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return stack[top];
}

int main(void){
  element ie = {
    20190001,
    "Hong",
    "Seoul"
  };

  element oe;

  push(ie);
  oe = pop();

  printf("학번 : %d\n", oe.student_no);
  printf("이름 : %d\n", oe.name);
  printf("주소 : %d\n", oe.address);

  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>함수의 매개변수로 전달하는 방법</strong>
                      <hr>
                      <pre>
                        <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

// 차후에 스택이 필요하면 여기만 복사하여 붙인다. 
// ===== 스택 코드의 시작 =====
#define MAX_STACK_SIZE 100

typedef int element;
typedef struct {
  element data[MAX_STACK_SIZE];
  int top;
} StackType;


// 스택 초기화 함수 
void init_stack(StackType *s){
  return ( s -> top == -1);
}

// 공백상태 검출 함수
int is_empty(StackType *s){
  return ( s -> top == -1);
}

// 포화 상태 검출 함수 
int is_full(StackType *s){
  return ( s -> top == ( MAX_STACK_SIZE - 1));
}

// 삽입함수 
void push(StackType *s, element item){
  if(is_full(s)){
    fprinf(stderr, "스택 포화 에러\n");
    return;
  }
  else{
    s -> data[++(s-> top)] = item;
  }
}

// 삭제함수 
element pop(StackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return s->data[(s->top)X-UA-Compatible]
}

// 피크함수 
element peek(StackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return s ->data[s->top];
}
// ===== 스택 코드의 끝 =====

// C언어에서의 함수 매개변수 전달 방식이 기본적으로 Call By Value이기 때문에, 구조체를 함수의 매개변수로 전달하는 경우, 구조체의 원본이 전달되는 것이 아니라 구조체의 복사본이 전달된다. 
// 따라서 함수 안에서는 복사본을 수정하여도 원본에는 영향을 주지 못한다. 그러나 원본에 대한 포인터를 전달하면 원본을 변경할 수 있다. 

int main(void){
  StackType s;

  init_stack(&s);
  push(&s, 1);
  push(&s, 2);
  push(&s, 3);
  printf("%d\n", pop(&s));
  printf("%d\n", pop(&s));
  printf("%d\n", pop(&s));
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택을 동적할 메모리 할당으로 생성</strong>
                      <pre class="C" >
                        <code>
int main(void){
  StackType *s;
  s = (StackType *)malloc(sizeof(StackType));
  init_stack(s);
  push(s, 1);
  push(s, 2);
  push(s, 3);
  printf("%d\n", pop(s));
  printf("%d\n", pop(s));
  printf("%d\n", pop(s));
  free(s);
}
                        </code>
                      </pre>
                      <hr>
                      <strong>동적배열스택</strong>
                      <hr>
                      <pre class="C" >
                        <code>
typedef int element;
typedef struct {
  element *data;
  int capacity;
  int top;
} StackType;

// 스택 생성 함수 
void int_stack(StackType *s){
  s -> top = -1;
  s -> capacity = 1;
  s -> data = (element *)malloc(s -> capacity*sizeof(element));
}

// 스택 삭제 함수 
void delete(StackType *s){
  free(s);
}

void push(StackType *s, element item){
  if(is_full(s)){
    s -> capacity *= 2;
    s -> data = (element *)realloc(s->data, s->capacity * sizeof(element));
  }
  s -> data[++(s->top)] = item;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>동적 배열 스택 프로그램</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_STACK_SIZE 100

typedef int element;
typedef struct {
  element *data;
  int capacity;
  int top;
} StackType;

// 스택 생성 함수 
void init_stack(StackType *s){
  s -> top = -1;
  s -> capacity = 1;
  s -> data = (element *)malloc(s -> capacity * sizeof(element));
}

// 공백 상태 검출 함수 
int is_empty(StackType *s){
  return ( s -> top == -1 );
}

// 포화상태 검출 함수 
int is_full(StackType *s)
{
  return ( s -> top == (MAX_STACK_SIZE -1 ));
}

void push(StackType *s, element item){
  if(is_full(s)){
    s -> capacity *= 2;
    s -> data = ( element *)realloc(s -> data, s -> capacity * sizeof(element));
  }
  s -> data[++(s->top)] = item;
}

// 삭제 함수 
element pop(StackType *s){
  if(is_empty(s)){
    fprintf(stderr, "스택 공백 에러\n");
    exit(1);
  }
  else return s -> data[(s->top)--];
}

int main(void){
  StackType s;
  init_stack(&s);
  push(&s, 1);
  push(&s, 2);
  push(&s, 3);
  printf("%d \n", pop(&s));
  printf("%d \n", pop(&s));
  printf("%d \n", pop(&s));
  free(s.data);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택의 활용 : 괄호 검사 문제 </strong>
                      <hr>
                      <ul>
                        <li>왼쪽 괄호의 개수와 오른쪽 괄호의 개수가 같아야 한다.</li>
                        <li>같은 종류의 괄호에서 왼쪽 괄호는 오른쪽 괄호보다 먼저 나와야 한다.</li>
                        <li>서로 다른 종류의 왼쪽 괄호와 오른쪽 괄호 쌍은 서로를 교차하면 안된다.</li>
                      </ul>
                      <pre>
                        <code class="C" >
check_matching(expr);

while(입력 expr의 끝이 아니면)
ch &lt;- expr의 다음 글자 
switch(ch)
    case '(' : case '[' : case '{' :
        ch를 스택에 삽입 
        break
    case ')' : case ']' : case '}' :
        if ( 스택이 비어 있으면 )
            then 오류 
            else 스택에서 open_ch 를 꺼낸다
                if ( ch와 open_ch가 같은 짝이 아니면 )
                    then 오류 보고 
    break
if( 스택이 비어 있지 않으면 )
    then 오류                                           
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#define MAX_STACK_SIZE 100

typedef char element;
element stack[MAX_STACK_SIZE];

int check_matching(const char *in){
  StackType s;
  char ch, open_ch;
  int i, n = strlen(in);
  init_stack(&s);

  for ( i = 0; i &lt; n ; i ++){
    ch = in[i];
    switch(ch){
      case '(' : case '[' : case '{' :
        push(&s, ch);
        break;
      case ')' : case ']' : case '}' :
        if(is_empty(&s)) return 0;
        else {
          open_ch = pop(&s);
          if((open_ch == '(' && ch != ')' ) ||
            (open_ch == '[' && ch != ']' ) ||
            (open_ch == '{' && ch != '}' ) 
          ){
            return 0;
          }
          break;
        }  
    }
  }
  if(!is_empty(&s)) return 0;
  return 1;
}

int main(void){
  char *p = "{ A[(i+1)]=0; }";
  if(check_matching(p) == 1)
    printf("%s 괄호검사성공\n", p);
  else 
    printf("%s 괄호검사실패\n", p);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>스택의 응용 : 후위 표기 수식의 계산</strong>
                      <hr>
                            
                      <pre>
                        <code class="C" >
calc_posfix:
    스택 s를 생성하고 초기화한다. 
    for item in 후위표기식 do 
        if ( item이 피연산자이면 )
            push(s, item)
        else if ( item이 연산자 op이면 )
            second &lt;- pop(s)
            first &lt;- pop(s)
            result &lt;- first op second // op 는 +-*/ 중의 하나 
            push(s, result)
        final_result &lt;- pop(s);                                  
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#incldue &lt;stdlib.h>
#define MAX_STACK_SIZE 100

typedef char element;

int eval(char exp[]){
  int op1, op2, value , i = 0;
  int len = strlen(exp);
  char ch;
  StackType s;

  init_stack(&s);
  for( i = 0; i &lt; len ; i ++){
    ch = exp[i];
    if( ch != '+' && ch != '-' && ch != '*' && ch != '/' ){
      value = ch - '0';
      push(&s, value);
    }else {
      op2 = pop(&s);
      op1 = pop(&s);
      switch ( ch ) {
        case '+' : push(&s, op1 + op2); break;
        case '-' : push(&s, op1 - op2); break;
        case '*' : push(&s, op1 * op2); break;
        case '/' : push(&s, op1 / op2); break;
      }
    }
  }
  return pop(&s);
}

int main(void){
  int result;
  printf("후위표기식은 82/3-32*+\n");
  result = eval("82/3 - 32 *+");
  printf("결과값은 %d\n", )
}
                        </code>
                      </pre>
                      <hr>
                      <strong>중위 표기 수식을 후위 표기 수식으로 전환</strong>
                      <hr>
                      <pre>
                        <code class="c">
infix_to_postfix(exp);

스택 s를 생성하고 초기화 
while ( exp에 처리할 문자가 남아 있으면 )
    ch &lt;- 다음에 처리할 문자 
    switch ( ch )
    case 연산자 : 
        while ( peek(s)의 우선순위 >= ch의 우선순위 ) do 
            e &lt;- pop(s)
            e를 출력 
        push(s, ch);
        break;
    case 왼쪽 괄호 : 
        push(s, ch);
        break;
    case 오른쪽 괄호 : 
        e &lt;- pop(s);
        while( e != 왼쪽괄호 ) do 
            e를 출력 
            e &lt;- pop(s);
        break;
    case 피연산자 : 
        ch를 출력
        break;

while( not is_empty(s) ) do 
    e &lt;- pop(s)
    e를 출력 
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#incldue &lt;stdlib.h>
#define MAX_STACK_SIZE 100

typedef char element;

int prec(char op)
{
  switch(op) {
    case '(' : case ')' : return 0;
    case '+' : case '-' : return 1;
    case '*' : case '/' : return 2;
  }
  return -1;
}

void infix_to_postfix(char exp[]){
  int i = 0;
  char ch, top_op;
  int len = strlen(exp);
  StackType s;

  init_stack(&s);
  for ( i = 0; i &lt; len; i ++){
    ch = exp[i];
    switch(ch) {
      case '+' : case '-' : case '*' : case '/' : 
        while ( !is_empty(&s) && (prec(ch) &lt;= prec(&s)))
          prinf("%sc", pop(&s));
        push(&s, ch);
        break;
      case '(' :
        push(&s, ch);
        break;
      case ')' :
        top_op = pop(&s);
        while ( top_op != '('){
          printf("%c", top_op);
          top_op = pop(&s);
        }
        break;
      default:
        printf("%c", pop(&s));
        break;
    }
  }
  while( !is_empty(&s))
    printf("%c", pop(&s));
}

init main(void){
  char *s = "(2+3)*4+9";
  printf("중위 표시 수식  %s \n", s);
  printf("후위 표시 수식 ");
  infix_to_postfix(s);
  printf("\n");
}
                        </code>
                      </pre>
                      <hr>
                      <strong>미로 탐색 프로그램</strong>
                      <hr>
                      <pre>
                        <code class="C" >
maze_search();

스택 s과 출구의 위치 x, 현재 생쥐의 위치를 초기화 
while( 현재의 위치가 출구가 아니면 ) do 
    현재 위치를 방문한 것으로 표기 
    if( 현재위치의 위, 아래, 왼쪽, 오른쪽 위치가 아직 방문되지 않았고 갈 수 있으면 )
        then 그 위치들을 스택에 push 
    if( is_empty(s) )
        then 실패 
    else 스택에서 하나의 위치를 꺼내어 현재 위치로 만든다. 
성공;                           
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>
#define MAX_SIZE 6

typedef struct {
  short r;
  short c;
} element;

element here = { 1, 0}, entry = { 1, 0 };

void push_loc(StackType *s, int r, int c){
  if( r &lt; 0 || c &lt; 0) return;
  if( maze[r][c] != '1' && maze[r][c] != '.' ) {
    element tmp;
    tmp.r = r;
    tmp.c = c;
    push(s, tmp);
  }
}

void maze_print(char maz[MAZE_SIZE][MAZE_SIZE]){
  print("\n");
  for( int r = 0; r &lt; MAZE_SIZE; r++){
    for( int c = 0; c &lt; MAZE_SIZE; c++){
      print("%c", maze[r][c]);
    }
    printf("\n");
  }
}

int main(void){
  int r,c;
  StackType s;

  init_stack(&s);
  here = entry;
  while ( maze[here.r][here.c] != 'x'){
    r = here.r;
    c = here.c;
    maze[r][c] = '.';
    maze_print(maze);
    push_loc(&s. r - 1, c);
    push_loc(&s. r + 1, c);
    push_loc(&s. r , c - 1);
    push_loc(&s. r , c + 1);
    if(is_empty(&s)){
      printf("실패\n");
      return;
    }
    else 
      here = pop(&s);
  }
  printf("성공\n");
  return 0;
}
                        </code>
                      </pre>
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading14">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse14" aria-expanded="false" aria-controls="collapse14">
                        큐
                      </button>
                    </h2>
                  </div>
                  <div id="collapse14" class="collapse" aria-labelledby="heading14" data-parent="#accordionExample">
                    <div class="card-body">
                      스택의 경우, 나중에 들어온 데이터가 먼저 나가는 구조인데 반하여 큐는 먼저 들어온 데이터가 먼저 나가는 구조로 이러한 특성을 선입선출(First In First Out)이라고 한다. 
                      <hr>
                      <strong>ADT : 큐</strong>
                      <hr>
                      <pre>
                        <code class="C" >
객체 : 0개 이상의 요소들로 구성된 선형 리스트 

연산 : 
    create(max_size) ::=
        최대 크기가 max_size 인 공백큐를 생성한다. 
    is_empty(q) ::= 
        if(size == max_size) return TRUE;
        else return FALSE;
    is_full(q) ::=
        if(size == max_size ) return TRUE;
        else return FALSE;
    enqueue(q, e) ::=
        if( is_full(q) ) queue_full 오류;
        else q의 끝에 e를 추가한다. 
    dequeue(q) ::=
        if( is_empty(q) ) queue_empty 오류:
        else q의 맨 앞에 있는 e를 제거하여 반환한다. 
    peek(q) ::=
        if( is_empty(q) ) queue_empty 오류;
        else q의 맨 앞에 있는 e를 읽어서 반환한다.                       

                        </code>
                      </pre>
                      <hr>
                      많이 이용되는 분야는 컴퓨터를 이용하여 현실 세계의 실제 상황을 시뮬레이션 하는 것이다, 예를 들면 은행에서 기다리는 사람들의 대기열, 공항에서 이륙하는 비행기들, 인터넷에서 전송되는 데이터 패킷들을 모델링하는 데 큐가 이용된다. 
                      큐는 운영체제에서도 중요하게 사용된다. 예를 들면 운영체제에는 인쇄 작업큐가 존재한다. 프린터는 속도가 늦고 상대적으로 컴퓨터의 CPU는 속도가 빠르기 때문에 CPU는 빠른 속도로 인쇄 데이터를 만든 다음, 인쇄 작업 큐에 저장하고
                      다른 작업으로 넘어간다. 
                      <hr>
                      <strong>선형 큐</strong>
                      <hr>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#define MAX_QUEUE_SIZE 5

typedef int element;
typedef struct {
  int front;
  int rear;
  element data[MAX_QUEUE_SIZE];
} QueueType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

void init_queue(QueueType *q){
  q -> rear = -1;
  q -> front = -1;
}

void queue_print(QueueType *q){
  for ( int i = 0; i &lt; MAX_QUEUE_SIZE; i ++ ) {
    if ( i &lt;= q -> front || i > q -> rear ){
      printf(" | ");
    }else{
      printf("%d | ", q -> data[i]);
    }
  }
  printf("\n");
}

int is_full(QueueType *q){
  if( q -> rear == MAX_QUEUE_SIZE - 1 )
    return 1;
  else 
    return 0;
}

int is_empty(QueueType *q){
  if( q -> front ==  q -> rear )
    return 1;
  else 
    return 0;
}

void enqueue(QueueType *q, int item){
  if(is_full(q)) {
    error("큐가 포화상태입니다. ")
    return;
  }
  q -> data[++(q->rear)] = item;
}

int dequeue(QueueType *q){
  if(is_empty(q)){
    error("큐가 공백상태입니다. ");
    return 1;
  }
  int item = q -> data[++(q->front)];
  return item;
}

int main(void){
  int item = 0;
  QueueType q;

  init_queue(&q);

  enqueue(&q, 10); queue_print(&q);
  enqueue(&q, 20); queue_print(&q);
  enqueue(&q, 30); queue_print(&q);

  item = dequeue(&q); queue_print(&q);
  item = dequeue(&q); queue_print(&q);
  item = dequeue(&q); queue_print(&q);
  return 0;
}


                        </code>
                      </pre>
                      <hr>
                      <strong>원형큐</strong>
                      <hr>
                      <pre>
                        <code class="C" >
* 원형큐에서의 삽입 알고리즘 
enqueue(Q, x):
    rear &lt;- ( rear + 1) % MAX_QUEUE_SIZE;
    Q[rear] &lt;- x;                          

* 원형큐에서의 삭제 알고리즘
    front &lt;- ( front + 1) % MAX_QUEUE_SIZE;
    return Q[front];                          
                        </code>
                      </pre>
                      <pre>
                        <code class="C" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

#define MAX_QUEUE_SIZE 5
typedef int element;
typedef struct {
  element data[MAX_QUEUE_SIZE];
  int front;
} QueueType;

void error(char *message){
  fprintf(stderr, "%s\n", message);
  exit(1);
}

void init_queue(QueueType *q)
{
  q -> front = q -> rear = 0;
}

int is_empty(QueueType *q)
{
  return ( q -> front == q -> rear);
}

int is_full(QueueType *q){
  return ((q -> rear + 1)% MAX_QUEUE_SIZE == q -> front);
}

void queue_print(QueueType *q){
  printf("QUEUE(front=%d rear=%d) = " , q -> front, q -> rear );
  if(!is_empty(q)) {
    int i = q -> front;
    do {
      i = ( i + 1) % ( MAX_QUEUE_SIZE );
      printf("%d | " , q -> data[i]);
      if( i == q -> rear ){
        break;
      }
    } while ( i != q -> front );
  }

  printf("\n");
}

void enqueue(QueueType *q, element item){
  if(is_full(q))
    error("큐가 포화상태입니다. ");
  q -> rear = ( q -> rear + 1) % MAX_QUEUE_SIZE;
  q -> data[q->rear] = item;
}

element dequeue(QueueType *q){
  if(is_empty(q)){
    error("큐가 공백상태입니다.");
  }
  q -> front = ( q -> front + 1) % MAX_QUEUE_SIZE;
}

element peek(QueueType *q){
  if(is_empty(q))
    error("큐가 공백상태입니다.");
  return q -> data[(q->front+1 ) % MAX_QUEUE_SIZE;
}

int main(void){
  QueueType queue;
  int element;

  init_queue(&queue);
  printf("--데이터 추가 단계--\n");
  while(!is_full(&queue)){
    printf("정수를 입력하시오 : ");
    scanf(%d, &element);
    enqueue(&queue, element);
    queue_print(&queue);
  }
  printf("큐는 포화상태입니다. \n\n");

  printf("--데이터 삭제 단계--\n");
  while(!is_empty(&queue)){
    element = dequeue(&queue);
    printf("꺼내진 정수 : %d \n", element);
    queue_print(&queue);
  }
  printf("큐는 공백상태입니다. \n");
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      <strong>Queue의 버퍼</strong>
                      <hr>
                      <p>
                        버퍼란? <br>
                        버퍼란 임시 저장 공간을 의미합니다. 임시 저장 공간이라고 해서 생뚱맞게 보일 수 있지만 정확히 말하면 A와 B가 서로 입출력을 수행하는 데에 있어서 속도차이를 극복하기 위해 사용하는 임시 저장 공간을 의미합니다. <br>
                        프로그래밍에서의 버퍼는 거의 대부분 CPU와 보조 기억 장치 사이에서 사용되는 임시저장 공간을 의미합니다. 버퍼라는 것은 속도차가 큰 대상이 입출력을 수행할 때 효율성을 위해 사용하는 임시 저장공간이라고 할 수 있겠습니다. 
                      </p>
                      <pre>
                        <code class="C" >
큐를 버퍼처럼 사용할 수 잇는데, 

#include &lt;stdio.h>
#include &lt'stdlib.h>

int main(void){
  QueueType queue;
  int element;

  init_queue(&queue);
  srand(time(NULL));

  for(int i = 0; i &lt; 100; i++ ){
    if(rand() % 5 == 0){
      enqueue(&queue , rand()%100);
    }
    queue_print(&queue);
    if(rand() % 10 == 0){
      int data = dequeue(&queue);
    }
    queue_print(&queue);
  }
  return 0;
}
                        </code>
                      </pre>
                      <p>
                        랜덤한 수(난수)를 생성하는 함수 <br>
                        <ul>
                          <li>
                            int rand(void)
                            <br>
                            랜덤한 숫자를 반환합니다. 
                            그 범위는 0 ~ RAND_MAX 까지 인데요. RAND_MAX 라는 것은 stdlib.h 헤더파일에 매크로로 작성되어 있습니다. <br>
                            RAND_MAX = 32767 <br>
                          </li>
                          <li>
                            void srand(unsigned int seed) <br>
                            rand 함수에 사용될 수를 초기화 한다. 이 초기화를 매개변수로 받는 seed값을 이용해서 합니다. <br>
                          </li>
                          <li>
                            time_t time(time_t* timer); <br>
                            UCT 기준 1970년 1월 1일 0시 0분 0초 부터 경과된 시간을 초(sec)로 반환하는 함수 
                          </li>
                        </ul>
                      </p>
                      <p>
                        매크로(#define) <br>
                        매크로란 어떤 것을 대신하여 사용하는 이름을 말한다. 즉, 어떤 특정한 값이나 처리 명령어를 하나의 이름을 부여하고 그 특정한 값이나 처리 명령어를 사용할 때 부여한 이름을 사용하여 대신 코딩하는 것을 말합니다. 
                        <pre>
                          <code class="C" >
#include &lt;stdio.h>

#define MAIN main(int argc, char *argv[])
#define BEGIN {
#define END } 
#define OUTPUT printf

MAIN
BEGIN
OUTPUT("Hello World! \n");
END
                          </code>
                        </pre>
                      </p>
                      <hr>
                      <Strong>덱(double-ended queue)</Strong>
                      <hr>
                      <pre>
                        <code class="C" >
객체 : n개의 element형의 요소들의 순서 있는 모임 
연산 :
    create() ::= 덱을 생성한다. 
    init(dq) ::= 덱을 초기화한다. 
    is_empty(dq) ::= 덱이 공백상태인지를 검사한다. 
    is_full(dq) ::= 덱이 포화 상태 인지를 검사한다. 
    add_front(dq, e) ::= 덱의 앞에 요소를 추가한다. 
    add_rear(dq, e) ::= 덱의 뒤에 요소를 추가한다. 
    delete_front(dq) ::= 덱의 앞에 있는 요소를 반환한 다음 삭제한다. 
    delete_rear(dq) ::= 덱의 뒤에 있는 요소를 반환한 다음 삭제한다. 
    get_front(q) ::= 덱의 앞에서 삭제하지 않고 앞에 있는 요소를 반환한다.
    get_rear(q) ::= 덱의 뒤에서 삭제하지 않고 뒤에 있는 요소를 반환한다. 
                        </code>
                      </pre>
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading15">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse15" aria-expanded="false" aria-controls="collapse15">
                     
                      </button>
                    </h2>
                  </div>
                  <div id="collapse15" class="collapse" aria-labelledby="heading15" data-parent="#accordionExample">
                    <div class="card-body">
                     
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading16">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse16" aria-expanded="false" aria-controls="collapse16">
                         
                      </button>
                    </h2>
                  </div>
                  <div id="collapse16" class="collapse" aria-labelledby="heading16" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading17">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse17" aria-expanded="false" aria-controls="collapse17">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse17" class="collapse" aria-labelledby="heading17" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading18">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse18" aria-expanded="false" aria-controls="collapse18">
                 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse18" class="collapse" aria-labelledby="heading18" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading19">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse19" aria-expanded="false" aria-controls="collapse19">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse19" class="collapse" aria-labelledby="heading19" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading9">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse9" aria-expanded="false" aria-controls="collapse9">
                         
                      </button>
                    </h2>
                  </div>
                  <div id="collapse9" class="collapse" aria-labelledby="heading9" data-parent="#accordionExample">
                    <div class="card-body">

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading1700">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#heading1700" aria-expanded="false" aria-controls="heading1700">
                        
                      </button>                    
                    </h2>
                  </div>
                  <div id="heading1700" class="collapse" aria-labelledby="heading1700" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                  </div>   
              </div>               
            </div>
            <div class="card-footer small text-muted"></div>
          </div>
          
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
    

    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

 

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>
  </body>

</html>
