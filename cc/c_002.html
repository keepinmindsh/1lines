<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">C ++/C</h6>
            <a class="dropdown-item" href="../cc/cc_001.html">C++ 의 시작</a>
            <a class="dropdown-item" href="../cc/c_001.html">C 의 시작</a>
            <a class="dropdown-item" href="../cc/c_002.html">C 의 기본</a>
            <a class="dropdown-item" href="../cc/c_003.html">자료구조</a>
            <a class="dropdown-item" href="../cc/c_004.html">Redis 분석하기</a>
            <a class="dropdown-item" href="../cc/cc_003.html"></a>
            <a class="dropdown-item" href="../cc/cc_004.html"></a>
            <a class="dropdown-item" href="../cc/cc_005.html"></a>
            <a class="dropdown-item" href="../cc/cc_006.html"></a>
            <a class="dropdown-item" href="../cc/cc_007.html"></a>
            <a class="dropdown-item" href="../cc/cc_008.html"></a>          
            <a class="dropdown-item" href="../cc/cc_009.html"></a>
            <a class="dropdown-item" href="../cc/cc_010.html"></a>
            <a class="dropdown-item" href="../cc/cc_011.html"></a>
            <a class="dropdown-item" href="../cc/cc_012.html"></a>
            <a class="dropdown-item" href="../cc/cc_013.html"></a>
            <a class="dropdown-item" href="../cc/cc_014.html"></a>
            <a class="dropdown-item" href="../cc/cc_015.html"></a>
            <a class="dropdown-item" href="../cc/cc_016.html"></a>
            <a class="dropdown-item" href="../cc/cc_017.html"></a>
            <a class="dropdown-item" href="../cc/cc_018.html"></a>
            <a class="dropdown-item" href="../cc/cc_019.html"></a>
            <a class="dropdown-item" href="../cc/cc_020.html"></a>
            <a class="dropdown-item" href="../cc/cc_021.html"></a>
            <a class="dropdown-item" href="../cc/cc_022.html"></a>
            <a class="dropdown-item" href="../cc/cc_023.html"></a>
            <a class="dropdown-item" href="../cc/cc_024.html"></a>
            <a class="dropdown-item" href="../cc/cc_025.html"></a>
            <a class="dropdown-item" href="../cc/cc_026.html"></a>
            <a class="dropdown-item" href="../cc/cc_027.html"></a>
            <a class="dropdown-item" href="../cc/cc_028.html"></a>
            <a class="dropdown-item" href="../cc/cc_029.html"></a>
            <a class="dropdown-item" href="../cc/cc_030.html"></a>
            <a class="dropdown-item" href="../cc/cc_031.html"></a>
            <a class="dropdown-item" href="../cc/cc_032.html"></a>
            <a class="dropdown-item" href="../cc/cc_033.html">알아두기</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>

          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
                함수 응용 
            </div>
            <div class="card-body">
              <div class="accordion" id="accordionExample">
                  <div class="card">
                      <div class="card">
                      <div class="card-header" id="headingThree">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                            매개변수 전달 방식
                          </button>
                        </h2>
                      </div>
                      <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordionExample">
                        <div class="card-body">
                          Call By Value : 매개변수가 값임 
                          <pre>
                            <code class="C" >          
                              
int Minus(int a, int b){
  return a - b 
}

// main 에서 호출 시 
printf("%d\n", Minus(3,4));

                            </code>
                          </pre>
                          <hr>
                          Call By Reference : 매개변수가 포인터로 사용됨. 
                          <hr>
                          <pre>
                            <code class="C" >
// 주소를 통해 호출자 메모리에 접근할 수 있는 방법 
int Minus(int *a, int *b){
  return *a - *b;
}

// main에서 x, y 값이 선언되어 있고 각 지역변수 x,y의 주소값을 인수로 지정 
printf(%d\n, Minus(&x, &y));
                            </code>
                          </pre>
                          <hr>
                          Call by reference 방식이 Call by Value 에 비해 가장 다른 점은 주소를 통해 호출자 메모리에 접근할 수 있는 방법을 제시함으로써 두 함수가 좀더 강력하게 결합될 수 있다는 것입니다. 
                          <hr>
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>

// 배열 실 인수는 '포인터' 매개변수로 받는다. 
// 포인터에는 요소의 개수 정보가 없으므로 int 매개변수가 더 필요하다. 
// 만일 입력 받아야 할 정수의 개수가 달라져도 이 함수 코드는 변하지 않는다. 
void InitList(int *pList, int nSize){
  int i = 0;
  for ( i = 0 ; i &lt; nSize; ++i){
    printf("정수를 입력하세요. : ");
    scanf("%d", &pList[i]);
  }
}

// 요소가 int 형식인 배열이라면 요소의 개수와 상관 없이 정렬할 수 있다. 
void SortList(int *pList, int nSize){
  int i = 0, j = 0, nTmp = 0;

  for ( i = 0 ; i &lt; nSize -1 ; i ++){
    for(j = i + 1; j &lt; nSize; ++j ){
      if(pList[j] &lt; pList[i]){
        nTmp = pList[j];
        pList[j] = pList[i];
        pList[i] = nTmp;
      }
    }
  }
}

void PrintList(int *pList, int nSize){
  int i = 0;
  for ( i = 0 ; i &lt; nSize ; ++i )
    printf("%d\t", pList[1]);
  
  putchar('\n');
}

int main(void){
  // 자료구조를 지역변수로 선언했기 때문에 
  // 다른 함수에서는 직접 접근할 수 없다. 
  int aList[5] = { 0 }

  InitList(aList, 5);
  SortList(aList, 5);
  PrintList(aList, 5);

  return 0;
}
                            </code>
                          </pre>
                          <hr>
                          매개변수가 포인터일 때 포인터가 가리키는 대상 메모리의 크기를 인수로 받는 것은 보안적으로나 설계적으로 매우 중요합니다. 
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>

// 주소를 매개변수로 받을 때는 대상 메모리의 크기를 함께 받는 것이 좋다. 
void GetName(char *pszName, int nSize){
  printf("이름을 입력하세요. : ");

  // 매개변수로 전달받은 주소를 다시 gets_s( ) 함수의 인수로 넘긴다. 
  gets_s(pszName, nSize);
}

int main(int argc, char* argv[])
{
  char szName[32] = { 0 };

  // 배열(주소)과 배열의 크기를 함수의 매개변수로 전달한다. 
  GetName(szName, sizeof(szName));
  printf("당신의 이름은 %s 입니다. \n", szName);
  return 0;
}
                            </code>
                          </pre>
                          <hr>
                          포인터의 가장 큰 문제는 가리키는 대상의 실제 크기를 포인터 자체만으로는 알 수가 없다는 점입니다. 
                          피호출자 함수가 동적으로 할당한 메모리를 호출자 함수에서 해제 하는 특정이 있습니다. 
                          메모리를 할당하는 함수와 해제하는 함수가 거의 대부분 달라질 것이기 때문에 아래의 예제를 잘이해 해야한다. 
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

// 주소를 반환하는 사용자 정의 함수 선업 및 정의 
char* GetName(void){
  char *pszName = NULL;

  // 메모리를 동적으로 할당한다. 
  pszName = (char*)calloc(32, sizeof(char));
  printf("이름을 입력하세요. :");

  // 동적 할당된 메모리에 사용자가 입력한 문자열을 저장한다. 
  gets_s(pszName, sizeof(char)*32);
  // 동적 할당한 메모리의 주소를 호출자 함수에 반환한다. 
  return pszName;
}

int main(int argc, char* argv[])
{
  char *pszName = NULL;

  // 이름이 저장된 동적 할당된 메모리의 주소를 반환받는다. 
  pszName = GetName();
  printf("당신의 이름은 %s입니다.", pszName);

  // 호출자 함수가 메모리를 해제해야 한다. 
  free(pszName);
  return 0;

}
                            </code>
                          </pre>
                          <hr>
                          Call by reference를 이용한 교환 예제 
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>

// 매개변수로 주소를 받는다. 
void Swap(int *pLeft, int *pRight){
  // 주소를 가리키는 대상의 메모리 값을 교환한다. 
  int nTmp = *pLeft;
  *pLeft = *pRight;
  *pRight = nTmp;
}

int main(int argc, char* argv[]){
  int x = 10, y = 20;

  // 호출자 함수 안에 선언된 지역 변수의 주소를 전달한다. 
  // 따라서 함수가 반환한 후 x와 y의 값은 서로 교환된다.
  Swap(&x, &y);
  printf("%d %d\n", x, y);
  return 0;
}

                            </code>
                          </pre>
                          <hr>
                          문자열의 길이를 측정하는 기능 
                          <hr>
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>

// 매개변수로 전달된 문자열의 길이를 반환하는 함수
int GetLength(const char *pszParm)
{
  int nLength = 0;

  while ( pszParm[nLength] != '\0')
    nLength++;

  return nLength;
}

int main(int argc, char* argv[])
{
  char *pszData = "Hello";

  printf("%d\n", GetLength("Hi"));
  printf("%d\n", GetLength(pszData));
  return 0;
}
                            </code>
                          </pre>
                          <hr>
                          잘못된 주소 전달의 예
                          <hr>
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>

int* TestFunc(void){
  int nData = 10;
  // 함수가 반환되면 소멸할 자동 변수의 주소를 반환한다. 
  // 운영체제에 반환했거나 곧 사라질 메모리에 대한 주소를 반환하는 일은 없어야 합니다. 
  return &nData;
}

int main(int argc, char* argv[]){
  int *pnResult = NULL;
  pnResult = TestFunc();

  // 포인터가 가리키는 대상 메모리는 유효하지 않은 메모리이다. 
  printf("%d\n" ,  *pnResult);
  return 0;
}
                            </code>
                          </pre>
                        </div>
                      </div>
                    </div>
                    <div class="card">
                      <div class="card-header" id="headingFour">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseFour" aria-expanded="false" aria-controls="collapseTwo">
                            스택 프래임
                          </button>
                        </h2>
                      </div>
                      <div id="collapseFour" class="collapse" aria-labelledby="headingFour" data-parent="#accordionExample">
                        <div class="card-body">
                        자동 변수는 스택 영역 메모리를 사용합니다. 자동변수는 기억 부류 auto로 선언된 변수를 말하는데 별도로 명시하지 않은 모든 지역 변수는 모두 자동변수입니다. 
                        함수의 매개변수 역시 자동변수이고 함수의 지역 변수입니다. 따라서 함수 내부에 선언된 변수와 매개변수는 기본적으로 '스택'을 사용합니다. 
                        <hr>
                        스택은 선형 자료구조의 일종으로 정보를 층층이 쌓아 올린 구조입니다. 
                        <hr>
                        <strong>스택과 메모리의 주소는 반대 방향을 그린다.</strong>
                        <hr>
                        스택의 왼쪽에는 함수의 이름과 스코프의 시작 지점을 표시하고 오른쪽에서는 식별자 이름을 기술합니다. 
                        우리가 작성하는 모든 예제들은 항상 main()함수에서 시작하므로 최초로 늘어난 스택은 main()함수에 속한 것으로 가정합니다. 그리고 
                        그림에서 스택은 위로 증가합니다. 그러나 메모리리의 주소는 아래로 증가합니다. 따라서 메모리 주소가 증가 했다는 것은 스택이 들어들었음을
                        의미하고 주솟값이 작어졌다는 것은 스택의 증가를 의미한다고 생각할 수 있습니다. 
                        <hr>
                          <ul>
                            <li>지역 변수는 선언된 순서대로 그린다.

                            </li>
                            <li>포인터 변수는 별도로 표시한다.
                              <pre>
                                <code  class="c">
#include &lt;stdio.h>

int main(int argc, char* argv[]){
  int x = 10, y = 20;
  int *pnData = &x;

  // 포인터 변수는 간접 지정 대상이 어디인지 포인터가 가리키는 지점을 표시해야한다. 
  *pnData = 100;
  return 0;
}
                                </code>
                              </pre>
                            </li>
                            <li>
                              배열의 인덱스는 아래로 증가하게 그린다.  <br>
                              배열의 인덱스는 주소가 증가하는 방향으로 표시해야합니다. 
                              배열의 이름은 '주소상수' 이므로 그자체가 스택에 Push되지 앟는다는 사실에 주의합니다. 

                            </li>
                            <li>
                              동적할당된 메모리는 따로 표시한다. <br>
                              메모리를 동적할당하거나, 정적 영역을 사용하는 병수가 등장한다면 이는 스택 영역이 아니라 별도로 그려서 표시해야한다.
                              <pre >
                                <code  class="c" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>

int main(int argc , char* argv[])
{
  int nData = 10;
  char *pszBuffer = NULL;

  pszBuffer = (char*)malloc(12);
  strcpy(pszBuffer, "Hello");
  free(pszBuffer);
  retur 0;
}

                                </code>
                              </pre>
                            </li>
                            <li>
                              매개변수는 오른쪽부터 스택에 그리며 새 스코프는 기존 스택 위에 그린다. <br>
                              만일 main()함수가 다른 사용자 정의함수를 호출할 경우에는 매개변수도 스택에 그려야 하는데 반드시 오른쪽 매개변수부터 먼저 push 하는 것으로 그립니다. <br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                              <pre>
                                <code class="c">
#include &lt;stdio.h>

int Add(int a, int b)
{
  int nResult = 0;
  nResult = a + b;
  return nResult;
}

int main(int argc, char* argv[])
{
  int nResult = 0;
  nResult = Add(3,4);
  return 0;
}
                                </code>
                              </pre>
                              <hr>
                              함수가 함수를 호출해 함수 몸체에 대한 스코프가 형성되면 스택에 가로선을 길게 그어 표시합니다. 
                              아래의 그림은 main 함수가 Add함수를 호출했다는 것은 Add보다 Main이 먼저 실행됨을 전제 합니다. 
                              따라서 스택에 표시할 때는 main 부터 시작합니다. 
                              <hr>
                              <img src="../cc/StackFrame01.png" class="img-thumbnail"  alt="" srcset="">
                              <hr>
                              Add 함수의 처리가 완료되어 메모리를 반환할 때 아래와 같습니다. 
                              <hr>
                              <img src="../cc/StackFrame03.png" class="img-thumbnail" alt="" srcset="">
                              <hr>
                              동적 할당한 메모리에 저장하고 그 주소를 반환하는 함수를 만든 사례로 실행 과정과 스택 프레임의 변화를 개념적으로 
                              다시 살펴보면, 
                              <hr>
                              <pre class="C" >
                                <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

char* GetName(void)
{
  char *pszName = NULL;

  pszName = (char*)calloc(32,sizeof(char));
  printf("이름을 입력하세요 :");
  gets_s(pszName, sizeof(char) * 32);
  return pszName;
}

int main(int argc, char* argv[]){
  char *pszName = NULL;

  pszName = GetName();
  printf("당신의 이름은 %s입니다.\n" , pszName);
  free(pszName);
  return 0;
}
                                </code>
                              </pre>
                              동적할당한 메모리의 기준주소가 GetName() 함수의 지역변수인 pszName 에 저장되어 있다는 것 
                              <hr>
                              <img src="../cc/StackFrame05.png" class="img-thumbnail" alt="" srcset=""> <br>
                              GetName() 함수가 반환하면 GetName 함수의 지역변수였던 pszName 은 사실상 사라진다고 봐야합니다. 
                              그러나 그 안에 담겨있던 정보는 호출자 함수인 main() 함수에 반환 값으로 전달됩니다.
                              <hr>
                              피호출자 함수가 메모리를 동적 할당하고 해제하지 않았으나, 해제의 열쇠가 되는 기준 주소를 호출자에 반환함으로써 
                              대상 메모리에 이를 수 있는 방법이 사라지지 않았다는 점이다. 그래서 GetName 함수가 반환하는 순간에 메모리가 누수될 
                              뻔 하였으나 이를 main() 함수에서 다시 선으로 이어 줌으로써 대상 메모리를 계속 관리할 수 있었습니다. 
                              그리고 만일 main() 함수에서 메모리를 해제하지 않고 함수가 반환한다면 메모리 누수가 발생합니다. 
                              <hr>
                              <img src="../cc/StackFrame06.png" class="img-thumbnail"  alt="" srcset="">
                              <hr>
                              <img src="../cc/StackFrame07.png" class="img-thumbnail" alt="" srcset=""> <br>
                              main() 함수가 GetName() 함수를 호출했고, GetName()함수가 다시 gets_s()함수를 호출햇다는 것. 
                              이는 매우 중요한 프로그램의 흐름을 알려주는 정보인데, 이를 호출 스탤(Call Stack)이라고 부릅니다. 
                              <hr>
                              <pre class="C" >
                                <code>
#include &lt;stdio.h>

int main(void)
{
  int nInput = 0;
  scanf("%d"m &nInput);

  if(nInput > 10){
    int nInput = 20;
    printf("%d\n", nInput);

    if(nInput &lt; 20){
      int nInput = 30;
      printf("%d\n", nInput);
    }
  }

  printf("%d\n", nInput);
  return 0;
}
                                </code>
                              </pre>
                              <hr>
                              <pre class="C" >
                                <code>
#include &lt;stdio.h>

int main(void){
  int nInput = 0;
  scanf("%d", &nInput);

  if( nInput > 10){
    int nInput = 20;
    printf("%d\n", nInput);

    if(nInput &lt; 20){
      int nInput = 30;
      printf("%d\n", nInput);
    }
  }
}
                                </code>
                              </pre>
                              스택에서 식별자를 검색할 때는 스택의 맨 위에서 아래쪽으로 검색합니다. 그리고 최대 함수 스코프까지 검색합니다. 그래도 찾지 못하면 전역변수에서 찾습니다. 
                              식별자 검색에서 가장 최근에 선언된 변수가 우선하는 이유는 스택의 구조 때문에 발생한 자연스러운 결과입니다. 
                              <hr>
                              <strong>
                                정적변수, 전역 변수는 별도로 표시한다. 
                              </strong>
                              <pre class="Java" >
                                <code>
#include &lt;stdio.h>

int TestFunc(void){
  static int nData = 10;
  ++ nData;
  return nData;
}

int main(int argc, char* argv[]){
  printf("%d\n", TestFunc());
  printf("%d\n", TestFunc());
  printf("%d\n", TestFunc());
  return 0;
}
                                </code>
                              </pre>
                              정적변수나 전역변수는 모두 데이터 영역을 사용하는 변수들입니다. 따라서 스택의 일부로 기술할 수 없고, 동적할당한 경우 처럼 별도의 영역에 따로 떼어 표시합니다.
                              즉, 스택이 늘고 줄고를 반복한다 해도 데이터 영역은 아무 관련이 없습니다. 
                            </li>
                          </ul>
                        </div>
                      </div>
                    </div> 
                    <div class="card-header" id="headingOne">
                      <h2 class="mb-0">
                        <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                            재귀 호출 
                        </button>
                      </h2>
                    </div>
                    <div id="collapseOne" class="collapse" aria-labelledby="headingOne" data-parent="#accordionExample">
                      <div class="card-body">
                         재귀 호출(recursive function)은 함수가 내부에서 다시 자기 자신을 호출하는 것입니다. 반복문과 스택 자료구조를 합친 것이 바로 재귀 호출입니다. 
                         논리적인 코드의 구조는 반복문과 같으나 반복과정에서 선형 자료 구조인 스택이 필요한 경우 재귀호출을 사용합니다. 
                         <hr>
                         <pre class="C" >
                           <code>
#include &lt;stdio.h>

int main(void){
  int i = 0, nFact = 1;
  for ( i = 5 ; i >= 1; --i){
    nFact *= 1;
  }

  printf("5! == %d\n", nFact);
  return 0;
}

#include &lt;stdio.h>

// 계승을 계산하고 결과를 반환하는 함수
int GetFactorial(int nParam){
  int nResult = 0;
  // 재귀호출을 끝내기 위한 조건식! 반복문의 조건식과 같다. 
  if ( nParam == 1) return 1;

  // 매개변수의 값을 1 감소시켜 자기 자신을 다시 호출한다. 
  // 이는 반복문의 계수기와 같다.
  // 아래 행에서 가장 먼저 실행되는 코드는 GetFactorial() 함수를 재귀호출하는 것이다. 
  nResult = nParam * GetFactorial(nParam -1);
  return nResult;
}

int main(void){
  printf("5! == %d\n", GetFactorial(5));
  return 0;
}
                           </code>
                         </pre>
                         <hr>
                         재귀호출에서는 조건에 부합할 때는 함수가 반환하는 방법으로 멈춥니다. 
                          <hr>
                          재귀 호출을 이용한 문자열 출력 
                          <hr>
                          재귀 호출을 하용하는 가장 흔한 경우는 비선형 자료구조를 다룰 때입니다. 비선형 자료구조에는 대표적으로 트리가 있으며, 자료를 계층적 구조로 만든 것이 
                          트리의 특징입니다. 
                          <pre class="c" >
                            <code>
#include &lt;stdio.h>

void PutData(char *pszParam){
  // 문자열의 끝이면 더 이상 재귀 호출은 하지 않고 반환한다. 
  if ( *pszParam == '\0'){
    return;
  }

  // 다음 두 구문의 실행 순서를 바꾸면 문자열이 뒤집어져 출력된다. 
  putchar(*pszParam);

  // 다음 글자를 가리키는 주소를 매개변수로 재귀호출한다.  
  PutData(pszParam + 1);11

}

int main(void){
  PutData("TestData");
  putchar('\n');
  return 0;
}
                            </code>
                          </pre>
                          스택은 가장 먼저 Push 한 정보가 가장 나중에 Pop 되고, 가장 나중에(혹은 최근에) Push한 정보가 가장 먼저 Pop되는 LIFO구조입니다. 
                          이러한 구조가 자주 사용되는 이유는 '되돌리기' 기능과 같은 것을 구현하기 좋기 때문입니다. 
                          스택이 순서를 뒤 바꾼다는 특징을 가진 것이 얼마나 다행스러운 지 모르겠습니다. 우리가 어떤 정보를 다루는 과정에서 로그를 남기고자
                          한다면 스택 형식으로 만드는 것이 좋을 수 있습니다. 왜냐하면 시기적으로 가장 최근에 벌어진 일이 스택의 최상단에 존재하므로 접근하기 쉽기
                          때문입니다. 
                          <hr>
                      </div>
                    </div>
                  </div>
                  <div class="card">
                    <div class="card-header" id="headingTwo">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                          문자/문자열 처리 함수 
                        </button>
                      </h2>
                    </div>
                    <div id="collapseTwo" class="collapse" aria-labelledby="headingTwo" data-parent="#accordionExample">
                      <div class="card-body">               
                        CRL은 많은 표준 함수를 제공합니다. 
                        <hr>
                        <ul>
                          <li>isalpha() : A ~ Z, a ~ z 에 속하는 문자인지 검사하는 함수이다. </li>
                          <li>isdigit() : 0 ~ 9 에 속하는 문자(char)인지 검사하는 함수이다. </li>
                          <li>isxdigit()  : 0 ~ 9, A ~ F, a ~ f 에 속하는 문자(char)인지 검사하는 함수이다.</li>
                          <li>isalnum()  : 0 ~ 9, A ~ Z, a ~ z 에 속하는 문자(char)인지 검사하는 함수이다.</li>
                          <li>islower() : 영문 소문자 인지 검사하는 함수이다. </li>
                          <li>isupper() : 영문 대문자인지 검사하는 함수이다. </li>
                          <li>isspace() : 0x09 ~ 0x0D 혹은 0x20에 속하는 화이트 스페이스 문자인지 검사하는 함수이다. </li>
                          <li>toupper() : 영문 소문자를 대문자로 변환하는 함수이다. </li>
                          <li>tolower() : 영문 대문자를 소문자로 변환하는 함수이다. </li>
                        </ul>   
                        <hr> 
                        문자열 처리함수 
                        <hr>
                        <ul>
                          <li>char *strcat(char *strDestination, const char *strSource);
                            <br>
                            첫 번째 인자로 전달된 주소에 저장된 문자열에 두 번째 인자로 전달될 문자열을 추가해주는 함수이다. 
                            따라서 첫 번째 인자로 전달된 주소에 저장된 문자열의 길이가 늘어난다. 
                          </li>
                          <li>char *strncat(char * strDestination, const char *strSource, size_t count);
                            <br>
                            첫 번째 인자로 전달된 주소에 저장된 문자열에 두 번째 인자로 전달된 문자열을 주어진 길이만큼만 
                            추가해주는 함수이다. 
                          </li>
                        </ul>
                        <pre class="C" >
                          <code>
#include &lt;stdio.h>
#include &lt;string.h>

int main(void){
  char szPath[128] = { "C:\\Program Files\\"};
  char szBuffer[128] = {0};

  printf("Input path : ");
  gets(szBuffer);

  strcat(szPath, szBuffer);
  puts(szPath);
  return 0;
}
                          </code>
                        </pre>
                        strcat 함수는 문자열을 뒤에 붙여주는 함수인데, 문자열의 길이가 늘어날 수록 길이를 측정하기 위해 
                        반복해야 할 횟수가 늘어나고 그만큼 효율을 떨어뜨립니다. 
                        따라서 이를 처리할 수 있는 대안은 strcat 을 우리가 직접 재조정하여 사용하는 것입니다. 
                        새로 만들 함수는 첫 번째 매개변수로 받은 주솟값을 그대로 반환하는 것이 아니라, 두 번째 매개변수로 전달된 문자열을 이어 붙인 후 
                        맨 마지막 문자('\0'이 아닌 문자)가 저장된 메모리의 주소를 반환합니다. 그러면 두 번째로 이어 붙일 때는 문자열의 길이를 처음부터 측정하지 
                        않을 수 있습니다. 
                        <pre class="c" >
                          <code>
#include &lt;stdio.h>
#include &lt;string.h>

char* mystrcat(char *pszDst, char *pszSrc){
  // 대상 메모리에 저장된 문자열의 끝을 찾는다.
  while ( *pszDst != '\0')
    ++pszData;

  // 그 뒤에 새로운 문자열을 이어 붙인다. 
  while ( *pszSrc != '\0')
    *pszDst++ = *pszSrc++;

  // 맨 끝을 NULL 문자로 마무리한다. 
  *++pszDst = '\0';

  // 이어 붙인 문자열의 마지막 글자가 저장된 메모리의 주소를 반환한다. 
  return --pszDst;
}

int main(void){
  char szPath[128] = { 0 };
  char *pszEnd = NULL;

  // 대상 메모리에 문자열을 붙인다. 
  pszEnd = mystrcat(szPath, "C:\\Program Files\\");
  // 앞서 반환한 주소를 첫 번째 인수로 호출해 문자열을 붙인다. 
  pszEnd = mystrcat(pszEnd, "CHS\\");
  pszEnd = mystrcat(pszEnd, "C programming");

  puts(szPath);
  return 0;
}
                          </code>
                        </pre>
                        <hr>
                        sprintf() 함수를 이용한 문자열 붙이기 
                        <hr>
                        문자열은 콘솔 화면이 아니라 '메모리'에 출력한다는 점이 다르다. 
                        <pre class="C" >
                          <code>
#include &lt;stdio.h>
#include &lt;string.h>

int main(void){
  char szPath[128] = {0};
  char szBuffer[128] = {0};
  printf("Input Path : ");
  gets(szBuffer);

  sprintf(szPath, "C:\\Program Files\\%s", szBuffer);
  puts(szPath);
  return 0;
}
                          </code>
                        </pre>
                        sprintf 함수도 보안 결함이 있으므로 sprint_s()나 snprintf() 함수를 사용하는 것이 좋습니다.
                        <hr>
                        strpbrk() 구문 분석 함수 
                        <ul>
                          <li>
                            *strpbrk(const char *string, const char *strCharset); <br>
                            string : 검색 대상 문자열이 저장된 메모리 주소 <br>
                            strCharSet : 검색할 문자 집합 <br>
                            반환 값 : 찾으면 해당 문자가 저장된 메모리 주소 반환, 찾지 못하면 NULL 반환 <br>
                            설명 : 임의의 대상 문자열에서 특정 문자 집합을 검색하는 함수 
                          </li>
                        </ul>
                        <pre class="C" >
                          <code>
#include &lt;stdio.h>
#include &lt;string.h> 

void main(void){
  char szBuffer[128] = { 0 };
  char szSet[128] = { 0 };
  char *pszStart = szBuffer;

  // 검색 대상 문자열을 입력받는다. 
  printf("Input string :");
  gets(szBuffer);

  // 찾을 '문자들'을 입력받는다. 
  printf("Input character set : ");
  gets(szSet);

  while((pszStart = strpbrk(pszStart, szSet)) != NULL){
    printf("[%p] index: %d, %c\n", pszStart, pszStart - szBuffer, *pszStart);

    // 일치하는 하나를 찾았으므로 다음으로 이동하고 계속 찾는다. 
    pszStart ++ ;
  }
}
                          </code>
                        </pre>
                        <hr>
                        strtok 함수를 이용한 구문 분석 
                        <ul>
                          <li>
                            char *strtok(char *strToken, const char *strDelimit) <br>
                            strToken : 토큰화 할 문자열이 저장된 메모리 주소 <br>
                            strDelimit : 토큰의 기준이 되는 구분자 문자 집합 <br>
                            반환 값 : 두 번째 인자로 전달된 문자집합 중 하나라도 찾으면 해당 문자가 저장된 메모리의 내용을 NULL로 바꾸고 문자열의 시작 주소를 반환한다. <br>
                            설명 : 임의의 문자열을 구분자를 근거로 토큰화 하는 함수이다. 이 함수는 내부적으로 정적 변수를 사용하므로 주의해야 한다. 
                          </li>
                        </ul>
                        <pre class="C" >
                          <code>
#include &lt;stdio.h>
#include &lt;stdio.h>

void main(void)
{
  // 토큰화 할 대상 문자열
  char szBuffer[128] = { "nData = x + y; \n nResult = a * b"};

  // 토큰화의 기준이 되는 구분자 문자열 
  char *pszSep = " *+=;\n";
  char *pszToken = NULL;

  // 구분자 문자열을 근거로 첫 번째 토큰화를 시도한다. 
  // 최초 strtok() 함수를 호출할 때는 첫 번째 인자로 토큰화를 시작할 문자열이 저장된 메모리의 주소를 명시했습니다. 
  pszToken = strtok(szBuffer, pszSep);
  while ( pszToken != NULL ){
    // 찾은 토큰을 출력한다. 
    puts(pszToken);
    // 그다음 토큰을 이어서 검색한다. 
    // 첫번째 인자를 NULL로 명시했습니다. 
    pszToken = strtok(NULL, pszSep);
  }

  // 변경된 원본 문자열을 출력해본다. 
  printf("\nszBuffer L %s \n", szBuffer);
}
                          </code>
                        </pre>
                        기본적인 함수의 작동 원리는 strstr(), strpbrk() 함수와 유사합니다. 그러나 strtok() 함수는 검색 대상 메모리에 '쓰기'를 시도하는 데다 
                        내부적으로 정적변수를 사용하기 때문에 멀티 스레드 환경에서 문제가 발생할 수 있습니다. 따라서 strtok() 함수로 검색을 수행하는 대상 메모리는 
                        반드시 쓰기 가능한 메모리여야 하고, 함수가 반환한 후로 대상 메모리의 내용이 수정되었다는 사실을 감안해야 합니다. 또한 보안 결함도 존재합니다. 
                        그러므로 이럭 제약들을 생각 했을 때, strtok() 함수 대신 가급적 strpbrk() 함수를 사용하는 것이 좋습니다. <br>
                        여기서 '토큰화'라는 말은 긴 문자열을 규칙에 따라 잘게 자르는 것을 의미하는 데, 이 말의 구체적인 의미는 문자열 중간에 NULL을 집어넣는 것입니다. 
                      </div>
                    </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading5">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse5" aria-expanded="false" aria-controls="collapse5">
                        유니코드 문자열 및 유틸리티 함수
                      </button>
                    </h2>
                  </div>
                  <div id="collapse5" class="collapse" aria-labelledby="heading5" data-parent="#accordionExample">
                    <div class="card-body">
                        C 언어에서 문자열은 두 종류로 구분할 수 있다. 첫번째는 MBCS 문자열이고 두 번째는 유니코드 문자열입니다. 우리가 다루는 문자열은 MBCS 문자열이며, MBCS 에서 
                        영문 한 글자는 1바이트, 한글 한글자는 2바이트를 사용합니다. 그리고 Char 형으로 문자를 표현합니다. 문자열의 끝을 명시하는 '\0' 상수의 자료형도 char 형입니다. 
                        <hr>
                        영문, 한굴, 한자 표현의 차이는 프로그램의 문자열 길이 계산에도 큰 영향을 준다. 즉, 문자열의 문자 개수와 길이가 서로 다르다는 문제가 발생한다. 
                        <hr>
                        유니코드는 문자 하나를 표현하기 위해 16비트 혹은 32비트 자료형을 사용합니다. 환경마다 다를 수 있는데 윈도우 운영체제는 16비트입니다. 따라서 
                        유니코드 형식인 wchar_t 형은 2바이트입니다. 유니코드는 상수 형식으로 표기할 때 문자열 앞에 'L'을 붙여 L"String" 형식으로 표기합니다. 따라서 
                        L"String" 의 자료형은 wchar[4] 입니다. 따라서 메모리의 크기가 8바이트입니다. 유니코드에서는 영문, 한글에 상관없이 필요한 메모리의 크기가 '(문자열의 길이 + 1) *
                        sizeof(wchar_t)'로 통일됩니다. 
                        <hr>
                        <ul>
                          <li>
                            wprintf(), wcscpy() 함수 <br>
                            유니코드 문자열은 유니코드 문자열 전용 함수를 사용해야한다. 
                            <pre class="C" >
                              <code>
#include &lt;stdio.h>
#include &lt;string.h>

int main(void)
{
  wchar_t *pwszData = L"String";
  wchar_t wszData[32];

  wcscpy(wszData, pwszData);
  wprintf(L"%s\n", wszData);
  return 0;
}
                              </code>
                            </pre>
                          </li>
                          <li>
                            wcstombs(), mbstowcs() 함수 <br>
                            size_t wcstombs(char *mbstr, const wchar_t *wcstr, size_t count); <br>
                            mbstr : MBCS로 변환된 문자열을 저장할 메모리 주소 <br>
                            wcstr : MBCS로 변환할 유니코드 문자열이 저장된 메모리 주소 <br>
                            count : MBCS로 변환할 문자열의 최대 크기 <br>
                            size_t mbstows(wchar_t *wcstr, const char *mbstr, size_t count); <br>
                            mbstr : 유니코드로 변환된 문자열을 저장할 메모리 주소 <br>
                            wcstr : 유니코드로 변환할 유니코드 문자열이 저장된 메모리 주소 <br>
                            count : 유니코드로 변환할 문자열의 최대 크기 <br>
                            <pre class="C" >
                              <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

void main(void)
{
  // 유니코드 문자열 상수로 초기화 
  wchar_t *pwszData = L"String";

  // MBCS 문자열로 담을 수 있는 배열
  char szData[32];
  size_t nConverted = 0;

  // 변환된 문자열의 길이를 알아낸다. 
  nConverted = wsctombs(NULL, pwszData, 32);
  prinf("%d\n", nConverted);

  // 유니코드 문자열을 MBCS 문자열로 변경해 szData 저장한다. 
  nConverted = wsctombs(szData, pwszData, 32);

  // 변환 결과를 출력한다. 
  printf("%s (%d)\n", szData, nConverted);
  
}
                              </code>
                            </pre>
                          </li>
                          <li>
                            atoi(), atol(), atof() , time(), localtime(), ctime(), system(), exit() 
                            <hr>
                            <ul>
                              <li>atoi(const char *string) : 정수 문자열을 실제 정수로 변환하는 함수 
                                <pre class="C" >
                                  <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

void main(void){
  char szBuffer[32];
  int nResult = 0;

  printf("Input string : ");
  gets(szBuffer);

  nResult = atoi(szBuffer);
  printf("%d\n", nResult);
}
                                  </code>
                                </pre>
                              </li>
                              <li>atol(const char *string) : long 형 숫자 문자열을 실제 long 숫자로 변환하는 함수 

                              </li>
                              <li>atof(const char *string) : 실수 문자열을 실제 실수로 변환하는 함수
                                <pre class="C" >
                                  <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

void main(void){
  printf("%d\n", atoi("2147483647"));
  printf("%d\n", atoi("2147483647"));
  printf("%d\n", atof("1.7e + 308"));
  printf("%d\n", atof("1.7e + 309"));
}
                                  </pre>
                                </code>
                              </li>
                              <li>time(time_t *timer) : 변환할 문자열이 저장된 메모리의 주소
                                <hr>
                                컴퓨터에서 시간을 표시할 때는 UTC( Universal Time Coordinated)나 GMT(Greenwich Mean Time)를 기준으로 표시합니다. UTC는 '협정 세계시'라고 하는데 세슘 원자 진동수를 기준으로 시간을 계산하는 
                                '원자시계'의 시간입니다. 그리고 GMT그리니치 평균 태양시'라고 하며 하루가 정확히 24시간으로 이루어졌다고 가정하여 시간을 계산합니다. 
                                <pre class="C" >
                                  <code>
#include &lt;stdio.h>
#include &lt;time.h>

void main(){
  struct tm *ptime = { 0 };
  time_t t = 0;

  t = time(NULL);
  ptime = localtime(&t);
  
  printf(%04d-%02d-%02d\n, ptime -> tm_year + 1900, ptime -> tm_mon + 1, ptime -> tm_mday );
}

#ifndef _TM_DEFINED
struct tm {
      int tm_sec;
      int tm_min;
      int tm_hour;
      int tm_mday;
      int tm_mon;
      int tm_year;
      int tm_wday;
      int tm_yday;
      int tm_isdst;
    };
#define _TM_DEFINED
#endif
                                  </code>
                                </pre>
                              </li>
                              <li>sturct *localtime(const time_t *timer) : tm 구조체는 년/월/일/시/분/초 등의 정보를 멤버로 가진다. 즉, 이 함수는 시간 값을 계산하여 구조체로 반환해주는 함수이다. </li>
                              <li>char *ctime(const time_t *timer); : 로컬 타임 존 설정에 맞추어 시간을 문자열로 변환하는 함수</li>
                            </ul>
                          </li>
                          <li>
                            <ul>
                              srand() , rand() 함수 
                              <hr>
                              rand() 함수는 난수를 발생하는 함수로, 호출할 때 마다 임의의 숫자를 불규칙적으로 변환합니다. 
                              <li>
                                 void srand(unsigned int seed);
                                 <hr>
                                 rand() 함수를 이용하여 난수를 발생시키기에 앞서 임의의 초깃값을 설정하여 최초 rand() 함수가 반환하는 값의 근거가 되는 초깃값을 명시하는 함수이다. 
                              </li>
                              <li>
                                int rand(void);
                                <hr>
                                0 ~ RAND_MAX(231-1) 사이에 속하는 임의의 난수 
                              </li>
                            </ul>
                            <pre class="c" >
                              <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;time.h>

void main() {
  int i = 0;
  srand((unsigne)time(NULL));

  for(i = 0; i &lt; 10 ; i ++){
    printf( "%6d\n", rand());
  }

  for(i = 0; 1 &lt; 10 ; i ++){
    printf("%6d\n", rand() % 10 );
  }
}
                              </code>
                            </pre>
                          </li>
                          <li>
                            system(), exit() 함수 
                            <hr>
                            system() 함수는 명령 프롬프트를 통해 명령을 내리는 것과 같은 기능을 제공한다. 이 함수를 이용하여 다른 외부 응용 프로그램이나 명령을 실행할 수 있습니다. 
                            이 함수의 유니코드 기반 함수는 _wsystem() 함수입니다. 
                            <ul>
                              <li>
                                int system(const char *command)
                                <hr>
                                Command Interpreter 에 명령어를 전달하여 실행하고 그 결과를 반환해주는 함수이다. 해당 명령의 수행이 끝나기 전까지 함수를 반환하지 않는다. 
                              </li>
                            </ul>
                            <pre class="c" >
                              <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

void main(){
  char szCommand[512] = { 0 };
  printf("Input command : ");
  gets(szCommand);

  system(szCommand);
}
                              </code>
                            </pre>
                            <ul>
                              <li>
                                int exit(int status)
                                <hr>
                                인수로 전달된 상태 값을 반환하고 프로그램을 완전히 종료한다. 
                              </li>
                            </ul>
                            <pre class="C" >
                                <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;conio.h>

void main(){
  char ch;
  print("Do you want to EXIT? (Y/N)\n");
  ch = _getch();

  if(ch == 'y' || ch == 'Y'){
    puts("EXIT");
    exit(1);
  }

  puts("End of Month( ) ");
}
                              </code>
                            </pre>
                          </li>
                        </ul>
                    </div>
                  </div>
                </div>  
                <div class="card">
                  <div class="card-header" id="heading7">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse7" aria-expanded="false" aria-controls="collapse7">
                        구조체 와 공용체 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#accordionExample">
                    <div class="card-body">
                      슈도 코드(pseudocode) : 프로그램을 작성할 때 각 모듈이 작동하는 논리를 표현하기 위한 언어이다. <br>
                      구조체 <br>
                      구조체를 이루고 있는 멤버들의 순서에 맞춰서 초깃값을 기술해야한다. 
                      <pre class="C" >
                        <code>
#include &lt;stdio.h>
#include &lt;string.h>

// 구조체 선언
struct USERDATA
{
  int nAge;
  char szName[32];
  char szPhone[32];
}

int main(void){
  // USERDATA 구조체 변수 user 선언 및 정의 
  struct USERDATA user = { 0, "", "" }

  // 구조체 멤버 접근 및 값 채우기 
  user.nAge = 10;
  strcpy(user.szName, "Hoon");
  strcpy(user.szPhone, "010-2646-0503");

  // 구조체 멤버 접근 및 출력 
  printf("%d살, %s , %s\n", user.nAge, user.szName, user.szPhone);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      typedef를 이용한 형 재선언 <br>
                      구조체 변수를 선언할 때 매번 struct 예약어를 기술하는 일은 귀찮은 일입니다. 그래서 대부분 구조체를 선언 할 때 typedef 얘약어를 이용해 형 재선언을 포함하는 것이 일반적입니다. 그러면 구조체 인스턴스를 정의할 때, 
                      struct 예약어를 생략할 수 있습니다. 
                      <pre class="C" >
                        <code>
#include &lt;stdio.h>
#include &lt;string.h>

// 구조체 선언 및 형 재선언 
// USERDATA 구조체의 선언과 행 재선언이 하나로 합쳐진 것이다. 
typedef struct USERDATA
{
  int nAge;
  char szName[32];
  char szPhone[32];
} USERDATA

int main(void)
{
  // 형 재선언 덕분에 변수를 선언할 때 'struct'를 생략할 수 있다. 
  USERDATA user = { 0, "" , ""};

  // 구조체 멤버 접근 및 값 채우기 
  user.nAge = 10;
  strcpy(user.szName, "Hoon");
  strcpy(user.szPhone, "010-1234-1234");

  // 구조체 멤버 접근 및 출력 
  printf("%d살, %s, %s\n", user.nAge , user.szName, user.szPhone);
  return 0;
}
                        </code>
                      </pre>
                      <hr>
                      구조체 배열 <br>
                      구조체가 자료형이 되므로 구조체 변수를 배열로 선언할 수 도 있습니다. 
                      <pre class="C" >
                        <code>
#include &lt;stdio.h>

// USERDATA 구조체 선언 및 형 재선언 
typedef struct USERDATA 
{
  int nAge;
  char szName[32];
  char szPhone[32];
} USERDATA

int main(void)
{
  USERDATA userList[4] = {
    { 10 , "김어준" , "1234" },
    { 11 , "정봉주" , "2345" },
    { 17 , "주진우" , "3456" },
    { 12 , "김용민" , "4567" },
  };

  int i = 0;

  // 배열 연산으로 각 USERDATA 인스턴스의 멤버 값을 출력한다. 
  for ( i = 0 ; i &lt; 4 ; ++i )
    printf("%d살\t%s\t%s\n", userList[i].nAge, userList[i].szName, userList[i].szPhone );

  return 0;
}
                        </code>
                      </pre>

                      구조체는 사용자가 그 구조를 설계한 자료형입니다. 따라서 메모리를 해석하는 방법이라고 봐야 합니다.
                      <pre class="C" >
                        <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>

typedef struct USERDATA
{
  int nAge;
  char szName[32];
  char szPhone[32];
} USERDATA;

int main(void)
{
  // USERDATA 구조체에 대한 포인터 변수 선언 및 정의 
  USERDATA *pUser = NULL;

  // USERDATA 구조체가 저장될 수 있을 수 있는 크기의 메모리 동적할당
  // 구조체의 사이즈를 정의할 때는, 메모리를 지정하지 않고 sizeof에 의해서 사용해야한다. 
  pUser = (USERDATA*)malloc(sizeof(USERDATA));

  // 포인터 이므로 '.'이 아니라 '->' 연산자로 멤버에 접근한다. 
  // 구조체 멤버 접근 연산자의 왼쪽 피 연산자가 포인터이면, 기존 연산자인 '.'를 사용할 수 없고 대신 -> 연산자를 사용해야 한다. 
  pUser -> nAge = 10;
  strcpy(pUser -> szName, "Hoon");
  strcpy(pUser -> szPhone, "9876");

  printf("%d살\t%s\t%s\n", pUser -> nAge, pUser -> szName, pUser -> szName);

  // 동적 할당한 메모리를 해제한다. 
  free(pUser);
  return 0;

}
                        </code>
                      </pre>
                        *pUser.szName 이라고 표기하면 간접 지정 연산자보다 구조체 멤버 접근 연산자가 우선하므로 최종 결과는 'char 형 l-value'가 됩니다. 구조체 멤버접근 연산자는 괄호, 배열 연산자와 더불어 1순위 연산자입니다. 
                        pUser -> szName을 다르게 표기하면 (*pUser).szName 이 됩니다. 
                        <hr>
                        구조체도 함수의 반환 자료형이나 매개변수가 될 수 있습니다. 그리고 구조체 변수는 배열의 이름과 달리 l-value가 될 수 있습니다. 
                        <pre class="C" >
                          <code>
#include &lt;stdio.h>

// 구조체 선언 및 재선언 
typedef struct USERDATA
{
  int nAge;
  char szName[32];
  char szPhone[32];
} USERDATA;


// 구조체 형식을 반환하는 함수 선언 및 정의 
USERDATA GetUserData(void)
{
  USERDATA user = { 0 };
  // %*c는 '\n'을 제거하기 위한 것이다. 
  scanf("%d%*c", &user.nAge);
  gets_s(user.szName, sizof(user.szName));
  gets_s(user.szPhone, sizeof(user.szPhone));
  return user;
}

int main(void)
{
  USERDATA user = { 0 };

  // 함수가 반환한 구조체를 저장하고 출력 
  // 하지만 아래와 같이 구조체 변수를 매겨변수나 반환 자료형식으로 사용하는 것은 비효율 적입니다. 
  // 구조체가 매개변수나 반환형이 될 때는 Call By reference 형식으로 처리하는게 좋습니다. 
  user = GetUserData();
  printf("%d살\t%s\t%s\n", user.nAger, user.szName, user.szPhone);


  return 0;
}


// Call By Reference에 의한 구조체 매개변수 전달 
// 구조체를 함수의 인수로 전달 할 때는 Call By Reference 방식을 사용하는 것이 현명합니다. 
USERDATA GetUserData(USERDATA *pUser)
{
  scanf("%d%*c", &pUser.nAge);
  gets_s(user.szName, sizof(pUser -> szName));
  gets_s(user.szPhone, sizeof(pUser -> szPhone));
  return user;
}

int main(void)
{
  USERDATA user = { 0 };
  
  GetUserData(&user);

  printf("%d살\t%s\t%s\n", user.nAger, user.szName, user.szPhone);

  return 0;
}
                          </code>
                        </pre>
                        <hr>  
                          <strong>구조체를 멤버로 가지는 구조체</strong>
                        <hr>
                        <pre class="C" >

                          <code>
typedef struct MYSKILL
{
  int nPoint;
  char szSkilName[32];

} MYSKILL;

typedef struct USERDATA
{
  int nAge;
  char szName[32];
  char szPhone[32];
  MYSKILL skill;
} USERDATA;

int main(void)
{
  USERDATA user = {
    "Jeong",
    "01000000000",
    { 90, "Attack" }
  };

  printf("%d\t%s\n", user.skill.nPoint, user.skill.szSkilName );

  return 0;
}
                          </code>
                        </pre>
                        <hr>
                        <strong>자기 참조 구조체</strong>
                        <hr>
                        구조체의 멤버로 구조체에 대한 포인터 변수를 선언할 수도 있다. 해당 포인터가 가리키는 대상이 자기 자신이면 자기 참고 구조체라고 부를수 있다. 
                        <pre class="C" >
                          <code>
typedef struct USERDATA
{
  int nAge;
  char szName[32];
  char szPhone[32];
  struct USERDATA *pNext; // 자기자신을 가리킬 수 있는 구조체를 포인터로 선언하였다. 
} USERDATA;

int main(void)
{
  USERDATA user = { "홍길동" , "0101231234", NULL };
  USERDATA newuser = { "유산슬" , "0102345678", NULL }; 

  // pNext를 이용해 위의 user와 newuser를 연결한다. 
  user.pNext = &newUser;

  printf("%d\t%s\n", user.pNext -> szName , user.pNext -> szPhone );

  return 0;
}

                          </code>
                        </pre>
                        <hr>
                        <strong>자기 참조 구조체 예제</strong>
                        <hr>
                        <pre>
                          <code>
int main(void)
{
  // 배열로 USERDATA를 구조체 인스턴스 넷을 선언 및 정의 
  USERDATA userList[4] = {
    { "홍길동1", "01002341234", NULL }, 
    { "홍길동2", "01004561234", NULL },
    { "홍길동3", "01007891234", NULL },
    { "홍길동4", "01001461234", NULL }
  }

  USERDATA *pUser = NULL;

  userList[0].pNext = &userList[1];
  userList[1].pNext = &userList[2];
  userList[2].pNext = &userList[3];

  userList[3].pNext = NULL;

  pUser = &userList[0];

  while(pUser != NULL){
    printf("%d\t%s\n", pUser -> szName , pUser -> szPhone );

    pUser = pUser -> pNext;
  }

  return 0;
}
                          </code>
                        </pre>
                        <hr>
                        <strong>구조체 멤버 맞춤</strong>
                        <hr>
                        <pre class="C" >
                          <code>
// 배열은 각 요소가 연접하여 붙어 있습니다. 그러나 구조체는 연접할 수 도 있고 그렇지 않을 수도 있습니다. 즉 두 멤버 사이에 일정 크기의 공백이 껴들 수 있습니다. 
// 구조체 멤버 맞춤에 의해서 

typedef struct USERDATA {
  char value;
  int number;
} USERDATA;

// USERDATA 의 sizeof는 5가 되어야할 것 같지만 8이 됩니다. 
// 그이유는 구조체 멤버 맞춤의 기본 값이 8byte라고 할 때, 1byte짜리 char 에 3byte를 채워, 4(value) + 4(number)로 인식되어 8byte로 만들게 됩니다. 

// 하지만 프로그램을 하다보면, 이 구조체들의 멤버 구성이 어떻게 되어 있던 간에 모든 멤버가 각각 연속적으로 붙어있어야하는 경우에는 
// 아래와 같이 코드를 작성할 수 있습니다. 

#pragma pack(push, 1)

typedef struct USERDATA {
  char value;
  int number;
} USERDATA;

#pragma pack(pop)

// 위와 같은 코드에서 sizeof로 계산하게 되면 1(value) + 4(number) = 5가 되는 것을 확인 할 수 있습니다. 
// pragma pack 전처리는 memory packing과 관련한 설정을 변경하는 전처리기 입니다. 
// 멤버 맞춥에 대한 오류 발생 가능성은 아래의 케이스들에 대해서 반드시 고려되어야 합니다. 
// * 파일에 저장하거나 읽어오는 경우 
// * 네트워크로 전송하거나 수신하는 경우 

                          </code>
                        </pre>
                        <hr>
                        <strong>
                          비트 필드 
                        </strong>
                        <hr>
                        비트 필드는 구조체 멤버가 바이트 단위가 아닌 비트 단위 데이터를 다루는 멤버로 선언되는 구조체입니다. 이를 통해 8비트 정보를 쉽게 원하는 크기 만큼 잘라서 사용할 수 있습니다. 
                        만일 비트 필드를 이용하지 않고도 일정 비트를 잘라내려면 마스크 연산을 비롯한 각종 비트 연산을 수행해야 합니다. 
                        <pre class="C" >
                          <code>
#include &lt;stdio.h>

typeof struct _DATAFLAG
{
  unsigned char main : 1; // 8 비트 중 오른쪽 1비트 
  unsinged char left : 2; // 오른쪽 2~3번째 비트 
  unsinged char right : 3; // 오른쪽 4~6번째 비트 
  unsinged char top : 2; // 오른쪽 7~8번째 비트 ( 왼쪽 두 비트 )
} DATAFLAG;

int main(void){
  // 1비트 표현범위 : 0 ~ 1
  // 2비트 표현범위 : 0 ~ 3 
  // 3비트 표현범위 : 0 ~ 7
  DATAFLAG flagSwitch = { 0, 3, 7, 4};

  printf("%d\n", flagSwitch.main);
  printf("%d\n", flagSwitch.left);
  printf("%d\n", flagSwitch.right);
  // 4는 2비트 표현범위를 넘어선 값이므로 출력할 수 없다. ( 0 출력 )
  printf("%d\n", flagSwitch.top);

  printf("%d\n", *((unsinged char *)&flagSwitch));
  printf("%d\n", sizeof(flagSwitch));
  
  return 0;
}
                          </code>
                        </pre>
                        <hr>
                        다시 말하지만 반드시 표현범위를 잘 따져봐야합니다. 그렇지 않으면 멤버인 top 처럼 4가 아니라 
                        0이 들어가버릴 수도 있습니다. 만일 표현의 범위가 넘어가면 넘어간 만큼의 정보는 모두 잘립니다. 
                    </div>
                  </div>
                </div> 
                
                <div class="card">
                  <div class="card-header" id="heading10">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse10" aria-expanded="false" aria-controls="collapse10">
                        공용체 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse10" class="collapse" aria-labelledby="heading10" data-parent="#accordionExample">
                    <div class="card-body">
                      공용체는 서로 다른 자료형 여러개가 모여 새로운 한덩어리를 이룬 구조체와 달리 한 가지 자료에 대해 여러가지 해석법을 부여하는 문법이다. 
<pre class="C" >
  <code>
#include &lt;stdio.h>

// IP_ADDR '공용체' 선언 및 형 재선언 
// 4바이트를 세 가지 형식으로 달리 해석할 수 있도록 선언한다. 
typedef union _IP_ADDR 
{
  int nAddress;
  short awData[2];
  unsigned char addr[4];
} IP_ADDR

int main(void){
  IP_ADDR Data = { 0 };
  // 한 멤버에 대해 단순 대입을 시도하면 대상 메모리에 쓰기가 일어날 것이고, 이를 아래에서 전혀 다른 방법으로 해석하고 활용할 수 있습니다. 
  Data.nAddress = 0x41424344;

  // 0x41424344 를 8비트씩 0x41, 0x42, 0x43, 0x44 넷으로 잘라 영문자로 출력한다. 
  printf("%c%c%c%c\n", Data.addr[0], Data.addr[1], Data.addr[2], Data.addr[3]);
  // 16 비트씩 둘로 잘라 출력한다. 
  printf("%X %d\n", Data.awData[0], Data.awData[0]);
  printf("%X %d\n", Data.awData[1], Data.awData[1]);

  return 0;
}
  </code>
</pre>
<hr>
                    IP_ADD 공용체 멤버인 nAddress, awData, addr 은 4바이트 메모리에 대한 세가지 해석방법입니다. 즉, 대상 메모리는 같은 곳이고 자료형만 달라집니다. 
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading11">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse11" aria-expanded="false" aria-controls="collapse11">
                        파일 입출력 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse11" class="collapse" aria-labelledby="heading11" data-parent="#accordionExample">                        
                    <div class="card-body">
                      변수나 동적 할당한 메모리가 주기억장치를 사용하기 위한 요소라면 파일은 보조기억장치를 사용하기 위한 요소이며, 파일 시스템이라고 부르는 별도의 관리 체계가 존재합니다. 
                      <hr>
                      보조기억장치는 주기억장치와 달리 용량문제에 매우 둔감합니다. malloc() 함수로 메모리를 확보하라면 인수로 필요한 메모리 크기를 바이트 단위로 명시해야하지만 파일은 그럴 필요가 없습니다. 
                      주기억장치나, 보조기억장치나 같은 메모리지만 사용하는 방법은 그 속성 만큼이나 서로 다릅니다. 
                      <hr>
                      <strong>파일 시스템 기본 이론</strong>
                      <hr>
                      파일 시스템은 파일 단위의 정보를 생성, 삭제, 저장, 검색할 수 있도록 정보를 구성하는 방법을 말한다. <br>
                      폴더는 디렉터리(directory)를 말합니다. <br>
                      파일의 위치를 말할 때, 경로를 말을 사용하는데, 이는 윈도우 운영체제를 기준으로 "드라이드명:\폴더명\폴더명" 형식으로 표현되는 정보로서, 파일시스템에서 특정 파일의 논리적인 위치를 표시합니다. <br>
                      <hr>
                      절대 경로  : 디스크 볼륨이름부터 파일명에 이르는 전체 정보를 표시한 것 <br>
                      상대 경로  : 프라이브명과 폴더명을 생략하여 파일이름만 표시한 것, 상대 경로로 설정할 경우에는 프로세스의 현재 경로를 기본 경로로 설정하여 파일의 논리적 위치를 결정합니다. <br>
                      <hr>
                      텍스트 파일과 바이너리 파일 <br>
                      파일은 크게 텍스트 파일과 바이너리 파일로 나눌 수 있습니다. 텍스트 파일은 파일에 저장된 정보가 모두 ASCII 코드나 문자열로 해석할 수 있는 정보들로만 구성된 파일을 말합니다. <br>
                      텍스트 파일의 중요한 특징 중 하나는 -1이라는 정수값을 '파일의 끝(EOF)'로 인식한다는 것. <br>
                      텍스트 파일을 제외한 모든 파일들은 바이너리 파일로 인식한다. 
                      <hr>
                      <strong>fopen , fclose</strong><br>
                      <ul>
                        <li>
                           FILE *fopen(const char *filename, const char *mode);
                           <hr>
                           인자 
                           <hr>
                            filename : 열고자 하는 대상 파일의 절대 경로 문자열  <br>
                            mode : 접근 모드를 명시한 문자열 
                           <hr>
                           반환값 
                           <hr>
                           FILE 구조체에 대한 주소 반환, 만일 에러가 발생하면 NULL 반환 
                           <hr>
                           설명
                           <hr>
                           반환된 FILE 구조체는 fclose() 함수를 이용하여 반드시 닫아야 한다. 
                           <hr>
                           <table class="table">
                            <thead>
                              <tr>
                                <th scope="col">모드</th><th scope="col">의미</th><th scope="col">파일이 존재할 때</th><th scope="col">파일이 없을 때</th>
                              </tr>
                            </thead>
                            <tbody>
                              <tr>
                                <th scope="row">r</th><td>텍스트 읽기</td><td>파일 열기</td><td>에러</td>
                              </tr>
                              <tr>
                                <th scope="row">w</th><td>텍스트 쓰기</td><td>기존 내용 지우고 열기</td><td>새로 만듦</td>
                              </tr>
                              <tr>
                                <th scope="row">a</th><td>텍스트 추가</td><td>기존 내용 뒤에 추가 </td><td>새로 만듦</td>
                              </tr>
                              <tr>
                                <th scope="row">r+</th><td>텍스트 읽기 + 갱신</td><td>파일열기</td><td>에러</td>
                              </tr>
                              <tr>
                                <th scope="row">w+</th><td>텍스트 쓰기 + 갱신</td><td>기존 내용 지우고 열기</td><td>새로 만듦</td>
                              </tr>
                              <tr>
                                <th scope="row">a+</th><td>텍스트 추가 + 갱신</td><td>기존 내용 뒤에 추가</td><td>새로 만듦</td>
                              </tr>
                              <tr>
                                <th scope="row">rb</th><td>바이너리 읽기</td><td>파일열기</td><td>에러</td>
                              </tr>
                              <tr>
                                <th scope="row">wb</th><td>바이너리 쓰기</td><td>기존 내용 지우고 열기</td><td>새로 만듦</td>
                              </tr>
                              <tr>
                                <th scope="row">ab</th><td>바이너리 추가</td><td>기존 내용 뒤에 추가</td><td>새로 만듦</td>
                              </tr>
                              <tr>
                                <th scope="row">rb+</th><td>바이너리 읽기 + 갱신</td><td>파일열기</td><td>에러</td>
                              </tr>
                              <tr>
                                <th scope="row">wb+</th><td>바이너리 쓰기 + 갱신</td><td>기존 내용 지우고 열기</td><td>새로 만듦</td>
                              </tr>
                              <tr>
                                <th scope="row">ab+</th><td>바이너리 추가 + 갱신</td><td>기존 내용 뒤에 추가</td><td>새로 만듦</td>
                              </tr>
                             
                            </tbody>
                          </table>
                        </li>
                        <li>
                          int fclose(File *stream);
                          <hr>
                          인자 
                          <hr>
                           stream : 닫을 파일에 대한 FILE 구조체 주소  
                          <hr>
                          반환값 
                          <hr>
                           함수가 성공하면 0을 반환하고 만일 에러가 발생하면 EOF를 반환 
                          <hr>
                          설명
                          <hr>
                           이 함수는 파일의 입출력을 끝내고 파일을 닫는다. 
                       </li>
                       <li>
                        int _fcloseall(void);
                        <hr>
                        인자 
                        <hr>
                         없음
                        <hr>
                        반환값 
                        <hr>
                         닫은 파일의 개수
                        <hr>
                        설명
                        <hr>
                         프로그램에서 열어둔 모든 파일을 닫는다. 
                     </li>
                      </ul>
                      

                      
                    
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading13">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse13" aria-expanded="false" aria-controls="collapse13">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse13" class="collapse" aria-labelledby="heading13" data-parent="#accordionExample">
                    <div class="card-body">

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading14">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse14" aria-expanded="false" aria-controls="collapse14">
                       
                      </button>
                    </h2>
                  </div>
                  <div id="collapse14" class="collapse" aria-labelledby="heading14" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading15">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse15" aria-expanded="false" aria-controls="collapse15">
                     
                      </button>
                    </h2>
                  </div>
                  <div id="collapse15" class="collapse" aria-labelledby="heading15" data-parent="#accordionExample">
                    <div class="card-body">
                     
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading16">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse16" aria-expanded="false" aria-controls="collapse16">
                         
                      </button>
                    </h2>
                  </div>
                  <div id="collapse16" class="collapse" aria-labelledby="heading16" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading17">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse17" aria-expanded="false" aria-controls="collapse17">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse17" class="collapse" aria-labelledby="heading17" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading18">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse18" aria-expanded="false" aria-controls="collapse18">
                 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse18" class="collapse" aria-labelledby="heading18" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading19">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse19" aria-expanded="false" aria-controls="collapse19">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse19" class="collapse" aria-labelledby="heading19" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading9">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse9" aria-expanded="false" aria-controls="collapse9">
                         
                      </button>
                    </h2>
                  </div>
                  <div id="collapse9" class="collapse" aria-labelledby="heading9" data-parent="#accordionExample">
                    <div class="card-body">

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading1700">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#heading1700" aria-expanded="false" aria-controls="heading1700">
                        
                      </button>                    
                    </h2>
                  </div>
                  <div id="heading1700" class="collapse" aria-labelledby="heading1700" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
              </div>                  
            </div>
            <div class="card-footer small text-muted"></div>
          </div>
          
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
    

    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

 

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>
  </body>

</html>
