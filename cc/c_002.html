<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">C ++</h6>
            <a class="dropdown-item" href="../cc/cc_001.html">C++ 의 시작</a>
            <a class="dropdown-item" href="../cc/cc_003.html"></a>
            <a class="dropdown-item" href="../cc/cc_003.html"></a>
            <a class="dropdown-item" href="../cc/cc_004.html"></a>
            <a class="dropdown-item" href="../cc/cc_005.html"></a>
            <a class="dropdown-item" href="../cc/cc_006.html"></a>
            <a class="dropdown-item" href="../cc/cc_007.html"></a>
            <a class="dropdown-item" href="../cc/cc_008.html"></a>          
            <a class="dropdown-item" href="../cc/cc_009.html"></a>
            <a class="dropdown-item" href="../cc/cc_010.html"></a>
            <a class="dropdown-item" href="../cc/cc_011.html"></a>
            <a class="dropdown-item" href="../cc/cc_012.html"></a>
            <a class="dropdown-item" href="../cc/cc_013.html"></a>
            <a class="dropdown-item" href="../cc/cc_014.html"></a>
            <a class="dropdown-item" href="../cc/cc_015.html"></a>
            <a class="dropdown-item" href="../cc/cc_016.html"></a>
            <a class="dropdown-item" href="../cc/cc_017.html"></a>
            <a class="dropdown-item" href="../cc/cc_018.html"></a>
            <a class="dropdown-item" href="../cc/cc_019.html"></a>
            <a class="dropdown-item" href="../cc/cc_020.html"></a>
            <a class="dropdown-item" href="../cc/cc_021.html"></a>
            <a class="dropdown-item" href="../cc/cc_022.html"></a>
            <a class="dropdown-item" href="../cc/cc_023.html"></a>
            <a class="dropdown-item" href="../cc/cc_024.html"></a>
            <a class="dropdown-item" href="../cc/cc_025.html"></a>
            <a class="dropdown-item" href="../cc/cc_026.html"></a>
            <a class="dropdown-item" href="../cc/cc_027.html"></a>
            <a class="dropdown-item" href="../cc/cc_028.html"></a>
            <a class="dropdown-item" href="../cc/cc_029.html"></a>
            <a class="dropdown-item" href="../cc/cc_030.html"></a>
            <a class="dropdown-item" href="../cc/cc_031.html"></a>
            <a class="dropdown-item" href="../cc/cc_032.html"></a>
            <a class="dropdown-item" href="../cc/cc_033.html">알아두기</a>
            <a class="dropdown-item" href="../cc/c_001.html">C 의 시작</a>
            <a class="dropdown-item" href="../cc/c_002.html">C 함수 응용</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>

          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
                함수 응용 
            </div>
            <div class="card-body">
              <div class="accordion" id="accordionExample">
                  <div class="card">
                      <div class="card">
                      <div class="card-header" id="headingThree">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                            매개변수 전달 방식
                          </button>
                        </h2>
                      </div>
                      <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordionExample">
                        <div class="card-body">
                          Call By Value : 매개변수가 값임 
                          <pre>
                            <code class="C" >          
                              
int Minus(int a, int b){
  return a - b 
}

// main 에서 호출 시 
printf("%d\n", Minus(3,4));

                            </code>
                          </pre>
                          <hr>
                          Call By Reference : 매개변수가 포인터로 사용됨. 
                          <hr>
                          <pre>
                            <code class="C" >
// 주소를 통해 호출자 메모리에 접근할 수 있는 방법 
int Minus(int *a, int *b){
  return *a - *b;
}

// main에서 x, y 값이 선언되어 있고 각 지역변수 x,y의 주소값을 인수로 지정 
printf(%d\n, Minus(&x, &y));
                            </code>
                          </pre>
                          <hr>
                          Call by reference 방식이 Call by Value 에 비해 가장 다른 점은 주소를 통해 호출자 메모리에 접근할 수 있는 방법을 제시함으로써 두 함수가 좀더 강력하게 결합될 수 있다는 것입니다. 
                          <hr>
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>

// 배열 실 인수는 '포인터' 매개변수로 받는다. 
// 포인터에는 요소의 개수 정보가 없으므로 int 매개변수가 더 필요하다. 
// 만일 입력 받아야 할 정수의 개수가 달라져도 이 함수 코드는 변하지 않는다. 
void InitList(int *pList, int nSize){
  int i = 0;
  for ( i = 0 ; i &lt; nSize; ++i){
    printf("정수를 입력하세요. : ");
    scanf("%d", &pList[i]);
  }
}

// 요소가 int 형식인 배열이라면 요소의 개수와 상관 없이 정렬할 수 있다. 
void SortList(int *pList, int nSize){
  int i = 0, j = 0, nTmp = 0;

  for ( i = 0 ; i &lt; nSize -1 ; i ++){
    for(j = i + 1; j &lt; nSize; ++j ){
      if(pList[j] &lt; pList[i]){
        nTmp = pList[j];
        pList[j] = pList[i];
        pList[i] = nTmp;
      }
    }
  }
}

void PrintList(int *pList, int nSize){
  int i = 0;
  for ( i = 0 ; i &lt; nSize ; ++i )
    printf("%d\t", pList[1]);
  
  putchar('\n');
}

int main(void){
  // 자료구조를 지역변수로 선언했기 때문에 
  // 다른 함수에서는 직접 접근할 수 없다. 
  int aList[5] = { 0 }

  InitList(aList, 5);
  SortList(aList, 5);
  PrintList(aList, 5);

  return 0;
}
                            </code>
                          </pre>
                          <hr>
                          매개변수가 포인터일 때 포인터가 가리키는 대상 메모리의 크기를 인수로 받는 것은 보안적으로나 설계적으로 매우 중요합니다. 
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>

// 주소를 매개변수로 받을 때는 대상 메모리의 크기를 함께 받는 것이 좋다. 
void GetName(char *pszName, int nSize){
  printf("이름을 입력하세요. : ");

  // 매개변수로 전달받은 주소를 다시 gets_s( ) 함수의 인수로 넘긴다. 
  gets_s(pszName, nSize);
}

int main(int argc, char* argv[])
{
  char szName[32] = { 0 };

  // 배열(주소)과 배열의 크기를 함수의 매개변수로 전달한다. 
  GetName(szName, sizeof(szName));
  printf("당신의 이름은 %s 입니다. \n", szName);
  return 0;
}
                            </code>
                          </pre>
                          <hr>
                          포인터의 가장 큰 문제는 가리키는 대상의 실제 크기를 포인터 자체만으로는 알 수가 없다는 점입니다. 
                          피호출자 함수가 동적으로 할당한 메모리를 호출자 함수에서 해제 하는 특정이 있습니다. 
                          메모리를 할당하는 함수와 해제하는 함수가 거의 대부분 달라질 것이기 때문에 아래의 예제를 잘이해 해야한다. 
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>
#include &lt;stdlib.h>

// 주소를 반환하는 사용자 정의 함수 선업 및 정의 
char* GetName(void){
  char *pszName = NULL;

  // 메모리를 동적으로 할당한다. 
  pszName = (char*)calloc(32, sizeof(char));
  printf("이름을 입력하세요. :");

  // 동적 할당된 메모리에 사용자가 입력한 문자열을 저장한다. 
  gets_s(pszName, sizeof(char)*32);
  // 동적 할당한 메모리의 주소를 호출자 함수에 반환한다. 
  return pszName;
}

int main(int argc, char* argv[])
{
  char *pszName = NULL;

  // 이름이 저장된 동적 할당된 메모리의 주소를 반환받는다. 
  pszName = GetName();
  printf("당신의 이름은 %s입니다.", pszName);

  // 호출자 함수가 메모리를 해제해야 한다. 
  free(pszName);
  return 0;

}
                            </code>
                          </pre>
                          <hr>
                          Call by reference를 이용한 교환 예제 
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>

// 매개변수로 주소를 받는다. 
void Swap(int *pLeft, int *pRight){
  // 주소를 가리키는 대상의 메모리 값을 교환한다. 
  int nTmp = *pLeft;
  *pLeft = *pRight;
  *pRight = nTmp;
}

int main(int argc, char* argv[]){
  int x = 10, y = 20;

  // 호출자 함수 안에 선언된 지역 변수의 주소를 전달한다. 
  // 따라서 함수가 반환한 후 x와 y의 값은 서로 교환된다.
  Swap(&x, &y);
  printf("%d %d\n", x, y);
  return 0;
}

                            </code>
                          </pre>
                          <hr>
                          문자열의 길이를 측정하는 기능 
                          <hr>
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>

// 매개변수로 전달된 문자열의 길이를 반환하는 함수
int GetLength(const char *pszParm)
{
  int nLength = 0;

  while ( pszParm[nLength] != '\0')
    nLength++;

  return nLength;
}

int main(int argc, char* argv[])
{
  char *pszData = "Hello";

  printf("%d\n", GetLength("Hi"));
  printf("%d\n", GetLength(pszData));
  return 0;
}
                            </code>
                          </pre>
                          <hr>
                          잘못된 주소 전달의 예
                          <hr>
                          <pre>
                            <code class="c" >
#include &lt;stdio.h>

int* TestFunc(void){
  int nData = 10;
  // 함수가 반환되면 소멸할 자동 변수의 주소를 반환한다. 
  // 운영체제에 반환했거나 곧 사라질 메모리에 대한 주소를 반환하는 일은 없어야 합니다. 
  return &nData;
}

int main(int argc, char* argv[]){
  int *pnResult = NULL;
  pnResult = TestFunc();

  // 포인터가 가리키는 대상 메모리는 유효하지 않은 메모리이다. 
  printf("%d\n" ,  *pnResult);
  return 0;
}
                            </code>
                          </pre>
                        </div>
                      </div>
                    </div>
                    <div class="card">
                      <div class="card-header" id="headingFour">
                        <h2 class="mb-0">
                          <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseFour" aria-expanded="false" aria-controls="collapseTwo">
                            스택 프래임
                          </button>
                        </h2>
                      </div>
                      <div id="collapseFour" class="collapse" aria-labelledby="headingFour" data-parent="#accordionExample">
                        <div class="card-body">
                        자동 변수는 스택 영역 메모리를 사용합니다. 자동변수는 기억 부류 auto로 선언된 변수를 말하는데 별도로 명시하지 않은 모든 지역 변수는 모두 자동변수입니다. 
                        함수의 매개변수 역시 자동변수이고 함수의 지역 변수입니다. 따라서 함수 내부에 선언된 변수와 매개변수는 기본적으로 '스택'을 사용합니다. 
                        <hr>
                        스택은 선형 자료구조의 일종으로 정보를 층층이 쌓아 올린 구조입니다. 
                        <hr>
                        <strong>스택과 메모리의 주소는 반대 방향을 그린다.</strong>
                        <hr>
                        스택의 왼쪽에는 함수의 이름과 스코프의 시작 지점을 표시하고 오른쪽에서는 식별자 이름을 기술합니다. 
                        우리가 작성하는 모든 예제들은 항상 main()함수에서 시작하므로 최초로 늘어난 스택은 main()함수에 속한 것으로 가정합니다. 그리고 
                        그림에서 스택은 위로 증가합니다. 그러나 메모리리의 주소는 아래로 증가합니다. 따라서 메모리 주소가 증가 했다는 것은 스택이 들어들었음을
                        의미하고 주솟값이 작어졌다는 것은 스택의 증가를 의미한다고 생각할 수 있습니다. 
                        <hr>
                          <ul>
                            <li>지역 변수는 선언된 순서대로 그린다.

                            </li>
                            <li>포인터 변수는 별도로 표시한다.
                              <pre>
                                <code  class="c">
#include &lt;stdio.h>

int main(int argc, char* argv[]){
  int x = 10, y = 20;
  int *pnData = &x;

  // 포인터 변수는 간접 지정 대상이 어디인지 포인터가 가리키는 지점을 표시해야한다. 
  *pnData = 100;
  return 0;
}
                                </code>
                              </pre>
                            </li>
                            <li>
                              배열의 인덱스는 아래로 증가하게 그린다.  <br>
                              배열의 인덱스는 주소가 증가하는 방향으로 표시해야합니다. 
                              배열의 이름은 '주소상수' 이므로 그자체가 스택에 Push되지 앟는다는 사실에 주의합니다. 

                            </li>
                            <li>
                              동적할당된 메모리는 따로 표시한다. <br>
                              메모리를 동적할당하거나, 정적 영역을 사용하는 병수가 등장한다면 이는 스택 영역이 아니라 별도로 그려서 표시해야한다.
                              <pre >
                                <code  class="c" >
#include &lt;stdio.h>
#include &lt;stdlib.h>
#include &lt;string.h>

int main(int argc , char* argv[])
{
  int nData = 10;
  char *pszBuffer = NULL;

  pszBuffer = (char*)malloc(12);
  strcpy(pszBuffer, "Hello");
  free(pszBuffer);
  retur 0;
}

                                </code>
                              </pre>
                            </li>
                            <li>
                              매개변수는 오른쪽부터 스택에 그리며 새 스코프는 기존 스택 위에 그린다. <br>
                              만일 main()함수가 다른 사용자 정의함수를 호출할 경우에는 매개변수도 스택에 그려야 하는데 반드시 오른쪽 매개변수부터 먼저 push 하는 것으로 그립니다. <br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
                              <pre>
                                <code class="c">
#include &lt;stdio.h>

int Add(int a, int b)
{
  int nResult = 0;
  nResult = a + b;
  return nResult;
}

int main(int argc, char* argv[])
{
  int nResult = 0;
  nResult = Add(3,4);
  return 0;
}
                                </code>
                              </pre>
                              <hr>
                              함수가 함수를 호출해 함수 몸체에 대한 스코프가 형성되면 스택에 가로선을 길게 그어 표시합니다. 
                              아래의 그림은 main 함수가 Add함수를 호출했다는 것은 Add보다 Main이 먼저 실행됨을 전제 합니다. 
                              따라서 스택에 표시할 때는 main 부터 시작합니다. 
                              <hr>
                              <img src="../cc/StackFrame01.png" class="img-thumbnail"  alt="" srcset="">
                              <hr>
                              Add 함수의 처리가 완료되어 메모리를 반환할 때 아래와 같습니다. 
                              <hr>
                              <img src="../cc/StackFrame03.png" class="img-thumbnail" alt="" srcset="">
                              <hr>
                              동적 할당한 메모리에 저장하고 그 주소를 반환하는 함수를 만든 사례로 실행 과정과 스택 프레임의 변화를 개념적으로 
                              다시 살펴보면, 
                              <hr>
                              <pre class="C" >
                                <code>
#include &lt;stdio.h>
#include &lt;stdlib.h>

char* GetName(void)
{
  char *pszName = NULL;

  pszName = (char*)calloc(32,sizeof(char));
  printf("이름을 입력하세요 :");
  gets_s(pszName, sizeof(char) * 32);
  return pszName;
}

int main(int argc, char* argv[]){
  char *pszName = NULL;

  pszName = GetName();
  printf("당신의 이름은 %s입니다.\n" , pszName);
  free(pszName);
  return 0;
}
                                </code>
                              </pre>
                              동적할당한 메모리의 기준주소가 GetName() 함수의 지역변수인 pszName 에 저장되어 있다는 것 
                              <hr>
                              <img src="../cc/StackFrame05.png" class="img-thumbnail" alt="" srcset=""> <br>
                              GetName() 함수가 반환하면 GetName 함수의 지역변수였던 pszName 은 사실상 사라진다고 봐야합니다. 
                              그러나 그 안에 담겨있던 정보는 호출자 함수인 main() 함수에 반환 값으로 전달됩니다.
                              <hr>
                              피호출자 함수가 메모리를 동적 할당하고 해제하지 않았으나, 해제의 열쇠가 되는 기준 주소를 호출자에 반환함으로써 
                              대상 메모리에 이를 수 있는 방법이 사라지지 않았다는 점이다. 그래서 GetName 함수가 반홚하는 순간에 메모리가 누수될 
                              뻔 하였으나 이를 main() 함수에서 다시 선으로 이어 줌으로써 대상 메모리를 계속 관리할 수 있었습니다. 
                              그리고 만일 main() 함수에서 메모리를 해제하지 않고 함수가 반환한다면 메모리 누수가 발생합니다. 
                              <hr>
                              <img src="../cc/StackFrame06.png" class="img-thumbnail"  alt="" srcset="">
                              <hr>
                              <img src="../cc/StackFrame07.png" class="img-thumbnail" alt="" srcset=""> <br>
                              main() 함수가 GetName() 함수를 호출했고, GetName()함수가 다시 gets_s()함수를 호출햇다는 것. 
                              이는 매우 중요한 프로그램의 흐름을 알려주는 정보인데, 이를 호출 스탤(Call Stack)이라고 부릅니다. 
                              <hr>
                              <pre class="C" >
                                <code>
#include &lt;stdio.h>

int main(void)
{
  int nInput = 0;
  scanf("%d"m &nInput);

  if(nInput > 10){
    int nInput = 20;
    printf("%d\n", nInput);

    if(nInput &lt; 20){
      int nInput = 30;
      printf("%d\n", nInput);
    }
  }

  printf("%d\n", nInput);
  return 0;
}
                                </code>
                              </pre>
                              <hr>
                              <pre class="C" >
                                <code>
#include &lt;stdio.h>

int main(void){
  int nInput = 0;
  scanf("%d", &nInput);

  if( nInput > 10){
    int nInput = 20;
    printf("%d\n", nInput);

    if(nInput &lt; 20){
      int nInput = 30;
      printf("%d\n", nInput);
    }
  }
}
                                </code>
                              </pre>
                              스택에서 식별자를 검색할 때는 스택의 맨 위에서 아래쪽으로 검색합니다. 그리고 최대 함수 스코프까지 검색합니다. 그래도 찾지 못하면 전역변수에서 찾습니다. 
                              식별자 검색에서 가장 최근에 선언된 변수가 우선하는 이유는 스택의 구조 때문에 발생한 자연스러운 결과입니다. 
                              <hr>
                              <strong>
                                정적변수, 전역 변수는 별도로 표시한다. 
                              </strong>
                              <pre class="Java" >
                                <code>
#include &lt;stdio.h>

int TestFunc(void){
  static int nData = 10;
  ++ nData;
  return nData;
}

int main(int argc, char* argv[]){
  printf("%d\n", TestFunc());
  printf("%d\n", TestFunc());
  printf("%d\n", TestFunc());
  return 0;
}
                                </code>
                              </pre>
                              정적변수나 전역변수는 모두 데이터 영역을 사용하는 변수들입니다. 따라서 스택의 일부로 기술할 수 없고, 동적할당한 경우 처럼 별도의 영역에 따로 떼어 표시합니다.
                              즉, 스택이 늘고 줄고를 반복한다 해도 데이터 영역은 아무 관련이 없습니다. 
                            </li>
                          </ul>
                        </div>
                      </div>
                    </div> 
                    <div class="card-header" id="headingOne">
                      <h2 class="mb-0">
                        <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                            재귀 호출 
                        </button>
                      </h2>
                    </div>
                    <div id="collapseOne" class="collapse" aria-labelledby="headingOne" data-parent="#accordionExample">
                      <div class="card-body">
                         재귀 호출(recursive function)은 함수가 내부에서 다시 자기 자신을 호출하는 것입니다. 반복문과 스택 자료구조를 합친 것이 바로 재귀 호출입니다. 
                         논리적인 코....드의 구조는 반복문과 같으나 반복과정에서 선형 자료 구조인 스택이 필요한 경우 재귀호출을 사용합니다. 
                         <hr>
                         <pre class="C" >
                           <code>
#include &lt;stdio.h>

int main(void){
  int i = 0, nFact = 1;
  for ( i = 5 ; i >= 1; --i){
    nFact *= 1;
  }

  printf("5! == %d\n", nFact);
  return 0;
}

#include &lt;stdio.h>

// 계승을 계산하고 결과를 반환하는 함수
int GetFactorial(int nParam){
  int nResult = 0;
  // 재귀호출을 끝내기 위한 조건식! 반복문의 조건식과 같다. 
  if ( nParam == 1) return 1;

  // 매개변수의 값을 1 감소시켜 자기 자신을 다시 호출한다. 
  // 이는 반복문의 계수기와 같다.
  // 아래 행에서 가장 먼저 실행되는 코드는 GetFactorial() 함수를 재귀호출하는 것이다. 
  nResult = nParam * GetFactorial(nParam -1);
  return nResult;
}

int main(void){
  printf("5! == %d\n", GetFactorial(5));
  return 0;
}
                           </code>
                         </pre>
                         <hr>
                         재귀호출에서는 조건에 부합할 때는 함수가 반환하는 방법으로 멈춥니다. 
                          <hr>
                          재귀 호출을 이용한 문자열 출력 
                          <hr>
                          재귀 호출을 하용하는 가장 흔한 경우는 비선형 자료구조를 다룰 때입니다. 비선형 자료구조에는 대표적으로 트리가 있으며, 자료를 계층적 구조로 만든 것이 
                          트리의 특징입니다. 
                          <pre class="c" >
                            <code>
#include &lt;stdio.h>

void PutData(char *pszParam){
  // 문자열의 끝이면 더 이상 재귀 호출은 하지 않고 반환한다. 
  if ( *pszParam == '\0'){
    return;
  }

  // 다음 두 구문의 실행 순서를 바꾸면 문자열이 뒤집어져 출력된다. 
  putchar(*pszParam);

  // 다음 글자를 가리키는 주소를 매개변수로 재귀호출한다.  
  PutData(pszParam + 1);11

}

int main(void){
  PutData("TestData");
  putchar('\n');
  return 0;
}
                            </code>
                          </pre>
                          스택은 가장 먼저 Push 한 정보가 가장 나중에 Pop 되고, 가장 나중에(혹은 최근에) Push한 정보가 가장 먼저 Pop되는 LIFO구조입니다. 
                          이러한 구조가 자주 사용되는 이유는 '되돌리기' 기능과 같은 것을 구현하기 좋기 때문입니다. 
                          스택이 순서를 뒤 바꾼다는 특징을 가진 것이 얼마나 다행스러운 지 모르겠습니다. 우리가 어떤 정보를 다루는 과정에서 로그를 남기고자
                          한다면 스택 형식으로 만드는 것이 좋을 수 있습니다. 왜냐하면 시기적으로 가장 최근에 벌어진 일이 스택의 최상단에 존재하므로 접근하기 쉽기
                          때문입니다. 
                          <hr>
                      </div>
                    </div>
                  </div>
                  <div class="card">
                    <div class="card-header" id="headingTwo">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                          문자/문자열 처리 함수 
                        </button>
                      </h2>
                    </div>
                    <div id="collapseTwo" class="collapse" aria-labelledby="headingTwo" data-parent="#accordionExample">
                      <div class="card-body">               
                        CRL은 많은 표준 함수를 제공합니다. 
                        <hr>
                        <ul>
                          <li>isalpha() : A ~ Z, a ~ z 에 속하는 문자인지 검사하는 함수이다. </li>
                          <li>isdigit() : 0 ~ 9 에 속하는 문자(char)인지 검사하는 함수이다. </li>
                          <li>isxdigit()  : 0 ~ 9, A ~ F, a ~ f 에 속하는 문자(char)인지 검사하는 함수이다.</li>
                          <li>isalnum()  : 0 ~ 9, A ~ Z, a ~ z 에 속하는 문자(char)인지 검사하는 함수이다.</li>
                          <li>islower() : 영문 소문자 인지 검사하는 함수이다. </li>
                          <li>isupper() : 영문 대문자인지 검사하는 함수이다. </li>
                          <li>isspace() : 0x09 ~ 0x0D 혹은 0x20에 속하는 화이트 스페이스 문자인지 검사하는 함수이다. </li>
                          <li>toupper() : 영문 소문자를 대문자로 변환하는 함수이다. </li>
                          <li>tolower() : 영문 대문자를 소문자로 변환하는 함수이다. </li>
                        </ul>   
                        <hr> 
                        문자열 처리함수 
                        <hr>
                        <ul>
                          <li>char *strcat(char *strDestination, const char *strSource);
                            <br>
                            첫 번째 인자로 전달된 주소에 저장된 문자열에 두 번째 인자로 전달될 문자열을 추가해주는 함수이다. 
                            따라서 첫 번째 인자로 전달된 주소에 저장된 문자열의 길이가 늘어난다. 
                          </li>
                          <li>char *strncat(char * strDestination, const char *strSource, size_t count);
                            <br>
                            첫 번째 인자로 전달된 주소에 저장된 문자열에 두 번째 인자로 전달된 문자열을 주어진 길이만큼만 
                            추가해주는 함수이다. 
                          </li>
                        </ul>
                        <pre class="C" >
                          <code>
#include &lt;stdio.h>
#include &lt;string.h>

int main(void){
  char szPath[128] = { "C:\\Program Files\\"};
  char szBuffer[128] = {0};

  printf("Input path : ");
  gets(szBuffer);

  strcat(szPath, szBuffer);
  puts(szPath);
  return 0;
}
                          </code>
                        </pre>
                        strcat 함수는 문자열을 뒤에 붙여주는 함수인데, 문자열의 길이가 늘어날 수록 길이를 측정하기 위해 
                        반복해야 할 횟수가 늘어나고 그만큼 효율을 떨어뜨립니다. 
                        따라서 이를 처리할 수 있는 대안은 strcat 을 우리가 직접 재조정하여 사용하는 것입니다. 
                        새로 만들 함수는 첫 번째 매개변수로 받은 주솟값을 그대로 반환하는 것이 아니라, 두 번째 매개변수로 전달된 문자열을 이어 붙인 후 
                        맨 마지막 문자('\0'이 아닌 문자)가 저장된 메모리의 주소를 반환합니다. 그러면 두 번째로 이어 붙일 때는 문자열의 길이를 처음부터 측정하지 
                        않을 수 있습니다. 
                        <pre class="c" >
                          <code>
#include &lt;stdio.h>
#include &lt;string.h>

char* mystrcat(char *pszDst, char *pszSrc){
  // 대상 메모리에 저장된 문자열의 끝을 찾는다.
  while ( *pszDst != '\0')
    ++pszData;

  // 그 뒤에 새로운 문자열을 이어 붙인다. 
  while ( *pszSrc != '\0')
    *pszDst++ = *pszSrc++;

  // 맨 끝을 NULL 문자로 마무리한다. 
  *++pszDst = '\0';

  // 이어 붙인 문자열의 마지막 글자가 저장된 메모리의 주소를 반환한다. 
  return --pszDst;
}

int main(void){
  char szPath[128] = { 0 };
  char *pszEnd = NULL;

  // 대상 메모리에 문자열을 붙인다. 
  pszEnd = mystrcat(szPath, "C:\\Program Files\\");
  // 앞서 반환한 주소를 첫 번째 인수로 호출해 문자열을 붙인다. 
  pszEnd = mystrcat(pszEnd, "CHS\\");
  pszEnd = mystrcat(pszEnd, "C programming");

  puts(szPath);
  return 0;
}
                          </code>
                        </pre>
                        <hr>
                        sprintf() 함수를 이용한 문자열 붙이기 
                        <hr>
                        문자열은 콘솔 화면이 아니라 '메모리'에 출력한다는 점이 다르다. 
                        <pre class="C" >
                          <code>
#include &lt;stdio.h>
#include &lt;string.h>

int main(void){
  char szPath[128] = {0};
  char szBuffer[128] = {0};
  printf("Input Path : ");
  gets(szBuffer);

  sprintf(szPath, "C:\\Program Files\\%s", szBuffer);
  puts(szPath);
  return 0;
}
                          </code>
                        </pre>
                        sprintf 함수도 보안 결함이 있으므로 sprint_s()나 snprintf() 함수를 사용하는 것이 좋습니다.
                        <hr>
                        strpbrk() 구문 분석 함수 
                        <ul>
                          <li>
                            *strpbrk(const char *string, const char *strCharset); <br>
                            string : 검색 대상 문자열이 저장된 메모리 주소 <br>
                            strCharSet : 검색할 문자 집합 <br>
                            반환 값 : 찾으면 해당 문자가 저장된 메모리 주소 반환, 찾지 못하면 NULL 반환 <br>
                            설명 : 임의의 대상 문자열에서 특정 문자 집합을 검색하는 함수 
                          </li>
                        </ul>
                        <pre class="C" >
                          <code>
#include &lt;stdio.h>
#include &lt;string.h> 

void main(void){
  char szBuffer[128] = { 0 };
  char szSet[128] = { 0 };
  char *pszStart = szBuffer;

  // 검색 대상 문자열을 입력받는다. 
  printf("Input string :");
  gets(szBuffer);

  // 찾을 '문자들'을 입력받는다. 
  printf("Input character set : ");
  gets(szSet);

  while((pszStart = strpbrk(pszStart, szSet)) != NULL){
    printf("[%p] index: %d, %c\n", pszStart, pszStart - szBuffer, *pszStart);

    // 일치하는 하나를 찾았으므로 다음으로 이동하고 계속 찾는다. 
    pszStart ++ ;
  }
}
                          </code>
                        </pre>
                      </div>
                    </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading5">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse5" aria-expanded="false" aria-controls="collapse5">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse5" class="collapse" aria-labelledby="heading5" data-parent="#accordionExample">
                    <div class="card-body">
                        
                    </div>
                  </div>
                </div>  
                <div class="card">
                  <div class="card-header" id="heading7">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse7" aria-expanded="false" aria-controls="collapse7">
                       
                      </button>
                    </h2>
                  </div>
                  <div id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#accordionExample">
                    <div class="card-body">
                       
                    </div>
                  </div>
                </div> 
                
                <div class="card">
                  <div class="card-header" id="heading10">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse10" aria-expanded="false" aria-controls="collapse10">
                      
                      </button>
                    </h2>
                  </div>
                  <div id="collapse10" class="collapse" aria-labelledby="heading10" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading11">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse11" aria-expanded="false" aria-controls="collapse11">
                      
                      </button>
                    </h2>
                  </div>
                  <div id="collapse11" class="collapse" aria-labelledby="heading11" data-parent="#accordionExample">                        
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading13">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse13" aria-expanded="false" aria-controls="collapse13">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse13" class="collapse" aria-labelledby="heading13" data-parent="#accordionExample">
                    <div class="card-body">

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading14">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse14" aria-expanded="false" aria-controls="collapse14">
                       
                      </button>
                    </h2>
                  </div>
                  <div id="collapse14" class="collapse" aria-labelledby="heading14" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading15">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse15" aria-expanded="false" aria-controls="collapse15">
                     
                      </button>
                    </h2>
                  </div>
                  <div id="collapse15" class="collapse" aria-labelledby="heading15" data-parent="#accordionExample">
                    <div class="card-body">
                     
                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading16">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse16" aria-expanded="false" aria-controls="collapse16">
                         
                      </button>
                    </h2>
                  </div>
                  <div id="collapse16" class="collapse" aria-labelledby="heading16" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading17">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse17" aria-expanded="false" aria-controls="collapse17">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse17" class="collapse" aria-labelledby="heading17" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading18">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse18" aria-expanded="false" aria-controls="collapse18">
                 
                      </button>
                    </h2>
                  </div>
                  <div id="collapse18" class="collapse" aria-labelledby="heading18" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading19">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse19" aria-expanded="false" aria-controls="collapse19">
                        
                      </button>
                    </h2>
                  </div>
                  <div id="collapse19" class="collapse" aria-labelledby="heading19" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
                <div class="card">
                  <div class="card-header" id="heading9">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse9" aria-expanded="false" aria-controls="collapse9">
                         
                      </button>
                    </h2>
                  </div>
                  <div id="collapse9" class="collapse" aria-labelledby="heading9" data-parent="#accordionExample">
                    <div class="card-body">

                    </div>
                  </div>
                </div> 
                <div class="card">
                  <div class="card-header" id="heading1700">
                    <h2 class="mb-0">
                      <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#heading1700" aria-expanded="false" aria-controls="heading1700">
                        
                      </button>                    
                    </h2>
                  </div>
                  <div id="heading1700" class="collapse" aria-labelledby="heading1700" data-parent="#accordionExample">
                    <div class="card-body">
                      
                    </div>
                  </div>
                </div>
              </div>                  
            </div>
            <div class="card-footer small text-muted"></div>
          </div>
          
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
    

    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

 

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>
  </body>

</html>
