<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1Lines - ReactJS</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">ReactJS</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      
    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu show" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">React JS</h6>
            <a class="dropdown-item" href="../react/reactjs_001.html">React JS의 시작</a>
            <a class="dropdown-item" href="../react/reactjs_002.html">React 요소</a>
            <a class="dropdown-item" href="../react/reactjs_003.html">React 활용</a>
            <a class="dropdown-item" href="../react/reactjs_004.html">React Hook</a>
            <a class="dropdown-item" href="../react/reactjs_005.html"></a>
            <a class="dropdown-item" href="../react/reactjs_006.html"></a>
            <a class="dropdown-item" href="../react/reactjs_007.html"></a>
            <a class="dropdown-item" href="../react/reactjs_008.html"></a>          
            <a class="dropdown-item" href="../react/reactjs_009.html"></a>
            <a class="dropdown-item" href="../react/reactjs_010.html"></a>
            <a class="dropdown-item" href="../react/reactjs_011.html"></a>
            <a class="dropdown-item" href="../react/reactjs_012.html"></a>
            <a class="dropdown-item" href="../react/reactjs_013.html"></a>
            <a class="dropdown-item" href="../react/reactjs_014.html"></a>
            <a class="dropdown-item" href="../react/reactjs_015.html"></a>
            <a class="dropdown-item" href="../react/reactjs_016.html"></a>
            <a class="dropdown-item" href="../react/reactjs_017.html"></a>
            <a class="dropdown-item" href="../react/reactjs_018.html"></a>
            <a class="dropdown-item" href="../react/reactjs_019.html"></a>
            <a class="dropdown-item" href="../react/reactjs_020.html"></a>
            <a class="dropdown-item" href="../react/reactjs_021.html"></a>
            <a class="dropdown-item" href="../react/reactjs_022.html"></a>
            <a class="dropdown-item" href="../react/reactjs_023.html"></a>
            <a class="dropdown-item" href="../react/reactjs_024.html"></a>
            <a class="dropdown-item" href="../react/reactjs_025.html"></a>
            <a class="dropdown-item" href="../react/reactjs_026.html"></a>
            <a class="dropdown-item" href="../react/reactjs_027.html"></a>
            <a class="dropdown-item" href="../react/reactjs_028.html"></a>
            <a class="dropdown-item" href="../react/reactjs_029.html"></a>
            <a class="dropdown-item" href="../react/reactjs_030.html"></a>
            <a class="dropdown-item" href="../react/reactjs_031.html"></a>
            <a class="dropdown-item" href="../react/reactjs_032.html"></a>
            <a class="dropdown-item" href="../react/reactjs_033.html"></a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>

          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
                ReactJS 의 요소
            </div>
            <div class="card-body">
                <div class="accordion" id="accordionExample">
                  <div class="card">
                    <div class="card-header" id="heading1">
                        <h2 class="mb-0">
                          <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse1" aria-expanded="true" aria-controls="collapse1">
                            props와 state를 나누어 사용하도록 한 이유 ?
                          </button>
                        </h2>
                    </div>
                    <div id="collapse1" class="collapse" aria-labelledby="heading1" data-parent="#accordionExample">
                        <div class="card-body">
                            먼저 개발자들에게 명확한 관념 모델(static mental model)을 제공합니다.  <br>
                            관념 모델은 무엇이 어떻게 동작하는지 이해할 때 진행되는 일련의 사고 프로세스를 의미합니다.  <br>
                            즉, 논리적으로 이치에 맞는 사고 모델을 제공한다는 것이다. <br>
                        </div>
                    </div>
                  </div>
              </div>
                <div class="accordion" id="accordionExample">
                  <div class="card">
                    <div class="card-header" id="headingTwo">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                            create-react-app 을 이용하여 react project 생성하기 
                        </button>
                      </h2>
                    </div>
                    <div id="collapseTwo" class="collapse" aria-labelledby="headingTwo" data-parent="#accordionExample">
                      <div class="card-body">
                        <pre>
                          <code class="shell" >
# create-react-app 을 이용한 작업 환경 구성하기
# npm {명령어} -{옵션} {Package}         
# install Package 설치하기 
# -g 전역에 설치하기                    
> npm install -g create-react-app


> create-react-app hello-world 

> cd hello-world

> npm start 
                          </code>
                        </pre>                        
                      </div>
                    </div>
                  </div>
                  <div class="card">
                    <div class="card-header" id="headingThree">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                            create-react-app 을 이용하지 않고 빌드없이 바로 이용하기 
                        </button>
                      </h2>
                    </div>
                    <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordionExample">
                      <div class="card-body">
                          <a href="https://beomi.github.io/2017/03/20/Using-ES6-JSX-on-Client/" target="_blank" rel="noopener noreferrer">build 없이 바로 배포하기</a>
                          <hr>
<pre>
  <code class="html" >
      &lt;!DOCTYPE html>
      &lt;html lang="en">
      &lt;head>
        &lt;meta charset="UTF-8">
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0">
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge">
        &lt;title>Document&lt;/title>
      &lt;/head>
      &lt;body>
          &lt;div id="root">&lt;/div>
          &lt;script src="https://unpkg.com/react@15/dist/react.js">&lt;/script>
          &lt;script src="https://unpkg.com/react-dom@15/dist/react-dom.js">&lt;/script>
          &lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.js">&lt;/script>
          &lt;script src="./js/app.js" type="text/babel">&lt;/script> 
      &lt;/body>
      &lt;/html>
  </code>
</pre>   
<pre>
  <code class="javascript" >
// js/app.js 
ReactDOM.render(
  &lt;h1>Hello, world!&lt;/h1>,
  document.getElementById('root')
);
  </code>
</pre>                       
                      </div>
                    </div>
                  </div>
                  <div class="card">
                    <div class="card-header" id="heading5">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse5" aria-expanded="false" aria-controls="collapse5">
                          React의 Rendering 처리 
                        </button>
                      </h2>
                    </div>
                    <div id="collapse5" class="collapse" aria-labelledby="heading5" data-parent="#accordionExample">
                      <div class="card-body">

                          <strong>ReactDOM의 역할</strong><br>
                          React.js는 자바스크립트 내에 DOM Tree와 같은 구조체를 VIRTUAL DOM으로 갖고 있습니다. 
                          다시 그릴 때는 그 구조체의 전후 상태를 비교하여 변경이 필요한 최소한의 요소만 실제 DOM에 반영합니다. 
                          따라서 무작위로 다시 그려도 변경에 필요한 최소한의 DOM만 갱신되기 때문에 빠르게 처리할 수 있습니다.
                          <hr>
                          <img src="../react/workflowRenderingBrowser.png" alt="">
                          <hr>
                          Virtual DOM 은 DOM 차원에서의 더블 버퍼링이랑 다름이 없다. <br>
                          변화가 일어나면 그것을 오프라인 DOM 트리에 적용시키는데,  <br>
                          이 DOM 트리는 렌더링도 되지 않기때문에 연산 비용이 적다. <br>
                          연산이 끝나고나면 그 최종적인 변화를 실제 DOM 에 던져주는 것이다.   <br>
                          그러면, 레이아웃 계산과 리렌더링의 규모는 커지겠지만, 딱 한번만 연산이 일어나게 된다.  <br>
                          바로 이렇게, 하나로 묶어서 적용시키는것이, 연산의 횟수를 줄일 수 있는 방법이다.  <br>
                          <hr>
                          React가 DOM보다 빠른 것이 아니라, 유지보수 가능한 어플리케이션을 만드는 것을 도와주고 대부분의 경우에 '충분히 빠르다.' <br>
                          실제로 최적화 작업을 직접 했을 때가 React를 사용했을 때 보다 빠르지만 이를 자동화하여 처리해주는 React가 유지보수 및 생산성을 고려하였을 때 배가 되는 것 <br>
                          React 를 사용한다고 해도 최적화 작업이 제대로 이뤄지지 않으면 오히려 속도가 더 느릴수도 있다. 
                      </div>
                    </div>
                  </div>  
                  <div class="card">
                    <div class="card-header" id="heading14">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse14" aria-expanded="false" aria-controls="collapse14">
                          Component Lifecycle 
                        </button>
                      </h2>
                    </div>
                    <div id="collapse14" class="collapse" aria-labelledby="heading14" data-parent="#accordionExample">
                      <div class="card-body">
                         컴포넌트의 생명주기는 16.3을 기점으로 나뉜다. <br>
                         아래는 16.3 이전, 이후에서 사용되는 모든 컴포넌트 생명주기 함수에 대해서 mounting, unmounting, updating 시점에 따라서 알아보겠다. 
                         <hr>
                         <img src="../react/component-lifecyle.png" class="img-fluid" alt="">
                         <hr>
                         <div class="list-group">
                          <a href="#" class="list-group-item list-group-item-action">
                            <div class="d-flex w-100 justify-content-between">
                              <h5 class="mb-1">  1. Mounting <br></h5>
                              <small></small>
                            </div>
                            <p class="mb-1">
                              컴포넌트 객체가 생성된 후, DOM으로 주입(삽입)될 때<br>
                              React Native의 실행되는 함수의 순서는 <br>
                                - constructor<br>
                                - static getDerivedStateFromProps ( React v16.3 부터 제공 )  - componentWillReceiveProps ( React v16.3 이전 ) <br>
                                - render<br>
                                - componentDidMount<br>
                              </p>
                            <small></small>
                          </a>
                          <a href="#" class="list-group-item list-group-item-action">
                            <div class="d-flex w-100 justify-content-between">
                              <h5 class="mb-1">2. Updating<br></h5>
                              <small class="text-muted"></small>
                            </div>
                            <p class="mb-1">브라우저 상에 React 컴포넌트가 표시되거나, 새로운 갱신(변경)이 발생했을 때<br>
                              React Native의 실행되는 함수 순서는 <br>
                            
                                - static getDerivedStateFromProps ( React v16.3 부터 제공 )   - componentWillReceiveProps ( React v16.3 이전 ) <br>
                            
                                - shouldComponentUpdate<br>
                            
                                - render <br>
                            
                                - getSnapshotBeforeUpdate ( React v16.3 부터 제공 ) - componentWillUpdate ( React v16.3 이전 )<br>
                            
                                - componentDidUpdate<br>
                              </p>
                            <small class="text-muted"></small>
                          </a>
                          <a href="#" class="list-group-item list-group-item-action">
                            <div class="d-flex w-100 justify-content-between">
                              <h5 class="mb-1">3. UnMounting<br></h5>
                              <small class="text-muted"></small>
                            </div>
                            <p class="mb-1">
                              해당 컴포넌트가 더이상 필요하지 않고, 컴포넌트가 해제(분리)될 때<br>
                              React Native 의 실행되는 함수 순서는 <br>
                                - componentWillUnmount<br>
                            </p>
                            <small class="text-muted"></small>
                          </a>
                          <a href="#" class="list-group-item list-group-item-action">
                            <div class="d-flex w-100 justify-content-between">
                              <h5 class="mb-1">4. Error Handling<br></h5>
                              <small class="text-muted"></small>
                            </div>
                            <p class="mb-1">                       
                              생명주기 함수 내, 생성자 내, 모든 하위 컴포넌트의 생성자 내의 렌더링 과정 상에서 에러가 발생할 때<br>
                              React Native 의 실행되는 함수 순서는 <br>
                                - getDerivedStateFromError<br>
                                - componentDidCatch ( React v16.3 부터 제공 ) <br>
                                > getDerivedStateFromError, componentDidCatch는 동일한 에러를 잡는데, 실제 전달되는 인자가 다르다.<br> 
                                  ~ getDerivedStateFromError 는 "render" 단계에 호출되며, 외부 함수에 의한 영향 ( SideEffect ) 까지 포함되지 않는다. <br>
                                  ~ sideEffect가 포함되어야하는 경우에는 componentDidCatch를 사용해야 한다. <br>
                            </p>
                            <small class="text-muted"></small>
                          </a>
                        </div>
                      </div>
                    </div>
                  </div>  
                                    
                  <div class="card">
                    <div class="card-header" id="headingFour">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseFour" aria-expanded="false" aria-controls="collapseTwo">
                          JSX
                        </button>
                      </h2>
                    </div>
                    <div id="collapseFour" class="collapse" aria-labelledby="headingFour" data-parent="#accordionExample">
                      <div class="card-body">
                        JSX : Javascript + XML 을 합쳐서 JSX라고 말한다. 
<pre>
  <code class="javascript" >
const element = &lt;h1>Hello, world!&lt;/h1>;

ReactDOM.render(
  element,
  document.getElementById('root')
);
  </code>
</pre>            
위의 코드에서 볼 수 있듯이 마치 html 의 요소를 정의한 것처럼 보이지만 이는 모두 JSX에 선언된 요소들이라고 보는게 옳다. <br>
<hr>
JSX를 이용하여 동적인 페이지를 만들고 싶을 때는 아래와 같이 코드 작성이 가능하다. <br>
<pre>
  <code class="javascript" >
function getHelloWorldByYourName(user){
  return user.myName;
};

const user = {
    myName : "홍길동"
};

const element = (
  &lt;h1>&lt;strong>My Name is {getHelloWorldByYourName(user)}&lt;/strong>&lt;/h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);
  </code>
</pre>
<hr>
JSX에서의 표현식
<hr>
<pre>
  <code class="Javascript" >
const name = 'Jeong Seung Hwa';
const element = &lt;h1>Hello, {name}&lt;/h1>;

ReactDOM.render(
  element,
  document.getElementById('root')
);
  </code>
</pre>
<hr>
JSX에서의 요소 바인딩 
<hr>
<pre>
  <code class="Javascript" >
function formatName(user) {
  return user.firstName + ' ' + user.lastName;
}

const user = {
  firstName: 'Jeong',
  lastName: 'Seung Hwa'
};

const element = (
  &lt;h1>
    Hello, {formatName(user)}!
  &lt;/h1>
);

ReactDOM.render(
  element,
  document.getElementById('root')
);
  </code>
</pre>
<hr>
속성에 대한 정의 
<hr>
<pre>
  <code class="JavaScript" >
// 따옴표를 이용햇 문자열 리터럴을 정의할 수 있습니다. 
const element = &lt;div tabIndex="0">&lt;/div>;

// 중괄호를 사용하여 어트리뷰트에 JavaScript 표현식을 삽입할 수도 있습니다. 
const element = &lt;img src={user.avatarUrl}>&lt;/img>;
  </code>
</pre>
<hr>
JSX로의 자식 정의 
<hr>
<pre>
  <code class="Javascript" >
      // tag 안의 자식 요소를 포함할 수 있습니다. 
      const element = (
        &lt;div>
          &lt;h1>Hello!&lt;/h1>
          &lt;h2>Good to see you here.&lt;/h2>
        &lt;/div>
      );      
  </code>
</pre>
<hr>
JSX는 주입 공격을 방지합니다. 
<hr>
기본적으로 React DOM은 JSX에 삽입된 모든 값을 렌더링 하기 전에 이스케이프하므로, 애플리케이션에서 명시적으로 작성되지 않은 내용은 주입되지 않습니다. <br>
모든 항목은 렌더링 되기 전에 문자열로 변환됩니다. 
<hr>
JSX는 객체를 표현합니다. 
<hr>
<pre>
  <code class="Javascript"  >
// 아래의 두개의 코드는 모두 createElment를 호출하는 방식이지만 표현식이 다릅니다. 
const element = (
  &lt;h1 className="greeting">
    Hello, world!
  &lt;/h1>
);

const element = React.createElement(
  'h1',
  {className: 'greeting'},
  'Hello, world!'
);
  </code>
</pre>
<hr>
JSX 속성 요소
<hr>
<pre class="XML" >
  <code >
    accept acceptCharset accessKey action allowFullScreen allowTransparency alt
    async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge
    charSet checked classID className colSpan cols content contentEditable
    contextMenu controls coords crossOrigin data dateTime default defer dir
    disabled download draggable encType form formAction formEncType formMethod
    formNoValidate formTarget frameBorder headers height hidden high href hrefLang
    htmlFor httpEquiv icon id inputMode integrity is keyParams keyType kind label
    lang list loop low manifest marginHeight marginWidth max maxLength media
    mediaGroup method min minLength multiple muted name noValidate nonce open
    optimum pattern placeholder poster preload radioGroup readOnly rel required
    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected
    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style
    summary tabIndex target title type useMap value width wmode wrap
  </code>
</pre>

                      </div>
                    </div>
                  </div>  
                  <div class="card">
                    <div class="card-header" id="heading4-1">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse4-1" aria-expanded="false" aria-controls="collapse4-1">
                          Element 
                        </button>
                      </h2>
                    </div>
                    <div id="collapse4-1" class="collapse" aria-labelledby="heading4-1" data-parent="#accordionExample">
                      <div class="card-body">
                        
                        <pre>
                          <code class="Javascript" >
const element = &lt;h1> Hello, World &lt;/h1>;
// 브라우저의 DOM 엘리먼트와 달리 React 엘리먼트는 일반 객체이며 쉽게 생성할 수 있습니다. 
// React DOM 은 React 엘리먼트와 일치하도록 DOM을 업데이트합니다. 
                          </code>
                        </pre>

                        <hr>
                          DOM에 엘리먼트 렌더링하기 
                        <hr>
                         <pre>
                           <code class="Javascript" >
// 이 안에 들어가는 모든 엘리먼트를 React DOM에서 관리하기 때문에 이것을 "루트(root)" DOM 노드라고 부릅니다. 
&lt;div id="root" > &lt;div>

// React 엘리먼트를 Root 엘리먼트에 로딩하려면 아래와 같이 사용합니다. 
const element = &lt;h1>Hello, world&lt;/h1>;
ReactDOM.render(element, document.getElementById('root'));
                           </code>
                         </pre>
                         <hr>
                          렌더링 된 엘리먼트 업데이트 하기 
                         <hr>
                         <pre>
                           <code class="Javascript" >
// ReactDOM 의 render에 의해서 UI 요소를 갱신하는 방식                             
function tick() {
  const element = (
    &lt;div>
      &lt;h1>Hello, world!&lt;/h1>
      &lt;h2>It is {new Date().toLocaleTimeString()}.&lt;/h2>
    &lt;/div>
  );
  ReactDOM.render(element, document.getElementById('root'));
}

setInterval(tick, 1000);
                           </code>
                         </pre>
                      </div>
                    </div>
                  </div> 
                  <div class="card">
                    <div class="card-header" id="headingOne">
                      <h2 class="mb-0">
                        <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                           JavaScript - Import, Export 
                        </button>
                      </h2>
                    </div>
                
                    <div id="collapseOne" class="collapse" aria-labelledby="headingOne" data-parent="#accordionExample">
                      <div class="card-body">
                        자바스크립트는 호이스팅으로 인하여 변수나 함수가 전역에서 사용될 수 있었기 때문에 이름 충돌이 잦게 발생하였습니다. 
                        ES6 부터는 모듈의 개념이 추가되어 Java, C# 처럼 Export, Import를 사용할 수 있게 되었다. 
                        <hr>
                        하지만 브라우저에서 지원이 되지 않고 있기 때문에 webpack과 같은 모듈 번들러를 사용해야만 모듈 시스템(import, export)를 이용할 수 있다. 
                        <hr>
                        <a href="https://github.com/AriaFallah/WebpackTutorial/tree/master/part1" target="_blank" >webpack 따라하며 배우기</a>
                        <pre>
                          <code class="javascript" >                       
// custom.js
Class custom {
  constructor(customName){
    this.customName = customName;
  }
}
                          </code>
                        </pre>
                      </div>
                    </div>
                  </div>
                  
                  <div class="card">
                    <div class="card-header" id="heading4-2">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse4-2" aria-expanded="false" aria-controls="collapse4-2">
                          Components 
                        </button>
                      </h2>
                    </div>
                    <div id="collapse4-2" class="collapse" aria-labelledby="heading4-2" data-parent="#accordionExample">
                      <div class="card-body">
                        컴포넌트 기반 소프트웨어 공학 ( Component-based software engineering)
                        <hr>
                        CBD는 개발 방법론의 핵심이 되는 '재사용성','생산성' 등을 향상시키며 요구사항이 수시로 바뀌는 현대의 서비스 개발에 특화되어 빠르게 서비스를 피벗하거나 사용자가 급등할 수 있는 환경을 고려해 유연한 환경을 조성하는데 도움이 됩니다. <br>
                        <hr>
                        <div class="list-group">
                          <a href="#" class="list-group-item list-group-item-action">
                            <div class="d-flex w-100 justify-content-between">
                              <h5 class="mb-1">Uncontrolled component</h5>
                              <small></small>
                            </div>
                            <p class="mb-1">
                              Uncontrolled Component는 상태를 직접 제어하지 않습니다. 
                              <pre class="C" >
                                <code>
const Hello = () => &lt;div>Hello&lt/div>

const Hi = () => &lt;div>Hi&lt/div>
                                </code>
                              </pre>
                              <a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key" target="blank" >추천 : 키를 사용한 완벽하게 제어되지 않는 컴포넌트 ( Uncontrolled Component )</a>
                            </p>
                            <small></small>
                          </a>
                          <a href="#" class="list-group-item list-group-item-action">
                            <div class="d-flex w-100 justify-content-between">
                              <h5 class="mb-1">Controlled component</h5>
                              <small class="text-muted"></small>
                            </div>
                            <p class="mb-1">
                              상태를 직접제어하는 컴포넌트 입니다. 
                              <pre class="javascript" >
                                <code>
const HelloWorld = () => {
  const [value, setValue] = userState(0)

  return (
    &lt;HelloComponent handleClick={setValue} >
      { value ? &lt;Hello /> : &lt;Hi /> }
    &lt;/HelloComponent>
  )
}                                    
                                </code>
                              </pre>
                            </p>
                            <small class="text-muted"></small>
                          </a>
                          <a href="#" class="list-group-item list-group-item-action">
                            <div class="d-flex w-100 justify-content-between">
                              <h5 class="mb-1">Pure component</h5>
                              <small class="text-muted"></small>
                            </div>
                            <p class="mb-1">
                              Pure Component는 리액트를 이용한 컴포넌트 기본 개발 방법에서 가장 기본적인 컴포넌트입니다. 
                              Pure Component와 Component는 매우 유사하지만. 다른점이 있다면 React의 생명주기 메소드인 shouldComponentUpdate 를 다루는 방식에 있다. 
                              Component의 경우 setState가 실행되는 모든 순간에 Component가 Re-Rendering이 발생하지만, PureComponent의 경우에는 setState에서 Value가 
                              실제로 변경될 때만 Re-Rendering이 일어나게 된다. 
                              <hr>
                              <pre class="javascript" >
                                <code>
import React , { PureComponet } from 'react';

Class HelloWorld extend PureComponent {
  constructor(props){
    super(props);
    this.state = {
      value : 0
    }

    this.call_event = this.call_event.bind(this);
  }

  call_event() {=
    if(특정 조건){
      this.setState({
        counter: this.state .value + 변경값,
      });
    }else {
      this.setState({
        counter: this.state.value
      });
    }
  }

  render(){
    return (
      &lt;div>
       {this.state.value}
        &lt;br>
        &lt;input
          type="button"
          onClick={this.call_event}
          value="click"
        />
      &lt;/div>
    )
  }
}
                                </code>
                              </pre>
                            </p>
                            <small class="text-muted"></small>
                          </a>

                          <a href="#" class="list-group-item list-group-item-action">
                            <div class="d-flex w-100 justify-content-between">
                              <h5 class="mb-1">Portal component</h5>
                              <small class="text-muted"></small>
                            </div>
                            <p class="mb-1">
                              React 버전 16부터 도입된 방법으로써, 컴포넌트를 렌더링할 때, UI를 어디에 렌더링 시킬지 DOM을 선택하여 부모 컴포넌트의 바깥에 렌더링할 수 있게 
                              해주는 기능입니다. 기존의 리액트에서는 컴포넌트를 렌더링 하게 될 때, 하위 컴포넌트들은 부모 컴포넌트의 DOM 내부에서 동작했어야 했지만, Portals를 사용하면
                              DOM의 계층 구조 시스템에 종속되지 않으면서 컴포넌트를 렌더링 할 수 있습니다. 
                              <pre class="javascript" >
                                <code>
import ReactDOM from 'react-dom';

const ModalPortal = ({ children }) => {
  const el = document.getElementById('modal');
  return ReactDOM.createPortal(children, el);
};

export default ModalPortal;
                                </code>
                              </pre>
                              
                              <pre class="html">
                                <code>
&lt;body>
    You need to enable JavaScript to run this app.
    &lt;/noscript>
  &lt;div id="root"><div>
  &lt;div id="modal"><div>
&lt;body>
                                </code>
                              </pre>
                              우리가 해당 컴포넌트 방식을 사용하게 되면 우리가 원하는 컴포넌트의 결과를 DOM의 특정 엘리먼트에 렌더링 할 수 있게 됩니다. 
                            </p>
                            <small class="text-muted"></small>
                          </a>
                          <a href="#" class="list-group-item list-group-item-action">
                            <div class="d-flex w-100 justify-content-between">
                              <h5 class="mb-1">Functional Component</h5>
                              <small class="text-muted"></small>
                            </div>
                            <p class="mb-1">
                              함수형 컴포넌트라고 부르며, 16.8전가지는 함수형 컴포넌트와 클래스 기반 컴포넌트의 성능 차이는 거의 드러나지 않았습니다. 
                              하지만 16.8에서 hooks가 도입되면서 함수형 컴포넌트에서 성능 최적화(useMemo, useCallback 등)를 진행할 수 있고, 라이프사이클(useEffect)를 
                              제어할 수 있어 성능적으로 함수형 컴포넌트가 우위에 있다고 할 수 있습니다. 
                              <hr>
                              함수형 컴포넌트와 React Hook 
                              <hr>
                             
                              <ul>
                                <li>useState</li>
                                <li>useEffect</li>
                                <li>useContext</li>
                                <li>useReducer</li>
                                <li>useCallback</li>
                                <li>useMemo</li>
                                <li>useRef</li>
                                <li>useImperativeHandle</li>
                                <li>useLayoutEffect</li>
                                <li>useDebugValue</li>
                              </ul>
                            </p>

                          </a>
                          <a href="./reactjs_004.html">React Hook에 대해서 자세히 알아보기 </a>  
                            <a href="#" class="list-group-item list-group-item-action">
                              <div class="d-flex w-100 justify-content-between">
                                <h5 class="mb-1">Presentaitional Component</h5>
                                <small class="text-muted"></small>
                              </div>
                              <p class="mb-1">
                                Presentaitional Component는 데이터와 관련된 이벤트 혹은 State 관리 없이 사용자에게 보여지는 뷰만을 관리합니다. DOM Element, style 등이 들어가며
                                ReadOnly Component라고도 부를 수 있습니다. 또한, 대부분의 경우 state를 갖고 있지 않으며, 갖고 있을 경우엔 데이터와 관련된 것이아니라 UI와 관련된
                                것이어야 합니다. 
                              </p>
                              <small class="text-muted"></small>
                            </a>
                            <a href="#" class="list-group-item list-group-item-action">
                              <div class="d-flex w-100 justify-content-between">
                                <h5 class="mb-1">Container Component</h5>
                                <small class="text-muted"></small>
                              </div>
                              <p class="mb-1">
                                여러 컴포넌트를 관리하기 위해서 작성되며, DOM Elements를 직접적으로 수정하거나 관리하지 않습니다. 
                              </p>
                              <small class="text-muted"></small>
                            </a>
                        </div>
                        <hr>
                        Components를 정의하는 방법은 JavaScript 함수를 정의하는 것 
                        <hr>
                        <pre>
                          <code class="Javascript" >
// props 는 속성을 나타내는 데이터                             
function Welcome(props) {
  return &lt;h1>Hello, {props.name}&lt;/h1>;
}

// ES6 class를 사용하여 컴포넌트를 정의할 수 있습니다
class Welcome extends React.Component {
  render(){
    return &lt;h1> Hello, {this.props.name}&lt;/h1>
  }
}
                          </code>
                        </pre>
                        <hr>
                        <strong>컴포넌트 렌더링</strong>
                        <hr>
                        <pre>
                          <code class="Javascript" >
function Welcome(props){
  return &lt;h1> Hello, {props.name} &lt;/h1>
}   
// React 엘리먼트는 사용자 정의 컴포넌트로도 나타낼 수 있습니다. 
const element = &lt;Welcome name="Sara" />

// React가 사용자 정의 컴포넌트로 작성한 엘리먼트를 발견하면 JSX 어트리뷰트를 해당 컴포넌트에 단일 객체로 전달합니다. 
// 이 객체를 "props" 라고 합니다. 
ReactDOM.render(
  element,
  document.getElementById('root')
)

                          </code>
                        </pre>
                        <hr>
                        주의: 컴포넌트의 이름은 항상 대문자로 시작합니다. <br>
                        React는 소문자로 시작하는 컴포넌트를 DOM 태그로 처리합니다. <br>
                        예를 들어 &lt;div />는 HTML div 태그를 나타내지만, &lt;Welcome />은 컴포넌트를 나타내며 범위 안에 Welcome이 있어야 합니다.
                        <hr>
                        <strong>컴포넌트 합성 </strong> <br>
                        컴포넌트는 자신의 출력에 다른 컴포넌트를 참조할 수 있습니다. 이는 모든 세부 단계에서 동일한 추상 컴포넌트를 사용할 수 있음을 의미합니다. <br>
                        
                        <pre>
                          <code class="Javascript" > 
function Welcome(props) {
  return &lt;h1>Hello, {props.name}&lt;/h1>;
}

function App() {
  return (
    &lt;div>
      &lt;Welcome name="Sara" />
      &lt;Welcome name="Cahal" />
      &lt;Welcome name="Edite" />
    &lt;/div>
  );
}

ReactDOM.render(
  &lt;App />,
  document.getElementById('root')
);
                          </code>
                        </pre>
                        <hr>
                        <pre>
                          <code class="Javascript" >
function formatDate(date) {
  return date.toLocaleDateString();
}

function Avatar(props){
  return (
    &lt;img className="Avatar" 
      src={props.user.avatarUrl}
      alt={props.user.name}
  )
}

function UserInfo(props){
  return (
    &lt;div className="UserInfo">
      &lt;Avatar user={props.user} />
      &lt;div className="UserInfo-name">
        {props.user.name}
      &lt;/div>
    &lt;/div>
  )
}

function Comment(props) {
  return (
    &lt;div className="Comment">
      &lt;UserInfo user={props.author} />
      &lt;div className="Comment-text">{props.text}&lt;/div>
      &lt;div className="Comment-date">
        {formatDate(props.date)}
      &lt;/div>
    &lt;/div>
  );
}
                            
                          </code>
                        </pre>
                        <hr>
                      </div>
                    </div>
                  </div> 
                  <div class="card">
                    <div class="card-header" id="heading8">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse8" aria-expanded="false" aria-controls="collapse8">
                          React - Props   
                        </button>
                      </h2>
                    </div>
                    <div id="collapse8" class="collapse" aria-labelledby="heading8" data-parent="#accordionExample">
                      <div class="card-body">
                        Props는 프로퍼티 용어의 약어 입니다. props는 컴포넌트에서 전달해서 보관하길 원하는 데이터 입니다. 즉, 컴포넌트 내에서 보관되면, 이 데이터는 수정되지 않고 보존되어야 하는 법칙이 성립된다. 만약 props의 값을 변경하고자 할 때는 컴포넌트 내부가 아닌, 부모 컴포넌트에서 
                        이에 대한 부분이 변경되어야 합니다. 
                        <hr>
                        <ul>
                          <li>props는 읽기 전용입니다.</li>
                          <li>모든 React 컴포넌트는 자신의 props를 다룰 때 반드시 순수 함수 처럼 동작해야 합니다.</li>
                          <li>props의 이름은 사용될 context가 아닌 컴포넌트 자체의 관점에서 짓는 것을 권장합니다. </li>
                        </ul>
                        <hr>
                        props는 React에서는 사용자가 컴포넌트에서 전달해서 보관하길 원하는 데잍어입니다. 즉, 컴포넌트 내에서 데이터가 보관되면. 이 데이터는 수정되지 않고 보존되어야 하는 법칙이 성립됩니다. 
                        <hr>
                        <pre class="JavaScript" >
                          <code>
// Class Component 사용시                             
import React, { Component } from 'react'

class HelloWorld extends Component {
  static defaultProps = {
    name : 'My World'
  }
  render() {
    return {
      &lt;div>
        Hello World! , &lt;b> {this.props.name} &lt;/b>
      &lt;/div>
    }
  }
}

export default MyName;

// Function Component 사용시 
const HelloWorld = ({ name }) => {
  return (
    &lt;div>
      안녕하세요! 제 이름은 {name} 입니다.
    &lt;/div>
  );
};

HelloWorld.defaultProps = {
  name : "Hello World"
}

export default HelloWorld;
                          </code>
                        </pre>
                        <hr>
                        props의 설정은 propTypes를 통해 객체를 설정하거나, getDefaultProps를 통해 props 값을 받아올 수 있습니다. 
                        <pre class="javascript" > 
                          <code>
var post = React.createClass({
  propTypes : {
      value : React.PropTypes.String
  }
});
                          </code>
                        </pre> 
                        <hr>
                        컴포넌트가 외부와의 데이터를 주고 받기 위해 props를 사용했는데, 이럴 경우 props의 Type을 확인해줘야하는 필요성이 생깁니다. 
                        이럴 경우, React.PropType를 이전에서는 사용했지만 React 15.5부터는 prop-types라는 npm을 통해 해결합니다. <br>
                        Prop-Type에서 제공하는 Type들은 array, bool,func,number,object,string,symbol,node,element 입니다. <br>
                        Type Checking의 경우, instanceOf(),oneOf([[array]]),oneOfType([[array]]) 와 같은 함수들을 사용해서 Type Checking을 할 수 있습니다. <br>
                        <pre class="shell" >
                          <code>
$ npm install --save prop-types
                          </code>
                        </pre>
                        <pre class="javascript" >
                          <code>
                            
import PropTypes from 'prop-types';

// 아래와 같이 타입을 지정할 수 있습니다. 
App.propTypes = {
  value: PropType.string
}
                          </code>
                        </pre>
                        <hr>
                        PropTypes의 예제
                        <pre class="javascript" >
                          <code>
var HelloWorld = React.createClass({
  // Class 컴포넌트 생성 시점에 propTyps를 설정하는 경우 ,
  propTypes: {
    name:   React.PropTypes.string.isRequired,
    id:     React.PropTypes.number.isRequired,
    width:  React.PropTypes.number.isRequired,
    height: React.PropTypes.number.isRequired,
    alt:    React.PropTypes.string
  },
  render() {
    var src = `/img/helloworld/${this.props.id}.png`;
    return (
      &lt;div>
        &lt;img src={src} width={this.props.width} height={this.props.height} alt={this.props.alt} />
        &lt;span>{this.props.name}&lt;/span>
      &lt;div>
    );
  }
});

// ES6에서 PropTypes를 지정하는 방식
HelloWorld.propTypes =  {
  user: React.PropTypes.shape({
    id:   React.PropTypes.number.isRequired,
    name: React.PropTypes.string.isRequired
  })
};


&lt;HelloWorld name="hello" id=1 width=100 height=100 />
                          </code>
                        </pre>
                      </div>
                    </div>
                  </div> 
                  <div class="card">
                    <div class="card-header" id="heading7">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse7" aria-expanded="false" aria-controls="collapse7">
                          React - State 
                        </button>
                      </h2>
                    </div>
                    <div id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#accordionExample">
                      <div class="card-body">
                        동적인 데이터를 사용해야할 경우, state를 사용해야합니다. 아래의 새로운 컴포넌트를 만들어 보겠습니다. 
                        <hr>
<pre>
  <code class="javascript" >
    import React, { Component } from 'react';

    class CounterHandler extends Component {
      state = {
        count: 0
      }
    
      addCount = () => {
        this.setState({
          count: this.state.count + 1
        });
      }
    
      reduceCount = () => {
        this.setState({
          count: this.state.count - 1
        });
      }
    
      render() {
        return (
          &lt;div>
            &lt;h1>카운터&lt;/h1>
            &lt;div>값: {this.state.count}&lt;/div>
            &lt;button onClick={this.addCount}>+&lt;/button>
            &lt;button onClick={this.reduceCount}>-&lt;/button>
          &lt;/div>
        );
      }
    }

    export default CounterHandler;
  </code>
</pre>  

<pre>
    <code class="javascript" >
    import React, { Component } from 'react';
    import CounterHandler from './CounterHandler';

    ReactDOM.render(
        &lt;CounterHandler />
    , document.getElementById('root'));

  </code>
</pre>        
<hr>
                        React 컴포넌트는 컴포넌트의 상태를 저장할 수 있습니다. <br>
                        props와의 차이점이라고 하면, state는 컴포넌트의 내부에 존재하고 있기 때문에, 상태 값 변경이 가능하다는 것입니다. <br>
                        this.setState() 메소드를 통해서 stat 값을 변경해줄 수 있습니다.   
                        <hr>
                        기본적으로 아래와 같이 Contructor에 state 변수를 선언할 때 중첩 문은 동작하지 않는다. 
                        <pre>
                          <code class="JavaScript">
// 아래와 같이 state 에서 중첩문이 적용되지 않음 - value가 undefined로 인식됨                             
class App extends Component {
  construct(props){
    super(props);
    this.state = {
      result : {
        value : 10
      }
    }

  }

}
                          </code>
                        </pre>    
                        <hr>
                        React는 성능을 위해 여러 setState() 호출을 단일 업데이트로 한꺼번에 처리할 수 있습니다. <br>
                        this.props 와 this.state가 비동기적으로 업데이트 될 수 있기 때문에 다음 state를 계산할 때 해당 값에 의존해서는 안됩니다. 
                        <hr>
                        <Strong>React Hook을 활용한 state 사용 방식</Strong> 
                        <pre>
                          <code class="Javascript" >
// Correct
const [ value, setValue ] = useState(0);

setValue((state, props) => ({
  counter: state.counter + props.increment
}))
                          </code>
                        </pre>  
                        <hr>
                        State는 다양한 독립적인 변수를 포함할 수 있습니다. 위의 코드에서 setValue를 이용해서 독립적으로 변수를 각각 호출할 수 있습니다. <br>
                        <pre>
                          <code class="Javascript" >
// Correct
const [ value, setValue ] = useState({ posts: [], comments: [] });

fetchPosts().then(response => {
  setValue({
    posts: response.posts
  });
});

fetchComments().then(response => {
  setValue({
    comments: response.comments
  });
});
                          </code>
                        </pre>     
                        <hr>
                        state가 소유하고 설정한 컴포넌트 이외에는 어떠한 컴포넌트에서 접근할 수 없습니다. <br>
                        일반적으로 이를 “하향식(top-down)” 또는 “단방향식” 데이터 흐름이라고 합니다. 모든 state는 항상 특정한 컴포넌트가 소유하고 있으며 그 state로부터 파생된 UI 또는 데이터는 오직 트리구조에서 자신의 “아래”에 있는 컴포넌트에만 영향을 미칩니다. <br>
                        <pre>
                          <code class="Javascript" >
import React, { useState } from 'react';

const FormattedData = props => {
    return &lt;h2>It is {props.date.toLocaleTimeString()}. &lt;/h2>
}

const SampleScreen01 = props => {

    const [ date , setDate] = useState(new Date());

    setInterval(() => {
        setDate(new Date());
      }, 1000)

    // 모든 컴포넌트가 완전히 독립적이라는 것을 보여주기 위해 App 렌더링하는 세 개의 &lt;FormattedData>을 만들었습니다.
    let SampleScreen01Layout = (
        &lt;div className="row" >
          &lt;FormattedData date={date} />
          &lt;hr />
          &lt;FormattedData date={date} />
          &lt;hr />
          &lt;FormattedData date={date} />
          &lt;hr />
        &lt;/div>
    );

    return SampleScreen01Layout;
}

export default SampleScreen01;
                          </code>
                        </pre>
                        <hr>
                        State 끌어올리기
                        <hr>
                        종종 동일한 데이터에 대한 변경 사항을 여러 컴포넌트에 반영해야 할 필요가 있습니다. 이럴 대는 가장 가까운 공통 조상으로 state를 끌어올리는 것이 좋습니다. 
                        <pre class="javascript" >
                          <code>
class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.handleCelsiusChange = this.handleCelsiusChange.bind(this);
    this.handleFahrenheitChange = this.handleFahrenheitChange.bind(this);
    this.state = {temperature: '', scale: 'c'};
  }

  handleCelsiusChange(temperature) {
    this.setState({scale: 'c', temperature});
  }

  handleFahrenheitChange(temperature) {
    this.setState({scale: 'f', temperature});
  }

  render() {
    const scale = this.state.scale;
    const temperature = this.state.temperature;
    const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
    const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;

    return (
      &lt;div>
        &lt;TemperatureInput
          scale="c"
          temperature={celsius}
          onTemperatureChange={this.handleCelsiusChange} />

        &lt;TemperatureInput
          scale="f"
          temperature={fahrenheit}
          onTemperatureChange={this.handleFahrenheitChange} />

        &lt;BoilingVerdict
          celsius={parseFloat(celsius)} />

      &lt;div>
    );
  }
}

class TemperatureInput extends React.Component {
  constructor(props) {
    super(props);
    this.handleChange = this.handleChange.bind(this);
  }

  handleChange(e) {
    this.props.onTemperatureChange(e.target.value);
  }

  render() {
    const temperature = this.props.temperature;
    const scale = this.props.scale;
    return (
      &lt;fieldset>
        &lt;legend>Enter temperature in {scaleNames[scale]}:&lt;legend>
        &lt;input value={temperature}
               onChange={this.handleChange} />
      &lt;fieldset>
    );
  }
}
                          </code>
                        </pre>
                        React 애플리케이션 안에서 변경이 일어나는 데이터에 대해서는 "진리의 원천"을 하나만 두어야 합니다. 보통의 경우, state는 렌더링에 그 값을 필요로 하는 컴포넌트에 먼저 추가됩니다. 
                        그리고 나서 다른 컴포넌트도 역시 그 값이 필요하게 되면 그 값을 그들의 가장 가까운 공통 조상으로 끌어올리면 됩니다. 다른 컴포넌트 간에 존쟇나는 state를 동기화 시키려고 노력하는 대신 
                        하향식 데이터 흐름에 기대는 걸 추천합니다. 
                        <hr>

                      </div>
                    </div>
                  </div> 
                  <div class="card">
                    <div class="card-header" id="heading4-2-1">
                      <h2 class="mb-0">
                        <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse4-2-1" aria-expanded="false" aria-controls="collapse4-4">
                          React Hook 
                        </button>
                      </h2>
                    </div>
                    <div id="collapse4-2-1" class="collapse" aria-labelledby="heading4-2-1" data-parent="#accordionExample">
                      <div class="card-body">
                        <hr>
                        함수형 컴포넌트에서 짧게 React Hook에 대해서 선언했던 부분이 있었다. 실제로 클래스 컴포넌트에서는 컴포넌트 사이클에서 제공되는 생명 주기 함수를 제공한다. 
                        이 때문에 Class 컴포넌트를 주로 사용할 경우, React Hook에서 제공되는 다양한 기능들을 사용할 수도 있는데, 이는 컴포넌트 생명주기에서 제공하는 함수들과 비슷한 쓰임새를 가진 것이 있기 때문에
                        함수형 컴포넌트에서도 생명주기를 관리 할 수 있게 된다. 
                        <br>
                        위에어 봤던 React Hook 함수를 다시 정리해보면, <br>
                        <ul>
                          <li>useState</li>
                          <li>useEffect</li>
                          <li>useContext</li>
                          <li>useReducer</li>
                          <li>useCallback</li>
                          <li>useMemo</li>
                          <li>useRef</li>
                          <li>useImperativeHandle</li>
                          <li>useLayoutEffect</li>
                          <li>useDebugValue</li>
                        </ul>
                      </div>
                    </div>
                  </div>               
              </div>                
            </div>
            <div class="card-footer small text-muted"></div>
          </div>
        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
    

    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

 

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>
  </body>

</html>
