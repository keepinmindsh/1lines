<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines - 해커와 화가</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1 Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">도서 정리</h6>
            <a class="dropdown-item" href="../document/architect_057.html">The Object</a>
            <a class="dropdown-item" href="../document/architect_058.html">패턴을 활용한 리팩터링</a>
            <a class="dropdown-item" href="../document/architect_059.html">훌륭한 프로그래머가 되는 법</a>
            <a class="dropdown-item" href="../document/architect_060.html">해커와 화가</a>
            <a class="dropdown-item" href="../document/architect_061.html">패턴 지향 소프트웨어 아키텍처</a>
            <a class="dropdown-item" href="../document/architect_036.html">참조글</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>
            <li class="breadcrumb-item active"></li>
          </ol>

        <div class="card mb-3">
          <div class="card-header">
            패턴 지향 소프트웨어 아키텍처
          </div>
          <div class="card-body">
            <ul>
              <li>넓은 시야를 가져라. 
                <hr>
                  세상을 살아감에 있어서 두 가지의 시작 '마이크로뷰' 와 '매크로뷰' 가 필요하다고 말합니다.
                  마이크로뷰는 우리 주변의 일을 깊게, 또 세세하게 파고들어 문제를 원리와 원인 중심으로 바라보는 시작을 말합니다. 
              </li>
              <li>찾아라. 그리고, 공유하라. 
              </li>
            </ul>
            <hr>
            패턴은 숙련된 소프트웨어 기술자들의 집약된 경험을 얻는데 유용하다. 모든 패턴들은 소프트웨어 시스템을 설계하거나 구형할 때 반복적으로 발생하는 특정 문제들을 해결해준다. 
            또한 주어진 요구사항에 부합하는 특정을 지닌 소프트웨어 아키텍처를 구성하기 위해 사용된다. 
            <hr>
            전문가들은 어떤 특수한 문제에 닥쳤을 때, 기존에 해왔던 해법과는 완전히 다른 새로운 해법을 사용해서 그 문제에 대응하는 경우는 극히 드물다. 
            전문가 들은 그들이 전에 풀어봤던 유사한 문제를 상기해내고 지금 당면한 새로운 문제를 해결하기 위해서 이전 해법의 핵심을 재사용하곤 한다.
            <hr>
            <strong>model-view-controller 아키텍처 패턴</strong> <br>
            사람과 컴퓨터가 상호작용하는 인터페이스를 필요로 하는 소프트웨어를 개발할 경우, 이 패턴을 고려해보아야 한다. 사용자 인터페이스는 상황에 따라 변경되기 쉽다. 
            따라서 상호작용하는 소프트웨어 시스템을 개발할 때는 아래의 두가지 사항을 고려해야 한다. 
            <ul>
              <li>사용자 인터페이스에 대한 변경은 쉬워야 하며 런타임에도 변경이 가능해야한다. 
                
              </li>
              <li>사용자 인터페이스를 새로운 환경에 적응시키고 이식할 때 애플리케이션 애플리케이션의 핵심 기능을 담당하는 코드에 영향을 미쳐서는 안된다. 

              </li>
            </ul>
            <hr>
            Model & View & Controller <br>
            <ul>
              <li>
                Model Component : <br>
                핵심 데이터와 기능을 캡슐화한다. 모델을 특정 출력 표현방식이나 입력 동작으로부터 독립적이어야 한다. 
              </li>
              <li>
                View Component : <br>
                사용자에게 정보를 출력한다. 뷰는 모델로부터 출력할 데이터를 얻는다. 하나의 모델에 여러 뷰가 존재할 수 있다. 
              </li>
              <li>
                Controller Component : <br>
                각 뷰에는 그에 상응하는 컨트롤러 컴포넌트가 존재한다. 컨르롤러는 입력을 받는데, 대체로 마우스의 이동, 마우스 버튼의 동작, 키보드 입력을 감지하는 이벤트롤 통해 입력을 받는다. 
                이벤트는 서비스 요청으로 해석되어 모델이나 뷰로 전달된다. 사용자는 오직 컨트롤러를 통해서만 시스템과 상호작용한다. 
              </li>
            </ul>
            <hr>
            <ul>
              <li>패턴은 특정 설계 상황에서 반복적으로 발생하는 설계 문제를 제기하며 그 문제에 대한 해법을 제시한다. </li>
              <li>패턴은 기존에 이미 입증된 설계 경험을 정리한 것이다. </li>
              <li>패턴은 클래스와 인스턴스의 레벨(혹은 컴포넌트의 개발)보다 상위의 추상 수준에서 정의된다. </li>
              <li>패턴은 설계 원칙에 대한 공통 어휘와 공감대를 형성시켜준다. </li>
              <li>패턴은 소프트웨어 아키텍처를 체계적으로 문서화하여 정리하는 방법을 제공한다.</li>
              <li>패턴은 소프트웨어 아키텍처 분야에서 정의한 고유 특성들에 근거해 소프트웨어를 개발할 수 있도록 지원한다. </li>
              <li>패턴은 복잡하고 이질적인 소프트웨어 아키텍처를 구축하는데 도움을 준다. </li>
              <li>패턴을 사용하면 소프트웨어 복잡도를 관하는데 유용하다. </li>
            </ul>
            스프트웨어 아키텍터를 위한 패턴은 특정 설계 정황에서 반복해서 발생하는 설계문제를 다루며 그 해법에 대한 검증된 일반 스키마를 제공한다. 해법 스키마는 그 해법을 구성하는 컴포넌트를 , 컴포넌트들의 책임과 관계, 컴포넌트들 간의 협력 방법을 서술하는 기준이 된다.  
            <hr>
            <strong>패턴은 무엇으로 구성되는가?</strong> 
            <ul>
              <li>정황 : 문제를 발생시키는 주어진 상황 - 설계 문제를 일으키는 설계 상황</li>
              <li>문제 : 해당 정황에서 반복적으로 발생하는 문제 - 정황에서 반복적으로 발생하응 영향력들</li>
              <li>
                해법 : 해당 문제에 대한 검증된 해답 - 영향력들 사이에 균형을 잡아는 구성 
                <ul>
                  <li>컴포넌트들과 그들 관계를 표현한 구조 </li>
                  <li>런타임 동작</li>
                </ul>
              </li>
            </ul>
            <hr>
            <strong>패턴의 카테고리</strong><br><br>
            <div class="list-group">
              <a href="#" class="list-group-item list-group-item-action">
                <div class="d-flex w-100 justify-content-between">
                  <h6 class="mb-1">아키텍처 패턴</h6>
                </div>
                <p class="mb-1">
                  아키텍처 패턴은 소프트웨어 시스템의 기본 구조를 구성하기 위한 스키마를 다룬다. 이 패턴은 미리 정의된 서브 시스템들을 제공하고 각 서브 시스템들의 책임을 
                  정의하며 서브시템들 간의 관계를 조직화하는 규칙과 가이드라인을 포함한다. <br>
                  아키텍처 패턴은 구체적인 소프트웨어 아키텍처를 위한 템플릿 역할을 한다. 이 패턴은 애플리케이션의 시스템 전체 구조의 특성을 정의하고 서브시스템들의 아키텍처에 영향을 미친다. 
                  <ul>
                    <li>계층화 패턴 </li>
                    <li>클라이언트-서버 패턴</li>
                    <li>마스터-슬레이브 패턴</li>
                    <li>파이프-필터 패턴</li>
                    <li>브로커 패턴</li>
                    <li>피어 투 피어 패턴</li>
                    <li>이벤트-버스 패턴</li>
                    <li>MVC 패턴</li>
                    <li>블랙 보드 패턴</li>
                    <li>인터프리터 패턴</li>
                  </ul>
                </p>
              </a>
              <a href="#" class="list-group-item list-group-item-action">
                <div class="d-flex w-100 justify-content-between">
                  <h5 class="mb-1">디자인 패턴</h5>
                </div>
                <p class="mb-1">
                  소프트웨어 시스템의 서브시스템이나 컴포넌트들, 혹은 그것들 간의 관계를 정의하기 위한 스키마를 제공한다. 디자인 패턴은 특정 정황 내에서 일반적인 설계 문제를 해결하며, 
                  통신하는 컴포넌트들 간의 반복적으로 발생하는 구조를 서술한다. 
                  <br>
                  디자인 패턴은 중간 규모의 패턴이다. 그래서 아키텍처 패턴보다 규모면에서는 작지만, 그렇다고 해서 특정 프로그래밍 언어나 프로그래밍 패러다임이 종속되는 경향을 나타내지는 않는다. 
                  다시 말해 여전히 어느 정도는 프로그래밍 언어나 프로그래밍 패러다임에 독립적이다. 
                  <ul>
                    <li>컴포넌트의 내부 상태가 변경되면 협력하는 컨포넌드들 사이에 일관성이 흐트러지는 경향이 있다. 일관성을 유지하려면 컴포넌트 사이에 데이터나 상태 정보를 교환하는 매커니즘이 필요하다. 
                      <ol>
                        <li>컴포넌트들은 느슨하게 결합되어야 한다. 즉 정보제공자는 협력 컴포넌드의 세부 내용에 종속되어서는 안된다. </li>
                        <li>정보 제공자에 종속된 컴포넌트를 사전에 미리 알 수 없다. </li>
                      </ol>
                    </li>
                  </ul>
                </p>
              </a>
              <a href="#" class="list-group-item list-group-item-action">
                <div class="d-flex w-100 justify-content-between">
                  <h5 class="mb-1">이디엄</h5>
                </div>
                <p class="mb-1">
                    이디엄은 특정 프로그래밍 언어에만 국한된 하위 레벨 패턴이다. 이디엄은 주어진 언어의 기능을 사용해서 컴포넌트들 혹은 컴포넌트들 간 관계의 특정 측면을 구현하는 방법을 서술한다. 
                    <br>
                    이디엄은 하위 레벨의 패턴을 표현한다. 그래서 이디엄은 설꼐와 구현, 이 두가지 측면을 해결한다. 
                    대부분의 이디엄은 특정 언어에 국한되어 있기 때문에, 기존 프로그래밍 경험으로부터 유래한다. 종종 동일한 이디엄이 서로 다른 프로그래밍 언어마다 다르게 나타나기도 하고, 때로는 
                    하나의 이디엄이 특정 프로그래밍 언어에서는 유용하지만 다른 프로그래밍 언어에서는 유용하지 않은 경우도 있다. 
                </p>
              </a>
              <hr>
              <strong>패턴 간의 관계</strong><br>
              많은 패턴들을 자세히 살펴보면 처음에 받은 인상과는 달리, 패턴 내에 있는 컴포넌트들과 그것들 간의 관계는 항상 '원자적(atomic)'이지만은 않다. 패턴은 특정 문제를 해결하지만 
              패턴을 적용함으로써 또 다른 새로운 문제를 발생시킬 수도 있다. 이렇게 새로 발생된 문제는 다른 패턴에 의해 해결되기도 한다. 특정 패턴 내에 있는 컴포넌트들이나 그것들의 관계는 더 작은 패턴에 의해
              서술될 수 있으며, 그것들을 포함하고 있는 더 큰 패턴에 의해 통합될 수 있다. 
              <ul>
                <li>Model And View Controller 패턴의 개선
                  <br>
                  Model And View Controller 패턴은 변경에 유연한 사용자 인터페이스를 제공하기 위해서 핵심 기능을 사람-컴퓨터 상호작용 기능으로부터 분리한다. 
                  하지만 이 패턴을 적용하면 또 다른 문제가 발생한다. 
                  뷰는 물론 심지어 컨트롤러까지 모델의 상태에 좌우된다. 이들 사이의 일관성은 물론 유지되어야 한다. 
                  모델의 상태가 변경될 때면 항상 모델에 좌우되는 뷰와 컨트롤러를 모두를 업데이트해야 한다. 하지만 사용자 인터페이스를 변경하더라도 변경 전파 기능을 잃어서는 안된다. 
                  이와 같은 경우에는 Observer 패턴을 사용하면 이 문제를 해결할 수 있다. 즉, 모델은 주체의 역할을 하는 반면, 뷰와 컨트롤러는 관찰자의 역할을 하면된다. 
                  <br>
                  소프트웨어 아키텍처에서 사용되는 대부분의 패턴은 더 작은 패턴에 의해 해결될 수 있는 문제를 발생시킨다. 패턴은 결코 고립되어 존재하지 않는다. <br>
                  크리스토퍼 알렉산더는 다소 추상적으로 이렇게 언급했다. "개별 패턴은 그것을 포함하고 있는 더 작은 패턴에 그리고 그것을 포함하고 있는 더 큰 패턴에 종속된다. "
                </li>
                <li>Model And View Controller 패턴의 Document-View 변형
                  <br>
                  model-view-controller 패턴을 사용하여 대화형 텍스트 편집기를 개발한다고 가정해보자. 이런 애플리케이션의 경우, 뷰 기능으로부터 컨트롤러 기능을 분리하는 작업은 그리 쉽지만은 않다.            
                  마우스를 사용해서 텍스트를 선택한 다음 일반 서체를 볼드 서체로 변경한다고 가정해보자. 텍스트를 선택하는 동작은 모델에 변경을 일으키지 않는 컨트롤러 동작에 해당한다. 
                  선택된 텍스트는 서체를 변경할 때 단지 다른 컨트롤러 동작에 대한 입력의 역할을 한다. 하지만 텍스트 선택 동작은 시각적인 효과를 필요로 한다. 즉, 선택된 텍스트에는 하이라이트 효과가
                  적용되어야 한다. 엄밀한 Model View Controller 구조에서 컨트롤러는 자체적으로 뷰처럼 동작하도록 구현해야 하거나 선택된 텍스트가 보여지는 뷰와함께 협력해야 한다.                                                                                                                                                                                                                                                

                </li>
                <li>투명한 피어투피어 IPC
                  <br>
                  고성능 피어투피어 IPC로 분산 애플리케이션을 개발해야 한다고 가정해보자. 다음과 같은 영향력들이 균형을 이뤄야 한다. 
                  <ul>
                    <li>IPC가 효율적이어야 한다. 원격 서버의 위치를 검색하는데 시간이 허비되는 것은 바람직하지 못하다. </li>
                    <li>특정 IPC 메커니즘에 종속되지 않고 독립적인 것이 바람직하다. 이 메커니즘은 클라이언트나 서버에 영향을 미치지 않도 교환 가능해야 한다. </li>
                    <li>클라이언트 들은 서버의 이름이나 위치를 미리 알고 있어야 하거나 서버의 이름이나 위치에 의존해서는 안된다. 그 대신 클라이언트들은 마치 동일한 프로세스 상에 있는 것처럼 통신해야 한다.</li>
                  </ul>
                </li>
              </ul>
              개선(refinement), 조합(combination), 변형(variant), 이렇게 세 가지 종류의 관계를 응용함으로써 패턴을 효과적으로 사용할 수 있다. 개선은 패턴의 구현을 지원하며, 조합은 복잡한 설계 구조를 구성하고, 
              변형은 주어진 설계 상황에서 올바른 패턴을 선택하도록 돕는다. 
              <hr>
              패턴은 이해하고 토론하기 위해 적절한 양식으로 서술되어야 한다. 잘 정리된 패턴 서술은 패턴의 핵김, 즉 그 패턴이 해결하고자 하는 문제가 무엇인기 그리고 그에 대한 해법이 무엇인지를 즉각 파악할 수 있도록 해준다. 
              또한 잘 정리된 서술은 패턴을 구현하고 적용 결과를 예측할 수 있을 만큼 필요한 모든 사항을 상세히 제공한다. 
              <br>
              패턴의 행보가 성공적인지를 평가하기 위한 중요 기준은 패턴이 소프트웨어 공학의 목표와 적절히 일치하느냐이다. 패턴은 복잡한 대규모 시스템을 개발하고 유지하며 발전시키는데 한몫을 담당해야 한다. 
              또한 업계에서 소프트웨어의 생산성을 효율적으로 향상시키는 데도 이바지 해야 하는데, 만약 그렇지 않다면 패턴은 소프트웨어의 생산성과는 아무 관련 없는 지적 유희가 되고 만다. 
              <br>
              <strong>정신적 빌딩 블록 역할을 하는 패턴</strong> <br>
              패턴은 소프트웨어 시스템을 개발할 때 특수한 설계 측면을 처리하기 위해 정신적인 빌딩 블록 역할을 한다. 
            </div>
            
          </div>
        </div>

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
   
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
 
    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Page level plugin JavaScript-->
    <script src="../vendor/chart.js/Chart.min.js"></script>

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>

    <!-- Demo scripts for this page-->
    <script src="../js/demo/chart-area-demo.js"></script>
    <script src="../js/demo/chart-bar-demo.js"></script>
    <script src="../js/demo/chart-pie-demo.js"></script>

  </body>

</html>
