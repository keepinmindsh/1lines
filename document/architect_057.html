<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines - SOLID</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1 Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">서론</h6>
            <a class="dropdown-item" href="../document/architect_001.html">서론</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">사례연구</h6>
            <a class="dropdown-item" href="../document/architect_002.html">사례연구</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">생성 패턴</h6>
            <a class="dropdown-item" href="../document/architect_003.html">추상 팩토리</a>
            <a class="dropdown-item" href="../document/architect_004.html">빌더</a>
            <a class="dropdown-item" href="../document/architect_005.html">팩토리 메서드</a>
            <a class="dropdown-item" href="../document/architect_006.html">원형</a>
            <a class="dropdown-item" href="../document/architect_007.html">단일체</a>
            <a class="dropdown-item" href="../document/architect_008.html">생성 패턴에 대한 논의</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">구조 패턴</h6>
            <a class="dropdown-item" href="../document/architect_009.html">적응자</a>
            <a class="dropdown-item" href="../document/architect_010.html">가교</a>
            <a class="dropdown-item" href="../document/architect_011.html">복합체</a>
            <a class="dropdown-item" href="../document/architect_012.html">장식자</a>
            <a class="dropdown-item" href="../document/architect_013.html">퍼사드</a>
            <a class="dropdown-item" href="../document/architect_014.html">플라이급</a>
            <a class="dropdown-item" href="../document/architect_015.html">프록시</a>
            <a class="dropdown-item" href="../document/architect_016.html">구조패턴에 대한 논의</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">행동 패턴</h6>
            <a class="dropdown-item" href="../document/architect_017.html">책임 연쇄</a>
            <a class="dropdown-item" href="../document/architect_018.html">명령</a>
            <a class="dropdown-item" href="../document/architect_019.html">해석자</a>
            <a class="dropdown-item" href="../document/architect_020.html">반복자</a>
            <a class="dropdown-item" href="../document/architect_021.html">중재자</a>
            <a class="dropdown-item" href="../document/architect_022.html">메멘토</a>
            <a class="dropdown-item" href="../document/architect_023.html">감시자</a>
            <a class="dropdown-item" href="../document/architect_024.html">상태</a>
            <a class="dropdown-item" href="../document/architect_025.html">전략</a>
            <a class="dropdown-item" href="../document/architect_026.html">템플릿 메서드</a>
            <a class="dropdown-item" href="../document/architect_027.html">방문자</a>
            <a class="dropdown-item" href="../document/architect_028.html">행동 패턴에 대한 논의</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">결론</h6>
            <a class="dropdown-item" href="../document/architect_029.html">디자인 패턴에서 무엇을<br> 기대할 수 있는가?</a>
            <a class="dropdown-item" href="../document/architect_030.html">간략한 역사</a>
            <a class="dropdown-item" href="../document/architect_031.html">패턴 커뮤니티</a>
            <a class="dropdown-item" href="../document/architect_032.html">초대의 글</a>
            <a class="dropdown-item" href="../document/architect_033.html">책을 마무리하며</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">System Archtecture</h6>
            <a class="dropdown-item" href="../document/architect_057.html">The Object</a>
            <a class="dropdown-item" href="../document/architect_053.html">API with Zuul</a>
            <a class="dropdown-item" href="../document/architect_037.html">Cloud System</a>
            <a class="dropdown-item" href="../document/architect_047.html">Cassandra</a>
            <a class="dropdown-item" href="../document/architect_036.html">DevOps</a>
            <a class="dropdown-item" href="../document/architect_045.html">IAC</a>
            <a class="dropdown-item" href="../document/architect_043.html">Kuberneties</a>
            <a class="dropdown-item" href="../document/architect_034.html">MVC</a>
            <a class="dropdown-item" href="../document/architect_049.html">MSA</a>
            <a class="dropdown-item" href="../document/architect_044.html">MOM</a>
            <a class="dropdown-item" href="../document/architect_039.html">PAAS</a>
            <a class="dropdown-item" href="../document/architect_035.html">REST API</a>
            <a class="dropdown-item" href="../document/architect_046.html">SAAS</a>
            <a class="dropdown-item" href="../document/architect_040.html">SCA</a>
            <a class="dropdown-item" href="../document/architect_042.html">SOA</a>
            <a class="dropdown-item" href="../document/architect_041.html">TDD(DDD)</a>
            <a class="dropdown-item" href="../document/architect_048.html">Web Cache</a>
            <a class="dropdown-item" href="../document/architect_050.html">Various Pattern</a>
            <a class="dropdown-item" href="../document/architect_055.html">Hexagonal Architecture</a>
            <a class="dropdown-item" href="../document/architect_056.html">Visualizing Architecture</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>
            <li class="breadcrumb-item active"></li>
          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
              The Object 정리 
            </div>
            <div class="card-body">
              <Strong>더오브젝트 , 마틴 파울러 글 참고</Strong><br>
              모든 소프트웨어 모듈에는 세 가지 목적이 있다. 첫 번째 목적은 실행 중에 제대로 동작하는 것이다. 이것은 모듈의 존재 이유라고 할 수 있다. <br>
              두번째 목적은 변경을 위해 존재하는 것이다. 대부분의 모듈은 생명 주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다. 변경하기 어려운 모듈은 제대로 동작하더라도 개선해야 한다. <br>
              모듈의 세번째 목적은 코드를 읽는 사람과 의사소통 하는 것이다. 모듈은 특별한 훈련없이도 개발자가 쉽게 읽고 이해할 수 있어야 한다. <br>
              읽는 사람과 의사 소통할 수 없는 모듈은 개선해야 한다. 
              <hr>
              <strong>객체 사이의 의존성</strong> - 의존성은 변경에 대한 영향을 암시한다. <br> 
              의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체가 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다. <br>
              자율성은 캡슐화와 연관이 있다. <strong>자율성이 높다는 것</strong>은 자신의 변경으로 부터 외부의 영향도가 적다는 것이고 <br>
               즉 <strong>이말은 해당 객체가 적절하게 캡슐화 되어 내부 변경이 외부에 영향을 미치지 않는다는 것이라고 볼 수 있다.</strong>  
              <hr>
              설계란 코드를 배치하는 것이다. 
              <hr>
              <strong>다형성을 구현하는 방법</strong><br>
              다형성을 구현하는 방법은 매우 다양하지만 메세지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다. 다시 말해 메세지와 메서드를 실행시점에 바인딩한다는 것이다. 
              이를 지연 바인딩(Lazy binding) 또는 동적 바인딩(dynamic binding)이라고 부른다. 그에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩 또는 정적 바인딩이라고 부른다. 
              객체지향이 컴파일 시점의 의존성과 실행시점의 의존성을 분리하고, 하나의 메세지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 바로 지연 바인딩이라는 메커니즘을 사용하기 때문이다. 
              <hr>
              항상 구현에 대해서 트레이드 오프를 반드시 고민하라. 
              <hr>
              메세지 - 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단. 
              <hr>
              <strong>협력</strong> <br>
              협력이란 어떤 객체가 다른 객체엑 무엇인가를 요청하는 것이다. <br> 
              한 객체는 어떤것이 필요할 때 다른 객체에게 전적을 위임하거나 협력한다. <br> 
              즉 , 두객체가 상호작용을 통해 더 큰 책임을 수행하는 것이다. 객체 사이의 협력을 설계할 때는 객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다. 
              <hr>
              협력이 설계를 위한 문맥을 결정한다. 
              <hr>
              <strong> 책임 : 객체에 의해 정의되는 응집도 있는 행위의 집합 </strong><br>
              하는 것 <br>
              <ul>
                <li>객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것</li>
                <li>다른 객체의 행동을 시작시키는 것</li>
                <li>다른 객체의 활동을 제어하고 조절하는 것</li>
              </ul>
              아는 것 <br>
              <ul>
                <li>사적인 정보에 관해 아는 것</li>
                <li>관련된 객체에 관해 아는 것</li>
                <li>자신이 유도하거나 계산할 수 잇는 것에 관해 아는 것 </li>
              </ul>
              <hr>
              <div class="card">
                <div class="card-header">
                   General Responsibility Assignment Software Pattern
                </div>
                <div class="card-body">
                    <p>
                      
                      "객체에 책임을 할당해야 하는데 그 할당하는 패턴 또는 원칙" , "책임 부여 원칙"
                      <hr>
                      GRASP 패턴은 9가지로 구성되어 있다.
                      <ul>
                        <li>Information Expert : 역할을 수행할 수 있는 정보를 가지고 있는 객체에 역할을 부여하라. </li>
                        <li>Creator : 객체의 생성은 생성되는 객체의 컨텍스트를 알고 있는 다른 객체가 있다면, 컨텍스트를 알고 있는 객체에 부여하자. </li>
                        <li>Controller : 시스템 이벤트(사용자의 요청)을 처리할 객체를 만들자. </li>
                        <li>Low Coupling : 객체들간, 서브 시스템들 간의 상호의존도가 낮게 역할을 부여하자. </li>
                        <li>High Cohesion : 각 객체가 밀접하게 연관된 역할들만 가지도록 역할을 부여하자. </li>
                        <li>Polymorphism : 객체의 종류에 따라서 행동양식이 바뀐다면, 다형성을 사용하자. </li>
                        <li>Pure Fabrication : Information Expert 패턴을 적용하면 Low Coupling과 High Cohesion의 원칙이 깨어진다면, 기능적인 역할을 별도로 한 곳으로 모으자. 데이터베이스 정보를 저장하거나, 로그 정보를 기록하는 역할에 대해 생각해 보자.</li>
                        <li>Indirection : 두 객체 사이의 직접적인 Coupling을 피하고 싶으면, 그 사이에 다른 객체를 사용하라. </li>
                        <li>Protected Variation : 변경될 여지가 있는 곳에 안정된 인터페이스를 정의해서 사용하자. </li>
                      </ul>
                    </p>
                    <footer class="blockquote-footer">https://vandbt.tistory.com/9</footer>
                 
                </div>
              </div>
              <hr>
              <strong>책임 주도 설계</strong>
              <ul>
                <li>시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다.</li>
                <li>시스템 책임을 더 작은 책임으로 분할 한다.</li>
                <li>분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.</li>
                <li>객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다. </li>
                <li>해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. </li>
              </ul>
              <hr>
              <strong>메세지가 객체를 결정한다.</strong>
               
              <ul>
                <li>객체가 최소한의 인터페이스를 가질 수 있게 된다. </li>
                <li>객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다. 객체의 인터페이스는 무엇을 하는지 표현해야 하지만 어떻게 수행하는지를 노출해서는 안된다. </li>                
              </ul>
              <hr>
              <strong>행동이 상태를 결정한다. </strong>
              <ul>
                <li>객체가 협력에 적합한지를 결정짓는 것은 그 객체의 상태이다. </li>
                <li>문제를 해결하기 위해서는 객체가 아닌 책임에 초점을 맞춰야한다. </li>
                <li>역할은 다른 것으로 교체할 수 있는 책임의 집합이다. </li>
              </ul>
              <hr>
              <strong>응집도</strong> : 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. <br>
              <strong>결합도</strong> : 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다. <br>
              변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다. <br>
              결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도 <br>
              <hr>
              <strong>단일 책임 원칙</strong><br>
              로버트 마틴은 모듈의 응집도가 변경와 연관이 있다는 사실을 강조하기 위해 단일 책임 원칙이라는 
              설계 원칙을 제시했다. 단일 책임 원칙을 한마디로 요약하면 클래스는 단 한 가지의 변경 이유만을 가져야 한다는 
              것이다. 아마 방금전에 설명한 내용을 이해했다면 단일 책임 원칙이 클래스의 응집도를 높일 수 있는 설계 원칙이라는 사실을 이해했을 것이다. <br>
              한가지 주의할 점은 단일 책임 원칙이라는 맥락에서 '책임'이라는 말이 '변경의 이유'라는 의미로 사용된다는 점이다. 
              <hr>
              <strong>캡슐화</strong><br>
              캡슐화란 변할 수 있는 어떤 것이라도 감추는 것이다. 그것이 속성의 타입이건, 할인 정책의 종류건 상관 없이 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것이다. 설계에서 변하는 
              것이 무엇인지 고려하고 변하는 개념을 캡슐화해야 한다. 
              <hr>
              <ul>
                <li>데이터보다 행동을 먼저 결정하라</li>
                <li>협력이라는 문맥안에서 책임을 결정하라.</li>
              </ul>
              클래스를 설정하고 그 클래스의 책임을 찾아 나서는 대신 메세지를 결정하고 이 메시지를 누구에게 전송할지 찾아보게 되었다. 클래스 기반 설계에서 
              메시지 기반 설계로의 자리바꿈은 우리가 해오던 설계 활동의 전환점이다. 메시지 기반의 설계 관점은 클래스 기반의 설계 관점보다 훨씬 유연한 애플리케이션을 
              만들 수 있게 해준다. "이 클래스가 필요하다는 점은 알겠는데 이 클래스는 무엇을 해야 하지?"라고 질문하고 않고 "메시지를 전송해야 하는데 누구에게 전송해야 하지?"라고 질문 하는 것. 
              설계의 핵심 질문을 이렇게 바꾸는 것이 메시지 기발 설계로 향하는 첫걸음이다. 객체를 가지고 있기 때문에 메시지를 보내는 것이 아니다. 
              메시지를 전송하기 때문에 객체를 갖게 된 것이다. 
              <hr>
              <strong>책임 할당을 위한 절차</strong>
              <ul>
                <li>도메인을 구성하기 </li>
                <li>
                  정보 전문가에게 책임을 할당하라 <br>
                  책임을 정보 전문가. 즉, 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라. <br>
                  객체가 자율적인 존재여야 한다는 사실을 다시 한번 상기시킨다. 정보를 알고 있는 객체만이 책임을 어떻게
                  수행할지 스스로 결정할 수 있기 때문이다. <br>


                </li>
                <li>높은 응집도와 낮은 결합도 <br>
                  낮은 결합도는 모든 설계 결정에서 염두에 둬야 하는 원리다. 다시 말해 설계 결정을 평가할 때 적용할 수 있는 
                  평가원리다. 현재의 책임 할당을 검토하거나 여러 설계 대안들이 있을때 낮은 결합도를 유지할 수 있는 설계를 선택하라. 


                </li>
                <li>
                  창조자에게 객체 생성 책임을 할당하라. <br>
                  CREATOR 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 잇는 객체에 해당 객체를 생성할 책임을 맡기는 것이다. 생성될 객체에 대해 잘 알고 있어야 하거나 
                  그 객체를 사용하는 객체는 어떤 방식으로는 생성될 객체와 연결될 것이다. 

                </li>
              </ul>
              <hr>
              <strong>클래스 응집도 판단하기</strong>
               <br>
              지금까지 클래스의 응집도를 판단할 수 있는 아래의 방법을 확인하면, 
              <ul>
                <li>클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라. </li>
                <li>클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다. 초기화 되는 속성의 그룹을 기준으로 클래스를 분리하라.</li>
                <li>메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다. 이들 그룹을 기준으로 클래스를 분리하라. </li>
              </ul>
              <hr>
              <strong>다형성을 통해 분리하기</strong>  <br>
              역할을 사용하면 객체의 구체적인 타입을 추상화할 수 있다. <br>
              Polymorphism 패턴 <br>
              객체의 타입에 따라 변하는 로직이 있을 때 변하는 로직을 담당할 책임을 어떻게 할당해야 하는가? 타입을 명시적으로 정의하고 각 타임에 다형적으로 행동하는 책임을 할당하라. 
              조건에 따른 변화는 프로그램의 기본 논리다. 프로그램을 if ~ else 또는 switch ~ case 등의 조건 논리를 사용해서 설계한다면 새로운 변화가 일어난 경우 조건 논리를 수정해야 한다. 
              이것은 프로그램을 수정하기 어렵고 변경에 취약하게 만든다. 
              <hr>
              Protected Variations 패턴은 책임 할당의 관점에서 캡슐화를 하는 것. 객체, 서브시스템, 그리고 시스템을 어떻게 설계해야 변화와 불안정성이 다른 요소에 나쁜 영향을 미치지 않도록 방지할 수 있을까?
              변화가 예상되는 불안정한 지점들을 식별하고 그 주위에 안정된 인터페이스를 형성하도록 책임을 할당하라. <br>
              설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐하라. 
              <hr>
              <strong>도메인의 구조가 코드의 구조를 이끈다.</strong>  <br>
              변경 역시 도메인 모델의 일부라는 것이다. 도메인 모델에는 도메인 안에서 변하는 개념과 이들 사이의 관계가 투영돼 있어야 한다. 
              도메인 모델에는 할인 정책과 할인 조건이 변경 될 수 있다는 도메인에 대한 직관이 반영돼 있다. 그리고 이 직관이 우리의 설계가 가져야하는 유연성을 이끌었다. 
              구현을 가이드 할 수 잇는 도메인 모델을 선택하라. 객체지향은 도메인의 개념과 구조를 반영한 코드를 가능하게 만들기 때문에 도메인의 구조가 
              코드의 구조를 이끌어 내는 것은 자연스러울 뿐만 아니라 바람직한 것이다. 
              <hr>
              <strong>코드의 구조가 도메인의 구조에 대한 새로운 통찰력을 제공한다.</strong>  <br>
              코드의 구조가 바뀌면 도메인에 대한 관점도 함께 바뀐다. 할인 정책을 자유롭게 변경할 수 있다는 것은 도메인에 포함된 중요한 요구사항이다. 이 요구사항을 수용하기 위해 
              할인 정책이라는 개념을 코드 상에 명시적으로 드러냈다면 도메인 모델 역시 코드의 관점에 따라 바뀌어야 한다. 따라서 도메인 모델은 코드의 구조에 따라 수정된다. 
              이 도메인 모델은 도메인에 포함된 개념과 관계 뿐만 아니라 도메인이 요구하는 유연성도 정확하게 반영한다. <br>
              도메인 모델은 단순히 도메인의 개념과 관계를 모아 놓은 것이 아니라. 도메인 모델은 구현과 밀접한 관계를 맺어야 한다. 도메인 모델은 코드에 대한 가이드를 제공할 수 있어야 하며
              코드의 변화에 발맞춰 함께 변화해야 한다. 도메인 모델을 코드와 분리된 막연한 무엇으로 생각하지 않기 바란다. 
              <hr>
              <strong>책임 주도 설계의 대안</strong><br>
              객체 디자인에서 가장 기본이 되는 것 중의 하나는 책임을 어디에 둘지를 결정하는 것이다. 나는 십년 이상 객체를 가지고 일했지만 처음 시작할 때는 여전히 적당한 위치를 찾지 못한다. 
              늘 이런 점이 나를 괴롭혔지만, 이제는 이런 경우에 리택터링을 사용하면 된다는 것을 알게 되었다. 
              <hr>
              <strong>짧고, 이해하기 쉬운 이름으로 된 메소드</strong><br>
              나는 다음과같은 이유로 짧고, 이해하기 쉬운 이름으로 된 메소드를 좋아한다. 첫째, 메서드가 잘게 나뉘져있을 때 다른 메서드에서 사용될 확률이 높아진다. 
              둘째 고수준의 메서드를 볼 때 일련의 주석을 읽는 것 같은 느낌이 들게 할 수 있다. 또한 메서드가 잘게 나눠져있을 때 오버라이딩 하는 것도 휠씬 쉽다. 
              만약 큰 메서드에 익숙해져 있다면 메서드를 잘게 나누는데는 약간의 시간이 걸릴 것이다. 작은 메서드는 실제로 이름을 잘지었을 때만 그 진가가 드러나므로 
              이름을 지을 때 주의해야 한다. <br>
              사람들은 때때로 나에게 한 메서드의 길이가 어느 정도 돼야 할지를 묻는다. 그러나 나는 길이가 중요하다고 생각하지 않는다. 중요한 것은 메서드의 이름과 메서드 몸체의 의미적 차이다. 
              뽑아내는 것이 코드를 더욱 명확하게 하면 새로 만든 메서드의 이름이 원래 코드의 길이보다 길어져도 뽑아낸다. 
              <hr>
              <strong>객체를 자율적으로 만들자 </strong><br>
              처음부터 책임 주도 설계 방법을 따르는 것보다 동작하는 코드를 작성한 후에 리팩터링하는 것이 더 훌륭한 결과물을 낳을 수도 있다. 
              <hr>
              <strong>인터페이스와 설계 품질</strong><br>
              <ul>
                <li>디미터 법칙 : 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한하라는 것이다. </li>
                <li>묻지 말고 시켜라</li>
                <li>의도를 드러내는 인터페이스</li>
                <li>명령 - 쿼리 분리 </li>
              </ul>
              <hr>
              <strong>디미터 법칙과 캡슐화</strong><br>
              디미터 법칙은 캡슐화를 다른 관점에서 표현한 것이다. 디미터 법칙이 가치 있는 이유는 캡슐화하기 위해 따라햐는 구체적인 지침을 제공하기 때문이다. 캡슐화 원칙이 클래스 내부의 구현을 
              감춰야한다는 사실을 강조한다면 디미터 법칙은 협력하는 클래스의 캡슐화를 지키기 위해 접근해야 하는 요소를 제한한다. 디미터 법칙은 협력과 구현이라는 사뭇 달라 보이는 두 가지 
              문맥을 하나의 유기적인 개념으로 통합한다. 클래스의 내부 구현을 채워가는 동시에 현재 협력하고 있는 클래스에 관해서도 고민하도록 주의를 환기시키기 때문이다. 
              <hr>
              <strong>객체를 구성하는 방식 - 묻지 말고 시켜라.</strong>  <br>
              절차적인 코드는 정보를 얻은 후에 결정한다. 객체지향 코드는 객체에게 그것을 하도록 시킨다. <br>
              우리는 메세지를 전송하는 개별적인 객체들을 보유하고 있는데, 그렇다면 객체들은 무엇을 말해야 하는가? 우리의 경험에 따르면 호출하는 객체는 이웃 객체가 수행하는 역할을 사용해 무엇을 원하는지를 서술해야 하고, 
              호출되는 객체가 어떻게 해야 하는지를 스스로 결정하게 해야 한다. 이것은 일반적으로 "묻지말고 시켜라" 스타일, 또는 좀 더 공식적으로 "디미터 법칙"으로 알려져있다. 
              <hr>
              켄트 벡은 메서드의 목적을 효과적으로 전달하고자 의도를 드러내는 선택자를 사용해 메서드의 이름을 짓는 것에 관해 글을 쓴 것이 있다. 설계에 포함된 모든 공개 요소가 조화를 이뤄 인터페이스를 구성하고, 인터페이스를 구성하는 
              각 요소의 이름을 토대로 설계 의도를 드러낼 수 잇는 기회를 얻게 된다. 타입 이름, 메서드 이름, 인자 이름이 모두 결합되어 의도를 드러내는 인터페이스를 형성한다. 그러므로 수행 방법에 관해서는 언급하지 말고 결과와 목적만을 
              포함하도록 클래스와 오퍼레이션의 이름을 부여하라. 이렇게 클라이언트 개발자가 내부를 이해해야 할 필요성이 줄어든다. 
              <hr>
              디미터의 법칙에 대해서 하나의 도트(.) 만을 강제하는 규칙이 아니라 기차 충돌 처럼 보이는 코드일지라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터의 법칙을 준수한것이다. 
              <hr>
              클래스는 하나의 변경 원인만을 가져야 한다. 서로 상관없는 책임들이 함께 뭉쳐있는 클래스는 응집도가 낮으며 작은 변경으로도 쉽게 무너질 수 있다. 따라서 디미터 법칙과 묻지말고 시켜라 원칙을 무작정 따르면 
              애플리케이션은 응집도가 낮은 객체로 넘쳐날 것이다. 
              <hr>
              <strong>명령과 쿼리 분리 원칙</strong><br>
              <ul>
                <li>객체의 상태를 변경하는 명령은 반환값을 가질 수 없다.</li>
                <li>객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다.</li>
              </ul>
              부수효과를 발생시키지 않는 것만을 함수로 제한함으로써 소프트웨어에서 말하는 '함수'의 개념이 일반 수학에서의 개념과 상충되지 않게 한다. 객체를 변경하지만 직접적으로 값을 반환하지 않을 명령과 객체에 대한 정보를 반환하지만 변경하지는 않는 쿼리 간의 명확한 구분을 유지할 것이다. <br>
              명령과 쿼리에서 중요한 부분은 질문이 답변을 수정해서는 안된다는 것이다. 
              <hr>
              <strong>
                책임에 초점을 맞춰라
              </strong>
               <br>
              메세지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것! 객체의 구현이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것이다. 이 모든 방식의 중심에는 객체가 수행할 책임이 위치한다. <br>
              훌륭한 메시지를 얻기 위한 출발점은 책임 주도 설계의 원칙을 따르는 것이다. <br>
              <hr>
              <strong>변경을 기준으로 선택하라.</strong> <br>
              <hr>
              <strong>컨텍스트 독립성</strong><br>
              시스템을 구성하는 객체가 컨텍스트 독립적이라면 해당 시스템은 변경하기 쉽다. 여기서 컨텍스트 독립적이라는 말은 각 객체가 해당 객체를 실행하는 시스템에 관해 아무것도 알지 못한다는 의미다. 
              이렇게 되면 행위의 단위를 가지고 새로운 상황에 적용할 수 있다. 컨텍스트 독립성을 따르면 다양한 컨텍스트에 적용할 수 있는 응집력 있는 객체를 만들 수 있고 객체 구성 방법을 재설정해서 
              변경 가능한 시스템으로 나아갈 수 있다. 
              <hr>
              <strong>추상화에 의존하라.</strong> <br>
              <hr>
              객체 지향 시스템은 협력하는 객체들의 네트워크로 구성돼 있다. 시스템은 객체를 생성해 서로 메시지를 주고 받을 수 있게 조립하는 과정을 거쳐 만들어진다. 시스템의 행위는 객체의 조합을 통해 나타나는 특성이다. 따라서 시스템에 포함된 객체의 구성을 변경해 시스템의 작동방식을 바꿀 수 있다. 
              이러한 객체 구성을 관리할 목적으로 작성하는 코드를 객체 네크워크의 행위에 대한 선언적인 정의라고 한다. <strong> 시스템을 이런 방식으로 구축하면 방법이 아니라 목적에 집중할 수 있어 시스템의 행위를 변경하기가 더 쉽다. </strong> 
              <hr>
              <strong>소프트웨어 객체는 확장에는 열려있어야 하고, 수정에 대해서는 닫혀있어야 한다. </strong><br>
              <ul>
                <li>확장에 대해 열려 있다. : 애플리케이션의 요구 사항이 변경될 때 이 변경에 맞게 새로운 '동작'을 추가해서 애플리케이션의 기능을 확장할 수 있다. </li>
                <li>수정에 대해 닫혀 있다. : 기존의 '코드'를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다. </li>
              </ul>
              개방-폐쇄 원칙의 핵심은 추상화에 의존하는 것 
              <hr>
              <strong>컴파일 타입 의존성을 고정시키고, 런타임 의존성을 변경하라. </strong> 
              <hr>
              <strong>소프트웨어 시스템은 응용 프로그램 객체를 제작하고 의존성을 서로 연결하는 시작 단계와 시작 단계 이후에 이어지는 실행 단계를 분리해야 한다. </strong><br>
              <hr>
              <strong>의존성 역전의 법칙</strong><br>
              <ul>
                <li>
                  상위 수준의 모듈은 하위 수준의 모듈에 의존해서는 안된다. 둘 모두 추상화에 의존해야 한다. 
                </li>
                <li>
                  추상화는 구체적인 상황에 의존해서는 안된다. 구체적인 사항은 추상화에 의존해야 한다. 
                </li>
              </ul>
              <hr>
              <strong>DRY 원칙</strong><br>
              모든 지식은 시스템 내에서 단일하고, 애매하지 않고, 정말로 믿을 만한 표현 양식을 가져야 한다. 
              <hr>
              <strong>코드의 중복을 위하여</strong><br>
              <ul>
                <li>두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.</li>
                <li>부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다. </li>
              </ul>
              <hr>
              <ul>
                <li><strong>업캐스팅</strong>: 부모 클래스 타입으로 선언된 변수에서 자식 클래스의 인스턴스를 할당하는 것이 가능하다. 이를 업캐스팅이라고 부른다. </li>
                <li><strong>동적 바인딩</strong>: 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정된다. 이것은 객체지향 시스템이 메시지를 처리할 적절한 메서드를 컴파일 시점이 아니라 실행 시점에 결정하기 때문에 가능하다.</li>
              </ul>
              <hr>
              <strong>설계에 일관성을 부여하라.</strong><br>
              <ul>
                <li>변하는 개념을 변하지 않는 개념으로부터 분리하라.</li>
                <li>변하는 개념을 캡슐화하라. </li>
              </ul>
              <hr>
             <strong>소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 디자인 패턴 이라고 한다.</strong>  <br>
             <ul>
               <li>디자인 패턴은 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음</li>
               <li>협력을 일관성 있게 만들기 위해서 재사용할 수 있는 설계의 묶음</li>
             </ul>
             <strong> 설계와 코드를 함께 재사용하기 위한 것을 프레임워크 라고 한다. </strong>
             <br>
             <ul>
               <li>특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다.</li>
               <li>일관성 있는 협력을 제공하는 확장 가능한 코드</li>
             </ul>
             <hr>
             <strong>
               패턴 
             </strong>
             <ul>
               <li>패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다. </li>
               <li>패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통 할 수 있다. </li>
               <li>패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다. </li>
               <li>패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.</li>
             </ul>
             <hr>
             <p>
               <strong>마틴 파울러&lt;Analysis Pattern></strong> <br>
               내가 사용하는 패턴 정의는 하나의 실무 컨텍스트에서 유용하게 사용해 왔고, 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어이다. 아이디어라는 용어를 사용하는 이유는 
               어떤 것도 패턴이 될 수 있기 때문이다. 패턴은 "GOF"에서 이야기하는 것 처럼 협력하는 객체 그룹일 수도 있고 코플리엔의 프로젝트 조직원리일 수도 있다. 실무 컨텍스트라는 용어는 
               패턴이 실제 프로젝트의 실무 경험에서 비롯됐다는 사실을 반영한다. 흔히 패턴을 '발명했다'고 하지않고 '발견했다'고 말한다. 
               모델의 유용성이 널리 받아들여지는 경우에만 패턴으로 인정할 수 있기 때문에 이말은 타당하다. 실무 프로젝트가 패턴보다 먼저지만 그렇다고 해서 실무 프로젝트의 모든 아이디어가 
               패턴인 것은 아니다. 패턴은 개발자들이 다른 컨텍스트에서도 유용할 것이라고 생각하는 어떤 것이다. 
             </p>

            </div>
        </div>
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
   
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
 
    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Page level plugin JavaScript-->
    <script src="../vendor/chart.js/Chart.min.js"></script>

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>

    <!-- Demo scripts for this page-->
    <script src="../js/demo/chart-area-demo.js"></script>
    <script src="../js/demo/chart-bar-demo.js"></script>
    <script src="../js/demo/chart-pie-demo.js"></script>

  </body>

</html>
