<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines - SOLID</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1 Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">서론</h6>
            <a class="dropdown-item" href="../document/architect_001.html">서론</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">사례연구</h6>
            <a class="dropdown-item" href="../document/architect_002.html">사례연구</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">생성 패턴</h6>
            <a class="dropdown-item" href="../document/architect_003.html">추상 팩토리</a>
            <a class="dropdown-item" href="../document/architect_004.html">빌더</a>
            <a class="dropdown-item" href="../document/architect_005.html">팩토리 메서드</a>
            <a class="dropdown-item" href="../document/architect_006.html">원형</a>
            <a class="dropdown-item" href="../document/architect_007.html">단일체</a>
            <a class="dropdown-item" href="../document/architect_008.html">생성 패턴에 대한 논의</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">구조 패턴</h6>
            <a class="dropdown-item" href="../document/architect_009.html">적응자</a>
            <a class="dropdown-item" href="../document/architect_010.html">가교</a>
            <a class="dropdown-item" href="../document/architect_011.html">복합체</a>
            <a class="dropdown-item" href="../document/architect_012.html">장식자</a>
            <a class="dropdown-item" href="../document/architect_013.html">퍼사드</a>
            <a class="dropdown-item" href="../document/architect_014.html">플라이급</a>
            <a class="dropdown-item" href="../document/architect_015.html">프록시</a>
            <a class="dropdown-item" href="../document/architect_016.html">구조패턴에 대한 논의</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">행동 패턴</h6>
            <a class="dropdown-item" href="../document/architect_017.html">책임 연쇄</a>
            <a class="dropdown-item" href="../document/architect_018.html">명령</a>
            <a class="dropdown-item" href="../document/architect_019.html">해석자</a>
            <a class="dropdown-item" href="../document/architect_020.html">반복자</a>
            <a class="dropdown-item" href="../document/architect_021.html">중재자</a>
            <a class="dropdown-item" href="../document/architect_022.html">메멘토</a>
            <a class="dropdown-item" href="../document/architect_023.html">감시자</a>
            <a class="dropdown-item" href="../document/architect_024.html">상태</a>
            <a class="dropdown-item" href="../document/architect_025.html">전략</a>
            <a class="dropdown-item" href="../document/architect_026.html">템플릿 메서드</a>
            <a class="dropdown-item" href="../document/architect_027.html">방문자</a>
            <a class="dropdown-item" href="../document/architect_028.html">행동 패턴에 대한 논의</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">결론</h6>
            <a class="dropdown-item" href="../document/architect_029.html">디자인 패턴에서 무엇을<br> 기대할 수 있는가?</a>
            <a class="dropdown-item" href="../document/architect_030.html">간략한 역사</a>
            <a class="dropdown-item" href="../document/architect_031.html">패턴 커뮤니티</a>
            <a class="dropdown-item" href="../document/architect_032.html">초대의 글</a>
            <a class="dropdown-item" href="../document/architect_033.html">책을 마무리하며</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">System Archtecture</h6>
            <a class="dropdown-item" href="../document/architect_057.html">The Object</a>
            <a class="dropdown-item" href="../document/architect_053.html">API with Zuul</a>
            <a class="dropdown-item" href="../document/architect_037.html">Cloud System</a>
            <a class="dropdown-item" href="../document/architect_047.html">Cassandra</a>
            <a class="dropdown-item" href="../document/architect_036.html">DevOps</a>
            <a class="dropdown-item" href="../document/architect_045.html">IAC</a>
            <a class="dropdown-item" href="../document/architect_043.html">Kuberneties</a>
            <a class="dropdown-item" href="../document/architect_034.html">MVC</a>
            <a class="dropdown-item" href="../document/architect_049.html">MSA</a>
            <a class="dropdown-item" href="../document/architect_044.html">MOM</a>
            <a class="dropdown-item" href="../document/architect_039.html">PAAS</a>
            <a class="dropdown-item" href="../document/architect_035.html">REST API</a>
            <a class="dropdown-item" href="../document/architect_046.html">SAAS</a>
            <a class="dropdown-item" href="../document/architect_040.html">SCA</a>
            <a class="dropdown-item" href="../document/architect_042.html">SOA</a>
            <a class="dropdown-item" href="../document/architect_041.html">TDD(DDD)</a>
            <a class="dropdown-item" href="../document/architect_048.html">Web Cache</a>
            <a class="dropdown-item" href="../document/architect_050.html">Various Pattern</a>
            <a class="dropdown-item" href="../document/architect_055.html">Hexagonal Architecture</a>
            <a class="dropdown-item" href="../document/architect_056.html">Visualizing Architecture</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>
            <li class="breadcrumb-item active"></li>
          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
              The Object 정리 
            </div>
            <div class="card-body">
              <Strong>더오브젝트 , 마틴 파울러 글 참고</Strong>
              모든 소프트웨어 모듈에는 세 가지 목적이 있다. 첫 번째 목적은 실행 중에 제대로 동작하는 것이다. 이것은 모듈의 존재 이유라고 할 수 있다. 
              두번째 목적은 변경을 위해 존재하는 것이다. 대부분의 모듈은 생명 주기 동안 변경되기 때문에 간단한 작업만으로도 변경이 가능해야 한다. 변경하기 어려운 모듈은
              제대로 동작하더라도 개선해야 한다. 모듈의 세번째 목적은 코드를 읽는 사람과 의사소통 하는 것이다. 모듈은 특별한 훈련없이도 개발자가 쉽게 일고 이해할 수 있어야 한다. 
              읽는 사람과 의사 소통할 수 없는 모듈은 개선해야 한다. 
              <hr>
              객체 사이의 의존성 - 의존성은 변경에 대한 영향을 암시한다. 의존성이라는 말 속에는 어떤 객체가 변경될 때 그 객체엑 의존하는 다른 객체도 함께 변경될 수 있다는 사실이 내포돼 있다. <br>
              자율성은 캡슐화와 연관이 있다. 자율성이 높다는 것은 자신의 변경으로 부터 외부의 영향도가 적다는 것이고 즉 이말은 해당 객체가 적절하게 캡슐화 되어 내부 변경이 외부에 영향을 미치지 않는다는 것이라고 볼 수 있다. 
              <hr>
              설계란 코드를 배치하는 것이다. 
              <hr>
              다형성을 구현하는 방법은 매우 다양하지만 메세지에 응답하기 위해 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다. 다시 말해 메세지와 메서드를 실행시점에 바인딩한다는 것이다. 
              이를 지연 바인딩(Lazy binding) 또는 동적 바인딩(dynamic binding)이라고 부른다. 그에 반해 전통적인 함수 호출처럼 컴파일 시점에 실행될 함수나 프로시저를 결정하는 것을 초기 바인딩 또는 정적 바인딩이라고 부른다. 
              객체지향이 컴파일 시점의 의존성과 실행시점의 의존성을 분리하고, 하나의 메세지를 선택적으로 서로 다른 메서드에 연결할 수 있는 이유가 바로 지연 바인딩이라는 메커니즘을 사용하기 때문이다. 
              <hr>
              항상 구현에 대해서 트레이드 오프를 반드시 고민하라. 
              <hr>
              메세지 - 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단. 
              <hr>
              협력이란 어떤 객체가 다른 객체엑 무엇인가를 요청하는 것이다. 한 객체는 어떤것이 필요할 때 다른 객체에게 전적을 위임하거나 협력한다. 즉 , 두객체가 상호작용을 통해 더 큰 책임을 수행하는 것이다. 객체 사이의 협력을 설계할 때는
              객체를 서로 분리된 인스턴스가 아닌 협력하는 파트너로 인식해야 한다. 
              <hr>
              협력이 설계를 위한 문맥을 결정한다. 
              <hr>
              책임 : 객체에 의해 정의되는 응집도 있는 행위의 집합 <br>
              하는 것 <br>
              <ul>
                <li>객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것</li>
                <li>다른 객체의 행동을 시작시키는 것</li>
                <li>다른 객체의 활동을 제어하고 조절하는 것</li>
              </ul>
              아는 것 <br>
              <ul>
                <li>사적인 정보에 관해 아는 것</li>
                <li>관련된 객체에 관해 아는 것</li>
                <li>자신이 유도하거나 계산할 수 잇는 것에 관해 아는 것 </li>
              </ul>
              <div class="card">
                <div class="card-header">
                   General Responsibility Assignment Software Pattern
                </div>
                <div class="card-body">
                  <blockquote class="blockquote mb-0">
                    <p>
                      
                      "객체에 책임을 할당해야 하는데 그 할당하는 패턴 또는 원칙" , "책임 부여 원칙"
                      <hr>
                      GRASP 패턴은 9가지로 구성되어 있다.
                      <ul>
                        <li>Information Expert : 역할을 수행할 수 있는 정보를 가지고 있는 객체에 역할을 부여하라. </li>
                        <li>Creator : 객체의 생성은 생성되는 객체의 컨텍스트를 알고 있는 다른 객체가 있다면, 컨텍스트를 알고 있는 객체에 부여하자. </li>
                        <li>Controller : 시스템 이벤트(사용자의 요청)을 처리할 객체를 만들자. </li>
                        <li>Low Coupling : 객체들간, 서브 시스템들 간의 상호의존도가 낮게 역할을 부여하자. </li>
                        <li>High Cohesion : 각 객체가 밀접하게 연관된 역할들만 가지도록 역할을 부여하자. </li>
                        <li>Polymorphism : 객체의 종류에 따라서 행동양식이 바뀐다면, 다형성을 사용하자. </li>
                        <li>Pure Fabrication : Information Expert 패턴을 적용하면 Low Coupling과 High Cohesion의 원칙이 깨어진다면, 기능적인 역할을 별도로 한 곳으로 모으자. 데이터베이스 정보를 저장하거나, 로그 정보를 기록하는 역할에 대해 생각해 보자.</li>
                        <li>Indirection : 두 객체 사이의 직접적인 Coupling을 피하고 싶으면, 그 사이에 다른 객체를 사용하라. </li>
                        <li>Protected Variation : 변경될 여지가 있는 곳에 안정된 인터페이스를 정의해서 사용하자. </li>
                      </ul>
                    </p>
                    <footer class="blockquote-footer">https://vandbt.tistory.com/9</footer>
                  </blockquote>
                </div>
              </div>
              <hr>
              책임 주도 설계
              <ul>
                <li>시스템이 사용자에게 제공해야하는 기능인 시스템 책임을 파악한다.</li>
                <li>시스템 책임을 더 작은 책임으로 분할 한다.</li>
                <li>분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.</li>
                <li>객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다. </li>
                <li>해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다. </li>
              </ul>
              <hr>
              메세지가 객체를 결정한다. <br>
              <ul>
                <li>객체가 최소한의 인터페이스를 가질 수 있게 된다. </li>
                <li>객체는 충분히 추상적인 인터페이스를 가질 수 있게 된다. 객체의 인터페이스는 무억을 하는지 표현해야 하지만 어떻게 수행하는지를 노출해서는 안된다. </li>                
              </ul>
              <hr>
              행동이 상태를 결정한다. 
              <ul>
                <li>객체가 협력에 적합한지를 결정짓는 것은 그 객체의 상태이다. </li>
                <li>문제를 해결하기 위해서는 객체가 아닌 책임에 초점을 맞춰야한다. </li>
                <li>역할은 다른 것으로 교체할 수 있는 책임의 집합이다. </li>
              </ul>
              <hr>
              응집도 : 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타낸다. <br>
              결합도 : 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도다. <br>
              변경의 관점에서 응집도란 변경이 발생할 때 모듈 내부에서 발생하는 변경의 정도로 측정할 수 있다. <br>
              결합도는 한 모듈이 변경되기 위해서 다른 모듈의 변경을 요구하는 정도 <br>
              <hr>
              단일 책임 원칙 <br>
              로버트 마틴은 모듈의 응집도가 변경와 연관이 있다는 사실을 강조하기 위해 단일 책임 원칙이라는 
              설계 원칙을 제시했다. 단일 책임 원칙을 한다미로 요약하면 클래스는 단 한 가지의 변경 이유만을 가져야 한다는 
              것이다. 아마 방금전에 설명한 내용을 이해했다면 단일 책임 원칙이 클래스의 응집도를 높일 수 있는 설계 원칙이라는 사실을 이해했을 것이다. <br>
              한가지 주의할 점은 단일 책임 원칙이라는 맥락에서 '책임'이라는 말이 '변경의 이유'라는 의미로 사용된다는 점이다. 
              <hr>
              캡슐화 <br>
              캡슐화란 변할 수 있는 어떤 것이라도 감추는 것이다. 그것이 속성의 타입이건, 할인 정책의 종류건 상관 없이 내부 구현의 변경으로 인해 외부의 객체가 영향을 받는다면 캡슐화를 위반한 것이다. 설계에서 변하는 
              것이 무엇인지 고려하고 변혀난 개념을 캡슐화해야 한다. 
              <hr>
              <ul>
                <li>데이터보다 행동을 먼저 결정하라</li>
                <li>협력이라는 문맥안에서 책임을 결정하라.</li>
              </ul>
              클래스를 셜정하고 그 클래스의 책임을 찾아 나서는 대신 메세지를 결정하고 이 메시지를 누구에게 전송할지 찾아보게 되었다. 클래스 기반 설계에서 
              메시지 기반 설계로의 자리바꿈은 우리가 해오던 설계 활동의 전환점이다. 메시지 기반의 설계 관점은 클래스 기반의 설계 관점보다 훨씬 유연한 애플리케이션을 
              만들 수 있게 해준다. "이 클래스가 필요하다는 점은 알겠는데 이 클래스는 무엇을 해야 하지?"라고 질문하고 않고 "메시지를 전송해야 하는데 누구에게 전송해야 하지?"라고 질문 하는 것. 
              설꼐의 핵심 질문을 이렇게 바꾸는 것이 메시지 기발 설계로 향하는 첫걸음이다. 객체를 가지고 있기 때문에 메시지를 보내는 것이 아니다. 
              메시지를 전송하기 때문에 객체를 갖게 된 것이다. 
              <hr>
              책임 할당을 위한 절차 <br>
              <ul>
                <li>도메인을 구성하기 </li>
                <li>
                  정보 전문가에게 책임을 할당하라 <br>
                  책임을 정보 전문가. 즉, 책임을 수행하는 데 필요한 정보를 가지고 있는 객체에게 할당하라. <br>
                  객체가 자율적인 존재여야 한다는 사실을 다시 한번 상기시킨다. 정보를 알고 있는 객체만이 책임을 어떻게
                  수행할지 스스로 결정할 수 있기 때문이다. <br>


                </li>
                <li>높은 응집도와 낮은 결합도 <br>
                  낮은 결합도는 모든 설계 결정에서 염두에 둬야 하는 원리다. 다시 말해 설계 결정을 평가할 때 적용할 수 있는 
                  평가원리다. 현재의 책임 할당을 검토하거나 여러 설계 대안들이 있을때 낮은 결합도를 유지할 수 있는 설계를 선택하라. 


                </li>
                <li>
                  창조자에게 객체 생성 책임을 할당하라. <br>
                  CREATOR 패턴의 의도는 어떤 방식으로든 생성되는 객체와 연결되거나 관련될 필요가 잇는 객체에 해당 객체를 생성할 책임을 맡기는 것이다. 생성될 객체에 대해 잘 알고 있어야 하거나 
                  그 객체를 사용하는 객체는 어떤 방식으로는 생성될 객체와 연결될 것이다. 

                </li>
              </ul>
              <hr>
              클래스 응집도 판단하기 <br>
              지금까지 클래스의 응집도를 판단할 수 있는 아래의 방법을 확인하면, 
              <ul>
                <li>클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다. 변경의 이유를 기준으로 클래스를 분리하라. </li>
                <li>클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다. 초기화 되는 속성의 그룹을 기준으로 클래스를 분리하라.</li>
                <li>메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다. 이들 그룹을 기준으로 클래스를 분리하라. </li>
              </ul>

              <hr>

             소프트웨어 설계에서 반복적으로 발생하는 문제에 대해 반복적으로 적용할 수 있는 해결 방법을 디자인 패턴 이라고 한다. <br>
             <ul>
               <li>디자인 패턴은 다양한 변경을 다루기 위해 반복적으로 재사용할 수 있는 설계의 묶음</li>
               <li>협력을 일관성 있게 만들기 위해서 재사용할 수 있는 설계의 묶음</li>
             </ul>
             설계와 코드를 함께 재사용하기 위한 것을 프레임워크 라고 한다. <br>
             <ul>
               <li>특정한 변경을 일관성 있게 다룰 수 있는 확장 가능한 코드 템플릿을 제공한다.</li>
               <li>일관성 있는 협력을 제공하는 확장 가능한 코드</li>
             </ul>
             <hr>
             <strong>
               패턴 
             </strong>
             <ul>
               <li>패턴은 반복적으로 발생하는 문제와 해법의 쌍으로 정의된다. </li>
               <li>패턴을 사용함으로써 이미 알려진 문제와 이에 대한 해법을 문서로 정리할 수 있으며, 이 지식을 다른 사람과 의사소통 할 수 있다. </li>
               <li>패턴은 추상적인 원칙과 실제 코드 작성 사이의 간극을 메워주며 실질적인 코드 작성을 돕는다. </li>
               <li>패턴의 요점은 패턴이 실무에서 탄생했다는 점이다.</li>
             </ul>
             <hr>
             <p>
               <strong>마틴 파울러&lt;Analysis Pattern></strong>
               내가 사용하는 패턴 정의는 하나의 실무 컨텍스트에서 유용하게 사용해 왔고, 다른 실무 컨텍스트에서도 유용할 것이라고 예상되는 아이디어이다. 아이디어라는 용어를 사용하는 이유는 
               어떤 것도 패턴이 될 수 있기 때문이다. 패턴은 "GOF"에서 이야기하는 것 처럼 협력하는 객체 그룹일 수도 있고 코플리엔의 프로젝트 조직원리일 수도 있다. 실무 컨텍스트라는 용어는 
               패턴이 실제 프로젝트의 실무 경험에서 비롯됐다는 사실을 반영한다. 흔히 패턴을 '발명했다'고 하지않고 '발견했다'고 말한다. 
               모델의 유용성이 널리 받아들여지는 경우에만 패턴으로 인정할 수 있기 때문에 이말은 타당하다. 실무 프로젝트가 패턴보다 먼저지만 그렇다고 해서 실무 프로젝트의 모든 아이디어가 
               패턴인 것은 아니다. 패턴은 개발자들이 다른 컨텍스트에서도 유용할 것이라고 생각하는 어떤 것이다. 
             </p>

            </div>
        </div>
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
   
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
 
    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Page level plugin JavaScript-->
    <script src="../vendor/chart.js/Chart.min.js"></script>

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>

    <!-- Demo scripts for this page-->
    <script src="../js/demo/chart-area-demo.js"></script>
    <script src="../js/demo/chart-bar-demo.js"></script>
    <script src="../js/demo/chart-pie-demo.js"></script>

  </body>

</html>
