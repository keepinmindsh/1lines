<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines - 패턴을 활용한 리팩터링</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1 Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">도서 정리</h6>
            <a class="dropdown-item" href="../document/architect_057.html">The Object</a>
            <a class="dropdown-item" href="../document/architect_058.html">패턴을 활용한 리팩터링</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>
            <li class="breadcrumb-item active"></li>
          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
              패턴을 활용한 리팩터링
            </div>
            <div class="card-body">
              <div class="list-group">
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                     &lt; 설계를 위한 예제 >
                    </h5>
                  </div>
                  <p class="mb-1">
                    스타크래프트를 이용한 예제 
                    <br>
                    테란의 커맨드 센터에서 SCV을 통해서 미네랄을 캐고, 가스를 캐어 배럭을 건설한다. 
                    건설된 배럭에서 마린, 메딕을 생산하여 저그를 공격해가는 과정을 정의한다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Constructors with Creation Methods
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 클래스의 인스턴스를 생성할 때 그것이 제공하는 여러 생성자 중 어떤 것을 호출해야 할 지 결정하기가 어렵다면, 
                    인스턴스를 생성해 리턴하는 생성 메서드로 각 생성자를 내체하여 그 용도가 명확히 드러나도록 한다. 
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse01;

import pattern.sample.patternuse01.building.Barrack;
import pattern.sample.patternuse01.code.UnitType;
import pattern.sample.patternuse01.unit.inf.Unit;

public class BattleGround {

    public static void main(String[] args) {

        Unit marine = Barrack.createUnit(UnitType.MARINE);

        marine.checkStatus();

        Unit medic = Barrack.createUnit(UnitType.MEDIC);

        medic.checkStatus();

    }
}

package pattern.sample.patternuse01.building;

import pattern.sample.patternuse01.code.UnitType;
import pattern.sample.patternuse01.unit.Empty;
import pattern.sample.patternuse01.unit.Marine;
import pattern.sample.patternuse01.unit.Medic;
import pattern.sample.patternuse01.unit.inf.Unit;

public class Barrack {

    public static Unit createUnit(UnitType unitType){
        switch (unitType){
            case MEDIC:
                return new Medic();
            case MARINE:
                return new Marine();
            default:
                return new Empty();
        }

    }
}

package pattern.sample.patternuse01.unit.status;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public class UnitStatus {
    private final int health;
}


package pattern.sample.patternuse01.code;

public enum UnitType {
    MARINE,
    MEDIC
}

package pattern.sample.patternuse01.unit.inf;

public interface Unit {

    public void checkStatus();
}

package pattern.sample.patternuse01.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse01.unit.inf.Unit;

@Slf4j
public class Empty implements Unit {

    @Override
    public void checkStatus() {
        log.info("Empty, do nothing!");
    }
}

package pattern.sample.patternuse01.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse01.unit.inf.Unit;
import pattern.sample.patternuse01.unit.status.UnitStatus;

@Slf4j
public class Marine implements Unit {

    private final UnitStatus unitStatus;

    public Marine(){
        unitStatus = UnitStatus.builder().health(70).build();
    }

    @Override
    public void checkStatus() {
        log.info("Marine Health : {}", unitStatus.getHealth());
    }
}

package pattern.sample.patternuse01.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse01.unit.inf.Unit;
import pattern.sample.patternuse01.unit.status.UnitStatus;

@Slf4j
public class Medic implements Unit {
    private final UnitStatus unitStatus;

    public Medic(){
        unitStatus = UnitStatus.builder().health(50).build();
    }

    @Override
    public void checkStatus(){
        log.info("Medic Health : {}", unitStatus.getHealth());
    }
}


                        
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Chain Constructors
                    </h5>
                  </div>
                  <p class="mb-1">
                    중복된 코드를 갖는 생성자가 여러 개 있다면, 중복을 최소화하기 위해 생성자들이 서로 호출하게 한다.
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse02;

import pattern.sample.patternuse02.building.inf.Constructor;
import pattern.sample.patternuse02.code.BuildType;
import pattern.sample.patternuse02.unit.creator.SCV;

public class BattleGround {
    public static void main(String[] args) {

        Constructor barrack1 = SCV.createBuilding(BuildType.BARRACK, 150, 0);

        Constructor factory1 = SCV.createBuilding(BuildType.FACTORY, 150, 150);

        barrack1.createBuilding();
        factory1.createBuilding();
    }
}

package pattern.sample.patternuse02.code;

public enum BuildType {
    BARRACK,
    FACTORY
}
                        
package pattern.sample.patternuse02.unit.creator;

import pattern.sample.patternuse02.building.Barrack;
import pattern.sample.patternuse02.building.constructor.BuildingConstructor;
import pattern.sample.patternuse02.building.Factory;
import pattern.sample.patternuse02.code.BuildType;

public class SCV {
    public static BuildingConstructor createBuilding(BuildType buildType, int mineral, int gas){
        switch (buildType){
            case BARRACK:
                return new BuildingConstructor(mineral, gas, new Barrack());
            case FACTORY:
                return new BuildingConstructor(mineral, gas, new Factory());
            default:
                return null;
        }
    }
}

package pattern.sample.patternuse02.building.constructor;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse02.building.inf.Building;
import pattern.sample.patternuse02.building.inf.Constructor;

@RequiredArgsConstructor
public class BuildingConstructor implements Constructor {

    private final int mineral;
    private final int gas;
    private final Building building;

    public Building createBuilding(){
        return building;
    }
}

package pattern.sample.patternuse02.building;

import pattern.sample.patternuse02.ability.Heal;
import pattern.sample.patternuse02.ability.Shot;
import pattern.sample.patternuse02.building.inf.Building;
import pattern.sample.patternuse02.code.UnitType;
import pattern.sample.patternuse02.unit.Marine;
import pattern.sample.patternuse02.unit.Medic;
import pattern.sample.patternuse02.unit.NotUnit;
import pattern.sample.patternuse02.unit.inf.Unit;

public class Barrack implements Building {

    public Unit makeUnit(UnitType unitType){

        switch (unitType){
            case MARINE:
                return new Marine(new Shot());
            case MEDIC:
                return new Medic(new Heal());
            default:
                return new NotUnit();
        }
    }
}

package pattern.sample.patternuse02.building;

import pattern.sample.patternuse02.building.inf.Building;
import pattern.sample.patternuse02.code.UnitType;
import pattern.sample.patternuse02.unit.inf.Unit;

public class Factory implements Building {
    @Override
    public Unit makeUnit(UnitType unitType) {
        return null;
    }
}

                        
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Encapsulate Classes with Factory 
                    </h5>
                  </div>
                  <p class="mb-1">
                    클라이언트가 한 패키지 내의, 공통 인터페이스를 가지는 클래스들의 인스턴스를 직접 생성하고 있다면, 
                    그 클래스의 생성자를 클라이언트가 직접 볼 수 없게 바꾸고 클라이언트는 팩터리 를 통해 그 인스턴스를 얻도록 한다. 
                    <hr>
                    <ul>
                      <li>용도를 쉽게 알아볼 수 있는 생성 메서드를 제공하여, 클라이언트가 원하는 종류의 객체르리 쉽게 생성할 수 있도록 한다. </li>
                      <li>공개될 필요가 없는 클래스들을 숨겨 패키지의 '개념적 무게'를 줄인다. </li>
                      <li>클라이언트가 '구현에 대해서가 아니라, 인터페이스에 대해 프로그래밍' 하게 된다. </li>
                      <li>새로운 종류의 객체가 필요할 경우에는 생성 메서드를 추갛거나 수정해야 한다. </li>
                      <li>팩터리의 소스 코드가 아닌 바이너리만 배포할 경우에는 클라이언트가 쉽게 수정할 수 없게 된다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse03;

import pattern.sample.patternuse03.building.Barrack;
import pattern.sample.patternuse03.operation.Armed;

public class BattleGround {
    public static void main(String[] args) {
        Armed armedMarine = Barrack.forMarine();

        Armed armedMedic = Barrack.forMedic();
    }
}

package pattern.sample.patternuse03.building;

import pattern.sample.patternuse03.equipment.AttackingGloves;
import pattern.sample.patternuse03.equipment.CMCArmor;
import pattern.sample.patternuse03.equipment.HealGloves;
import pattern.sample.patternuse03.equipment.MedicArmor;
import pattern.sample.patternuse03.operation.Armed;
import pattern.sample.patternuse03.unit.Marine;
import pattern.sample.patternuse03.unit.Medic;

public class Barrack {

    public static Armed forMarine(){
        return new Armed(new Marine(new CMCArmor(), new AttackingGloves()));
    }

    public static Armed forMedic(){
        return new Armed(new Medic(new MedicArmor(), new HealGloves()));
    }
}

package pattern.sample.patternuse03.operation;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse03.unit.inf.Unit;

@RequiredArgsConstructor
public class Armed {

    private final Unit unit;
}


package pattern.sample.patternuse03.equipment.inf;

public interface Armor {
}

package pattern.sample.patternuse03.equipment;

import pattern.sample.patternuse03.equipment.inf.Armor;

public class CMCArmor implements Armor {
}

package pattern.sample.patternuse03.equipment;

import pattern.sample.patternuse03.equipment.inf.Armor;

public class MedicArmor implements Armor {
}

package pattern.sample.patternuse03.equipment.inf;

public interface Gloves {
}

package pattern.sample.patternuse03.equipment;

import pattern.sample.patternuse03.equipment.inf.Gloves;

public class AttackingGloves implements Gloves {
}

package pattern.sample.patternuse03.equipment;

import pattern.sample.patternuse03.equipment.inf.Gloves;

public class HealGloves implements Gloves {
}

package pattern.sample.patternuse03.unit.inf;

public interface Unit {
}

package pattern.sample.patternuse03.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse03.equipment.inf.Armor;
import pattern.sample.patternuse03.equipment.inf.Gloves;
import pattern.sample.patternuse03.unit.inf.Unit;

@RequiredArgsConstructor
public class Marine implements Unit {
    private final Armor armor;
    private final Gloves gloves;
}

package pattern.sample.patternuse03.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse03.equipment.inf.Armor;
import pattern.sample.patternuse03.equipment.inf.Gloves;
import pattern.sample.patternuse03.unit.inf.Unit;

@RequiredArgsConstructor
public class Medic implements Unit {
    private final Armor armor;
    private final Gloves gloves;
}
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Introduce Polymorphic Creation with Factory Method
                    </h5>
                  </div>
                  <p class="mb-1">
                    한 상속 구조 내의 클래스들이 어떤 메서드를 각자 구현하는데 객체 생성 단계만 제외하고 나머지가 서로 유사하다면, 
                    그 메서드를 수퍼 클래스로 옮기고 객체 생성은 팩터리 메서드에 맡기도록 한다. 
                    <hr>
                    <ul>
                      <li>객체를 생성하는 과정에서의 코드 중복을 줄인다.</li>
                      <li>객체를 생성하는 곳이 실제로는 어디고, 또 어떻게 오버라이드 하면 되는지 잘 드러난다. </li>
                      <li>팩터리 메서드에서 인스턴스로 만들 클래스가 특정 타입을 구현하도록 강제할 수 있다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse04;

import pattern.sample.patternuse04.building.Barrack;
import pattern.sample.patternuse04.code.UnitType;
import pattern.sample.patternuse04.unit.inf.Unit;

public class BattleGround {
    public static void main(String[] args) {

        Unit marine = Barrack.createUnit(UnitType.MARINE);
        Unit medic = Barrack.createUnit(UnitType.MEDIC);
        Unit firebat = Barrack.createUnit(UnitType.FIREBAT);

        marine.action();
        medic.action();
        firebat.action();
    }
}

package pattern.sample.patternuse04.building;

import pattern.sample.patternuse04.code.UnitType;
import pattern.sample.patternuse04.trainer.FireBatTrainer;
import pattern.sample.patternuse04.trainer.MarineTrainer;
import pattern.sample.patternuse04.trainer.MedicTrainer;
import pattern.sample.patternuse04.trainer.factory.Trainer;
import pattern.sample.patternuse04.unit.inf.Unit;

public class Barrack {

    public static Unit createUnit(UnitType unitType){

        Trainer trainer;

        switch (unitType){
            case MARINE:
                trainer = new MarineTrainer();
            case MEDIC:
                trainer = new MedicTrainer();
            default:
                trainer = new FireBatTrainer();
        }

        return trainer.createUnit();
    }
}

package pattern.sample.patternuse04.code;

public enum UnitType {
    MARINE,
    MEDIC,
    FIREBAT
}

package pattern.sample.patternuse04.trainer.factory;

import pattern.sample.patternuse04.unit.inf.Unit;

public abstract class Trainer {

    public abstract Unit createUnit();
}

package pattern.sample.patternuse04.trainer;

import pattern.sample.patternuse04.trainer.factory.Trainer;
import pattern.sample.patternuse04.unit.FireBat;
import pattern.sample.patternuse04.unit.inf.Unit;

public class FireBatTrainer extends Trainer {
    @Override
    public Unit createUnit() {
        return new FireBat();
    }
}

package pattern.sample.patternuse04.trainer;

import pattern.sample.patternuse04.trainer.factory.Trainer;
import pattern.sample.patternuse04.unit.Marine;
import pattern.sample.patternuse04.unit.inf.Unit;

public class MarineTrainer extends Trainer {
    @Override
    public Unit createUnit() {
        return new Marine();
    }
}

package pattern.sample.patternuse04.trainer;

import pattern.sample.patternuse04.trainer.factory.Trainer;
import pattern.sample.patternuse04.unit.Medic;
import pattern.sample.patternuse04.unit.inf.Unit;

public class MedicTrainer extends Trainer {
    @Override
    public Unit createUnit() {
        return new Medic();
    }
}

package pattern.sample.patternuse04.unit.inf;

public interface Unit {

    public void action();
}

package pattern.sample.patternuse04.unit;

import pattern.sample.patternuse04.unit.inf.Unit;

public class FireBat implements Unit {
    @Override
    public void action() {

    }
}

package pattern.sample.patternuse04.unit;

import pattern.sample.patternuse04.unit.inf.Unit;

public class Marine implements Unit {
    @Override
    public void action() {

    }
}

package pattern.sample.patternuse04.unit;

import pattern.sample.patternuse04.unit.inf.Unit;

public class Medic implements Unit {
    @Override
    public void action() {

    }
}

                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Conditional Logic with Strategy
                    </h5>
                  </div>
                  <p class="mb-1">
                    메서드 내의 조건문을 통해 여러 개의 서로 다른 로직(계산법) 가운데 어떤 것을 실행할 지 선택하고 있다면, 
                    각 계산법에 대응하는 스트레티지(Strategy) 클래스를 만들고 해당 스트레티지 인스턴스에 계산을 위임하도록 메서드를 수정한다. 
                    <hr>
                    <ul>
                      <li>조건 로직을 줄이거나 제거해 알고리즘을 명확하게 한다.</li>
                      <li>알고지름 내의 여러 로직을 상속 구조로 옮겨 클래스를 단순화 한다. </li>
                      <li>런타임에 어떤 알고리즘을 다른 알고리즘으로 변경하기가 쉬어진다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse05;

import pattern.sample.patternuse05.building.Barrack;
import pattern.sample.patternuse05.code.UnitType;
import pattern.sample.patternuse05.unit.inf.Unit;

public class BattleGround {
    public static void main(String[] args) {
        Unit marine = Barrack.createUnit(UnitType.MARINE);

        Unit medic = Barrack.createUnit(UnitType.MEDIC);

        marine.action();

        medic.action();
    }
}

package pattern.sample.patternuse05.ability.inf;

public interface Action {
    public void act();
}

package pattern.sample.patternuse05.ability;

import pattern.sample.patternuse05.ability.inf.Action;

public class Attack implements Action {
    @Override
    public void act() {

    }
}

package pattern.sample.patternuse05.ability;

import pattern.sample.patternuse05.ability.inf.Action;

public class Heal implements Action {
    @Override
    public void act() {

    }
}

package pattern.sample.patternuse05.building;

import pattern.sample.patternuse05.ability.Attack;
import pattern.sample.patternuse05.ability.Heal;
import pattern.sample.patternuse05.code.UnitType;
import pattern.sample.patternuse05.unit.Marine;
import pattern.sample.patternuse05.unit.Medic;
import pattern.sample.patternuse05.unit.inf.Unit;

public class Barrack {
    public static Unit createUnit(UnitType unitType){
        switch (unitType){
            case MARINE:
                return new Marine(new Attack());
            case MEDIC:
                return new Medic(new Heal());
            default:
                return null;
        }
    }
}

package pattern.sample.patternuse05.code;

public enum UnitType {
    MARINE,
    MEDIC
}

package pattern.sample.patternuse05.unit.inf;

public interface Unit {
    public void action();
}

package pattern.sample.patternuse05.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse05.ability.inf.Action;
import pattern.sample.patternuse05.unit.inf.Unit;

@RequiredArgsConstructor
public class Marine implements Unit {

    private final Action action;

    @Override
    public void action() {
        action.act();
    }
}

package pattern.sample.patternuse05.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse05.ability.inf.Action;
import pattern.sample.patternuse05.unit.inf.Unit;

@RequiredArgsConstructor
public class Medic implements Unit {

    private final Action action;

    @Override
    public void action() {
        action.act();
    }
}
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Form Template Method
                    </h5>
                  </div>
                  <p class="mb-1">
                    한 상속 구조 내의 어떤 두 서브 클래스가 유사한 단위 작업을 같은 순서로 실행하는 메서드를 각자 구현하고 있다면, 
                    각 단위 작업을 별도의 메서드로 뽑아내어 두 메서드를 일반화하고 이렇게 일반화 된 메서드를 수퍼 클래스로 올려 템플릿 메서드로 만든다. 
                    <ul>
                      <li>서브 클래스 들의 공통 기능을 수퍼 클래스로 옮겨, 중복 코드가 제거 된다. </li>
                      <li>알고리즘의 과정이 단순해지고, 쉽게 알아볼 수 있다. </li>
                      <li>서브 클래스에서 알고리즘의 구현을 재정의하는 것이 쉬워진다. </li>
                      <li>서브 클래스가 꼭 구현해야하는 메서드의 개수가 많다면, 설계가 복잡해진다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse06;

import pattern.sample.patternuse06.building.Barrack;
import pattern.sample.patternuse06.code.UnitType;
import pattern.sample.patternuse06.unit.inf.Unit;

public class BattleGround {
    public static void main(String[] args) {
        Unit marine = Barrack.createUnit(UnitType.MARINE);

        marine.Action();

        Unit medic = Barrack.createUnit(UnitType.MEDIC);

        medic.Action();
    }
}

package pattern.sample.patternuse06.building;

import pattern.sample.patternuse06.code.UnitType;
import pattern.sample.patternuse06.template.Training;
import pattern.sample.patternuse06.template.impl.MarineTraining;
import pattern.sample.patternuse06.template.impl.MedicTraining;
import pattern.sample.patternuse06.unit.Marine;
import pattern.sample.patternuse06.unit.Medic;
import pattern.sample.patternuse06.unit.inf.Unit;

import static pattern.sample.patternuse06.code.UnitType.MARINE;
import static pattern.sample.patternuse06.code.UnitType.MEDIC;

public class Barrack {
    public static Unit createUnit(UnitType unitType){
        Training training;

        switch (unitType){
            case MARINE:
                training = new MarineTraining();

                return new Marine(training.trainingUnit(MARINE));

            case MEDIC:
                training = new MedicTraining();

                return new Medic(training.trainingUnit(MEDIC));

            default:
                return null;
        }
    }
}


package pattern.sample.patternuse06.code;

public enum UnitType {
    MARINE,
    MEDIC
}

package pattern.sample.patternuse06.template;

import pattern.sample.patternuse06.code.UnitType;
import pattern.sample.patternuse06.unit.action.inf.Action;

public abstract class Training {

    public Action trainingUnit(UnitType unitType){

        return training();
    }

    public abstract Action training();
}


package pattern.sample.patternuse06.template.impl;

import pattern.sample.patternuse06.template.Training;
import pattern.sample.patternuse06.unit.action.Attack;
import pattern.sample.patternuse06.unit.action.inf.Action;

public class MarineTraining extends Training {
    @Override
    public Action training() {
        return new Attack();
    }
}

package pattern.sample.patternuse06.template.impl;

import pattern.sample.patternuse06.template.Training;
import pattern.sample.patternuse06.unit.action.Heal;
import pattern.sample.patternuse06.unit.action.inf.Action;

public class MedicTraining extends Training {
    @Override
    public Action training() {
        return new Heal();
    }
}

package pattern.sample.patternuse06.unit.action.inf;

public interface Action {
    public void act();
}

package pattern.sample.patternuse06.unit.action;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse06.unit.action.inf.Action;

@Slf4j
public class Attack implements Action {
    @Override
    public void act() {
        log.info("공격하다.");
    }
}

package pattern.sample.patternuse06.unit.action;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse06.unit.action.inf.Action;

@Slf4j
public class Heal implements Action {
    @Override
    public void act() {
        log.info("치료하다.");
    }
}

package pattern.sample.patternuse06.unit.inf;

public interface Unit {
    public void Action();
}

package pattern.sample.patternuse06.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse06.unit.action.inf.Action;
import pattern.sample.patternuse06.unit.inf.Unit;

@RequiredArgsConstructor
public class Marine implements Unit {

    private final Action action;

    @Override
    public void Action() {
        action.act();
    }
}

package pattern.sample.patternuse06.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse06.unit.action.inf.Action;
import pattern.sample.patternuse06.unit.inf.Unit;

@RequiredArgsConstructor
public class Medic implements Unit {

    private final Action action;

    @Override
    public void Action() {
        action.act();
    }
}
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Compose Method
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 메서드의 내부 로직이 한 눈에 이해하기 어렵다면, 그 로직을 의도가 잘 드러나며 동등한 수준의 작업을 하는 여러 단계로 나눈다. 
                    <ul>
                      <li>어떤 메서드가 무슨일을 하고, 또 그 일을 수행하는지 효과적으로 표현한다. </li>
                      <li>동등한 수준의 작업을 하며 이름이 적절하게 붙은 몇 단계로 내부를 나눔으로써, 메서드를 단순하게 만든다. </li>
                      <li>작은 메서드가 지나치게 많이 생길 수 있다.</li>
                      <li>로직이 여러 곳에 흩어지기 때문에 디버깅이 어려울 수 있다. </li>
                    </ul>
                    <hr>
                    절차 
                    <ul>
                      <li>
                        <strong>작게 만든다.</strong> 
                        Composed Method의 코드는 10줄을 잘 넘어가지 않는다. 보통 5줄 정도다. 
                      </li>
                      <li>
                        <strong>사용되지 않거나 중복된 코드를 제거한다. </strong> 
                        이렇게 함으로써 메서드 내부의 코드량을 줄일 수 있다. 중복된 코드 중에는 명확하게 드러나는 것도 있지만 유심히 살펴봐야 발견할 수 있는 경우도 있음을 명심하기 바란다. 
                      </li>
                      <li>
                        <strong>코드의 의도가 잘 드러나도록 한다. </strong> 
                        변수와 메서드, 파라미터의 이름이 그 목적을 잘 표현하도록 짓는다. ( 예를 들어, public void addChildTo(Nodeparent) 와 같은 식으로 )
                      </li>
                      <li>
                        <strong>단순화 한다.</strong>
                        코드를 가능한 한 단순하게 변경한다. 기존의 코드가 어떻게 작성됐는지 고착하고, 다른 대안을 시험해본다. 
                      </li>
                      <li>
                        <strong>동등한 수준으로 단계를 나눈다.</strong>
                        메서드를 여러 작업 단계로 나눌 때, 각 단계가 동등한 수준이 되도록 해야한다. 예를 들어, 세부 조건을 검사하는 로직과 몇 개의 고수준 메서드를 호출하는 코드가 섞여 있다면, 동등하지 않은 수준의 단계들로 이루어진것이다. 세부 조건 로직을 이름이 잘 지어진 별도의 메서드로 뽑아내, 다른 
                        고수준 메서드와 동등한 수준으로 맞춰야 한다. 
                      </li>
                    </ul>
                    예제 
                    <pre>
                      <code class="java" >
public class List... 
 
  // 매직 넘버 10은 그 목적을 전혀 표현하지 못하는 숫자로 하드 코딩 되어 있으므로, 먼저 이를 상수로 변경한다. 
  private final static int GROWTH_INCREMENT = 10;                        

  public void add(Object element) {
    // 조건 문으로 메서드 전체를 감싸기보다는 다음과 같이 초반에 메서드를 빠져 나가도록 함으로써 메서드의 실행 요건을 명시하는 것이 낫다. 
    if ( readOnly )
      return;
    
    // elements 배열의 크기를 늘릴 필요가 있는지를 검사하는 코드에 Extract Method 리팩터링을 적용한다. 
    if(atCapacity()){
      grow();
    }
    addElement(elements);
  }  
  
  private boolean atCapacity(){
    return (size + 1) > elements.length;
  }

  private void grow() {
    Object[] newElements = new Object[elements.length + GROWTH_INCREMENT];
    for ( int i = 0; i &lt; size ; i ++ ){
      newElements[i] = elements[i];
    }
    elements = newElements;
  }

  private void addElement(Object element){
    element[size++] = element;
  }
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Implicit Tree with Composite 
                    </h5>
                  </div>
                  <p class="mb-1">
                    실질적으로 트리 구조인 데이터를 String 과 같은 기본 타입으로 표현하고 있다면, 그 기본 타입의 표현을 컴포짓 구조로 바꾼다. 
                    <ul>
                      <li>코드를 더 단순하게 만들기 위해서 Composite 패턴을 사용한다. </li>
                      <li>노드를 추가/삭제/포매팅하는 등의 반복적인 코드를 캡슐화 한다. </li>
                      <li>빈번하게 사용하는 유사한 로직을 다루기 위한 일반화된 방법을 제공한다.</li>
                      <li>클라이언트가 데이터를 생성하는 방법이 단순해진다. </li>
                    </ul>
                    <hr>
                    묵시적 트리 중에서 새로운 클래스로 모델화할 수 있는 부분인, 묵시적 종단을 찾는다. 이 때 새로운 클래스는 종단 노드를 나타내는 것으로, Composite:Leaf에 해당한다. 종단 노드 클래스는 리팩터링 또는 테스트 주도 갭잘을 통해서 생성할 수 있다. 
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse07;

import pattern.sample.patternuse07.building.Barrack;
import pattern.sample.patternuse07.unit.UnitComposite;
import pattern.sample.patternuse07.unit.type.MarineType;
import pattern.sample.patternuse07.unit.type.MedicType;

public class BattleGround {
    public static void main(String[] args) {
        UnitComposite unitList = Barrack.requestUnit();

        unitList.addTrainedUnit(new MedicType());
        unitList.addTrainedUnit(new MarineType());
        unitList.addTrainedUnit(new MarineType());
        unitList.addTrainedUnit(new MarineType());
        unitList.addTrainedUnit(new MarineType());
        unitList.addTrainedUnit(new MedicType());
        unitList.addTrainedUnit(new MedicType());
        unitList.addTrainedUnit(new MedicType());
        unitList.addTrainedUnit(new MedicType());

        unitList.trainingUnit();

        unitList.checkTrainedUnit();
    }
}

package pattern.sample.patternuse07.building;

import pattern.sample.patternuse07.unit.UnitComposite;

public class Barrack {
    public static UnitComposite requestUnit(){
        return new UnitComposite();
    }
}


package pattern.sample.patternuse07.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse07.unit.impl.Marine;
import pattern.sample.patternuse07.unit.impl.Medic;
import pattern.sample.patternuse07.unit.inf.Unit;
import pattern.sample.patternuse07.unit.type.MarineType;
import pattern.sample.patternuse07.unit.type.MedicType;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class UnitComposite {

    private final List&lt;UnitComposite> unitCompositeList = new ArrayList&lt;>();
    private List&lt;Unit> unitList;

    public void trainingUnit(){
        unitList = unitCompositeList.stream().map(trainingType -> {
            trainingType.trainingUnit();

            if(trainingType instanceof MarineType){
                return new Marine();
            }else if(trainingType instanceof MedicType){
                return new Medic();
            }else {
                return null;
            }
        }).collect(Collectors.toList());
    }

    public void checkTrainedUnit(){
        unitList.forEach(Unit::checkUnit);
    }

    public void addTrainedUnit(UnitComposite unitComposite){
        unitCompositeList.add(unitComposite);
    }
}

package pattern.sample.patternuse07.unit.type;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse07.unit.UnitComposite;

@Slf4j
public class MedicType extends UnitComposite {
    @Override
    public void trainingUnit() {
        log.info("메딕 훈련을 시작합니다. ");
    }
}

package pattern.sample.patternuse07.unit.type;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse07.unit.UnitComposite;

@Slf4j
public class MarineType extends UnitComposite {

    @Override
    public void trainingUnit() {
        log.info("마린 훈련을 시작합니다. ");
    }
}

package pattern.sample.patternuse07.unit.inf;

public interface Unit {
    public void checkUnit();
}

package pattern.sample.patternuse07.unit.impl;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse07.unit.inf.Unit;

@Slf4j
public class Marine implements Unit {
    @Override
    public void checkUnit() {
        log.info("Marine 입니다.");
    }
}

package pattern.sample.patternuse07.unit.impl;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse07.unit.inf.Unit;

@Slf4j
public class Medic implements Unit {
    @Override
    public void checkUnit() {
        log.info("Medic 입니다.");
    }
}



                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Encapsulate Composite with Builder
                    </h5>
                  </div>
                  <p class="mb-1">
                    컴포짓 구조를 생성하는 과정이 반복적으로 수행되고 복잡하며 에러 발생 가능성도 많은 상태라면, 그 세부 사항을 처리하는 별도의 빌더를 제공하여 
                    컴포짓 구조를 쉽게 생성할 수 있도록 한다. 
                    <hr>                  
                    <ul>
                      <li>컴포짓 구조를 생성하는 클라이언트의 코드를 단순화 한다.</li>
                      <li>반복적이고 에러 발생 가능성이 높은 컴포짓 구조 생성 작업의 단점을 개선한다. </li>
                      <li>클라이언트 코드의 컴포짓 구조 사이의 결합을 느슨하게 한다.</li>
                      <li>캡슐화된 컴포짓 구조 또는 복잡한 객체의 여러 다양한 표현이 가능하게 한다.</li>
                      <li>인터페이스의 의도가 덜 명확해질 수 있다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse08;

import pattern.sample.patternuse08.building.Barrack;
import pattern.sample.patternuse08.code.UnitType;
import pattern.sample.patternuse08.unit.inf.Unit;
import pattern.sample.patternuse08.unitBuilder.UnitBuilder;

public class BattleGround {
    public static void main(String[] args) {
        Unit marine = Barrack.createUnit(UnitBuilder.builder()
                                    .unitName("Marine")
                                    .unitType(UnitType.MARINE).build());


    }
}

package pattern.sample.patternuse08.building;

import pattern.sample.patternuse08.unit.inf.Unit;
import pattern.sample.patternuse08.unitBuilder.UnitBuilder;

public class Barrack {

    public static Unit createUnit(UnitBuilder unitBuilder){
        return unitBuilder.createUnit();
    }

}

package pattern.sample.patternuse08.code;

public enum UnitType {
    MARINE,
    MEDIC,
    SCV
}

package pattern.sample.patternuse08.unit.inf;

public interface Unit {
}

package pattern.sample.patternuse08.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse08.unit.inf.Unit;

@Slf4j
public class Marine implements Unit {
    public Marine() {
        log.info("Marine이 생성되었습니다. ");
    }
}

package pattern.sample.patternuse08.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse08.unit.inf.Unit;

@Slf4j
public class Medic implements Unit {
    public Medic(){
        log.info("Medic이 생성되었습니다.");
    }
}

package pattern.sample.patternuse08.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse08.unit.inf.Unit;

@Slf4j
public class SCV implements Unit {
    public SCV() {
        log.info("SCV이 생성되었습니다.");
    }
}

package pattern.sample.patternuse08.unitBuilder;

import lombok.Builder;
import pattern.sample.patternuse08.code.UnitType;
import pattern.sample.patternuse08.unit.Marine;
import pattern.sample.patternuse08.unit.Medic;
import pattern.sample.patternuse08.unit.SCV;
import pattern.sample.patternuse08.unit.inf.Unit;

public class UnitBuilder {

    private final String unitName;
    private final UnitType unitType;

    @Builder
    public UnitBuilder(String unitName, UnitType unitType){
        this.unitName = unitName;
        this.unitType = unitType;
    }

    public Unit createUnit(){
        switch (unitType){
            case MEDIC:
                return new Medic();
            case MARINE:
                return new Marine();
            default:
                return new SCV();
        }
    }
}                    
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Move Accumulation to Collecting Parameter
                    </h5>
                  </div>
                  <p class="mb-1">
                    지역변수에 정보를 축적하는 매우 긴 메서드가 있다면, 그것을 여러 메서드로 분해하고 각 메서드에 수집 파라미터를 넘겨 정보를 축적하도록 한다. 
                    <hr>
                    다루기 어려울 정도로 비대한 메서드를 분해해 Composed Method로 만들려면, 
                    Composed Method에 의해 호출되는 각 메서드로부터 정보를 얻어 어떻게 축적할 것인지 
                    결정해야 한다. 각 메서드가 리턴한 정보를 보관해 두었다가 나중에 최종 형태로 합칠 수도 있지만 각 메서드에 수집 파라미터를 넘겨 정보를 점진적으로 축적할 수도 있다. 각 메서드는 자신의 정보를 수집 파라미터에 쓰고, 그 결과로 정보가 축적된다. 
                    
                    <ul>
                      <li>다루기 어려울 정도로 비대한 메서드를 작고 간단하며 이해하기 쉬운 여러 개의 메서드로 분해하는 데 도움이 된다. </li>
                      <li>코드의 실행 속도가 향상될 수 있다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse09;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse09.building.Barrack;
import pattern.sample.patternuse09.code.UnitType;
import pattern.sample.patternuse09.unit.inf.Unit;

@Slf4j
public class BattleGround {
    public static void main(String[] args) {
        Unit unit = Barrack.getUnit(UnitType.MARINE);

        Unit unitMedic = Barrack.getUnit(UnitType.MEDIC);

        log.info("결과 : {}" ,unit.checkAbility());
        log.info("결과 : {}" ,unitMedic.checkAbility());
    }
}

package pattern.sample.patternuse09.builder;

import lombok.Builder;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@Builder
public class TrainingBuilder {
    private final Training walking;
    private final Training running;
    private final Training jumping;
    private final Training hiding;
    private final Training watching;
    private final Unit unit;

    public Unit trainingUnit(){

        walking.practice(unit);

        running.practice(unit);

        jumping.practice(unit);

        hiding.practice(unit);

        watching.practice(unit);

        return unit;
    }
}

package pattern.sample.patternuse09.building;

import pattern.sample.patternuse09.builder.TrainingBuilder;
import pattern.sample.patternuse09.code.UnitType;
import pattern.sample.patternuse09.order.*;
import pattern.sample.patternuse09.unit.Marine;
import pattern.sample.patternuse09.unit.Medic;
import pattern.sample.patternuse09.unit.inf.Unit;

public class Barrack {
    public static Unit getUnit(UnitType unitType){

        if(unitType == UnitType.MARINE){
            return TrainingBuilder
                    .builder()
                    .unit(new Marine())
                    .hiding(new Hiding())
                    .jumping(new Jumping())
                    .running(new Running())
                    .walking(new Walking())
                    .watching(new Watching())
                    .build().trainingUnit();
        }else{
            return TrainingBuilder
                    .builder()
                    .unit(new Medic())
                    .hiding(new Hiding())
                    .jumping(new Jumping())
                    .running(new Running())
                    .walking(new Walking())
                    .watching(new Watching())
                    .build().trainingUnit();
        }
    }
}

package pattern.sample.patternuse09.code;

public enum UnitType {
    MARINE,
    MEDIC,
    SCV
}

package pattern.sample.patternuse09.order.inf;

public interface Training&lt;ReturnR> {

    public ReturnR practice(ReturnR returnR);
}

package pattern.sample.patternuse09.order;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@RequiredArgsConstructor
public class Hiding implements Training&lt;Unit> {

    @Override
    public Unit practice(Unit unit) {

        unit.trainAbility(" 숨기 능력이 추가되었습니다.");

        return unit;
    }
}

package pattern.sample.patternuse09.order;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@RequiredArgsConstructor
public class Jumping implements Training&lt;Unit> {

    @Override
    public Unit practice(Unit unit) {
        unit.trainAbility(" 점프 능력이 추가되었습니다.");
        return unit;
    }
}

package pattern.sample.patternuse09.order;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@RequiredArgsConstructor
public class Running  implements Training&lt;Unit> {

    @Override
    public Unit practice(Unit unit) {
        unit.trainAbility(" 달리기 능력이 추가되었습니다.");
        return unit;
    }
}

package pattern.sample.patternuse09.order;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@RequiredArgsConstructor
public class Walking  implements Training&lt;Unit> {

    @Override
    public Unit practice(Unit unit) {
        unit.trainAbility(" 걷기 능력이 추가되었습니다.");
        return unit;
    }
}

package pattern.sample.patternuse09.order;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@RequiredArgsConstructor
public class Watching  implements Training&lt;Unit> {

    @Override
    public Unit practice(Unit unit) {
        unit.trainAbility(" 보기 능력이 추가되었습니다.");
        return unit;
    }
}

package pattern.sample.patternuse09.unit.inf;

public interface Unit {

    public void trainAbility(String ability);

    public String checkAbility();
}

package pattern.sample.patternuse09.unit;

import pattern.sample.patternuse09.unit.inf.Unit;

public class Marine implements Unit {

    private StringBuilder abilities = new StringBuilder();
    private final String unitName;

    public Marine(){
        unitName = "Marine";
    }

    public void trainAbility(String ability){
        abilities.append("능력 : " + ability + "\r\n");
    }

    public String checkAbility(){
        return abilities.toString();
    }

}

package pattern.sample.patternuse09.unit;

import pattern.sample.patternuse09.unit.inf.Unit;

public class Medic implements Unit {

    private StringBuilder abilities = new StringBuilder();
    private final String unitName;

    public Medic(){
        unitName = "Medic";
    }

    public void trainAbility(String ability){
        abilities.append("능력 : " + ability + "\r\n");
    }

    public String checkAbility(){
        return abilities.toString();
    }
}


                        
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Extract Composite
                    </h5>
                  </div>
                  <p class="mb-1">
                    한 상속 구조 내의 서브 클래스가 동일한 컴포짓 기능을 각자 구현하고 있다면, 컴포짓 기능을 수퍼 클래스로 옮겨 구현한다. 
                    <hr>
                    어떤 상속 구조 내의 서브 클래스들이 자신의 자식 객체를 컬렉션에 저장하고 그 자식 객체들의 기능에 접근하기 위한 메서드를 각자 구현하는 것은 자주 볼 수 있다. 
                    이때 만약 자식 객체의 타입이 부모 객체와 동일한 상속 구조 내의 타임이라면 , Composite패턴으로 리팩터링하여 많은 코드 중복을 제거할 수 있다. 
                    <ul>
                      <li>중복된 자식 객체 저장/처리 로직을 제거한다.</li>
                      <li>자식 객체 처리 로직을 상속 받아 그대로 사용할 수 있음이 명확히 드러난다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse10;

import pattern.sample.patternuse10.action.Act;
import pattern.sample.patternuse10.action.Hiding;
import pattern.sample.patternuse10.action.Running;
import pattern.sample.patternuse10.action.Walking;
import pattern.sample.patternuse10.action.composite.Action;
import pattern.sample.patternuse10.code.ActionType;
import pattern.sample.patternuse10.unit.Marine;
import pattern.sample.patternuse10.unit.inf.Unit;

public class BattleGround {
    public static void main(String[] args) {

        Action action = new Act();

        action.actionAdd(new Running());
        action.actionAdd(new Hiding());
        action.actionAdd(new Walking());

        Unit marine = new Marine(action);

        marine.act(ActionType.HIDING);
        marine.act(ActionType.HIDING);
        marine.act(ActionType.WALK);
        marine.act(ActionType.RUNNING);
    }
}

package pattern.sample.patternuse10.action.composite;

import pattern.sample.patternuse10.action.Hiding;
import pattern.sample.patternuse10.action.Running;
import pattern.sample.patternuse10.action.Walking;
import pattern.sample.patternuse10.code.ActionType;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

public abstract class Action {

    protected List&lt;Action> actionList = new ArrayList&lt;>();

    public void actionAdd(Action action){
        actionList.add(action);
    }

    public Action action(ActionType actionType){

        AtomicReference&lt;Action> action = new AtomicReference&lt;>();

        actionList.forEach(actionFromList -> {
            switch (actionType){
                case RUNNING:
                    if(actionFromList instanceof Running){
                        action.set(actionFromList);
                    }
                    return;
                case HIDING:
                    if(actionFromList instanceof Hiding) {
                        action.set(actionFromList);
                    }
                    return;
                case WALK:
                    if(actionFromList instanceof Walking ){
                        action.set(actionFromList);
                    }
                    return;
                }
        });

        return action.get();
    }

    public abstract void act();
}

package pattern.sample.patternuse10.action;

import pattern.sample.patternuse10.action.composite.Action;
import pattern.sample.patternuse10.code.ActionType;

import java.util.concurrent.atomic.AtomicReference;

public class Act extends Action {

    @Override
    public Action action(ActionType actionType){

        AtomicReference&lt;Action> action = new AtomicReference&lt;>();

        super.actionList.forEach(actionFromList -> {
            switch (actionType){
                case RUNNING:
                    if(actionFromList instanceof Running){
                        action.set(actionFromList);
                    }
                    return;
                case HIDING:
                    if(actionFromList instanceof Hiding) {
                        action.set(actionFromList);
                    }
                    return;
                case WALK:
                    if(actionFromList instanceof Walking ){
                        action.set(actionFromList);
                    }
                    return;
            }
        });

        return action.get();
    }

    @Override
    public void act() {

    }
}

package pattern.sample.patternuse10.action;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse10.action.composite.Action;

@Slf4j
public class Hiding extends Action {
    @Override
    public void act() {
        log.info("Hiding Action start!");
    }
}

package pattern.sample.patternuse10.action;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse10.action.composite.Action;

@Slf4j
public class Running  extends Action {
    @Override
    public void act() {
        log.info("Running Action start!");
    }
}

package pattern.sample.patternuse10.action;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse10.action.composite.Action;

@Slf4j
public class Walking  extends Action {
    @Override
    public void act() {
        log.info("Waling Action start!");
    }
}

package pattern.sample.patternuse10.code;

public enum ActionType {
    WALK,
    RUNNING,
    HIDING
}

package pattern.sample.patternuse10.unit.inf;

import pattern.sample.patternuse10.code.ActionType;

public interface Unit {

    public void act(ActionType actionType);
}

package pattern.sample.patternuse10.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse10.action.composite.Action;
import pattern.sample.patternuse10.code.ActionType;
import pattern.sample.patternuse10.unit.inf.Unit;

@RequiredArgsConstructor
public class Marine implements Unit {
    private final Action action;

    @Override
    public void act(ActionType actionType) {
        action.action(actionType).act();
    }
}                    
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace One/Many Distinctions with Composite
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 클래스에서 주어진 객체를 처리 할 때, 그 객체의 개수에 따라 서로 다른 로직을 사용하고 있다면, 컴포짓을 사용해 객체의 개수에 상관없이 한 로직으로 처리할 수 있도록 만든다. 
                    <hr>
                    어떤 클래스에 하나의 객체를 처리하는 메서드가 있는데, 로직이 이와 거의 비슷하면서 여러 객체를 처리하는 메서드가 있다면, 이는 한 객체와 여러 객체를 구별하고 있는 것이다. 이와 같은 경우에는 
                    코드가 중복되고, 클라이언트의 코드가 복잡해지고, 처리 결과를 취합하기 위해서 추가적인 처리가 필요해진다. `
                    <ul>
                      <li>객체가 하나일 때와 여러 개일 때를 처리하기 위해 각각 존재했던 중복된 처리 코드를 제거할 수 있다. </li>
                      <li>객체 하나를 처리하는 방법과 객체 여러 개를 처리하는 방법이 하나로 통일된다. </li>
                      <li>여러 개의 객체를 처리하기 위해 필요한 추가적인 기능을 부여할 수 있다. ( 예를 들어, OR 조건 표현 ) </li>
                      <li>컴포짓을 생성하는 동안 타입 안전성을 위해 런타임 타입 검사가 필요할 수 있다. </li>
                    </ul> 
                    <hr>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse11;

import pattern.sample.patternuse11.building.Barrack;
import pattern.sample.patternuse11.unit.Marine;
import pattern.sample.patternuse11.unit.Medic;

import java.util.Arrays;

public class BattleGround {
    public static void main(String[] args) {

        Barrack barrack = new Barrack();

        barrack.isTrainedUnit(new Marine());

        barrack.isTrainedUnit(Arrays.asList(new Marine(), new Medic()));
    }
}

package pattern.sample.patternuse11.building;

import pattern.sample.patternuse11.unit.UnitPackage;
import pattern.sample.patternuse11.unit.composit.Unit;

import java.util.List;

public class Barrack {

    public boolean isTrainedUnit(Unit unit){

        // isTrainedUnit에 대한 중복 로직을 해당 메소드에서 공통적으로 처리할 수 있다.

        return unit.checkUnitStatus();
    }

    public boolean isTrainedUnit(List&lt;Unit> unitList){
        return isTrainedUnit(new UnitPackage(unitList));
    }
}

package pattern.sample.patternuse11.unit.composit;
public abstract class Unit {

    public abstract boolean checkUnitStatus();
}

package pattern.sample.patternuse11.unit;

import pattern.sample.patternuse11.unit.composit.Unit;

public class Marine extends Unit {
    @Override
    public boolean checkUnitStatus() {
        return false;
    }
}

package pattern.sample.patternuse11.unit;

import pattern.sample.patternuse11.unit.composit.Unit;

public class Medic extends Unit {
    @Override
    public boolean checkUnitStatus() {
        return false;
    }
}

package pattern.sample.patternuse11.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse11.unit.composit.Unit;

import java.util.ArrayList;
import java.util.List;

@RequiredArgsConstructor
public class UnitPackage extends Unit {

    private final List&lt;Unit> unitList;
    private List&lt;Unit> filteredUnitList = new ArrayList&lt;>();

    public void add(Unit unit){
        unitList.add(unit);
    }

    public List&lt;Unit> getSpecs(){
        return filteredUnitList;
    }

    @Override
    public boolean checkUnitStatus() {
        return false;
    }
}                       
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Conditional Dispatcher with Command 
                    </h5>
                  </div>
                  <p class="mb-1">
                    요청에 대한 디스패처가 조건 로직으로 구현되어 있다면, 각 액션에 대한 커맨드 객체를 만들어 컬렉션에 저장해두고, 
                    조건 로직은 컬렉션에서 원하는 커맨드를 찾아 실행하는 코드로 대체한다. 
                    <hr>
                    많은 시스템에서 외부 요청을 받아 분배하고 실행하는 동작이 일어난다. 이때 요청을 분배하고 실행하는 조건문을 조건적 디스패처라 부른다. 어떤 경우에는 조건적 디스패처로 충분히 작업을 수행할 수 있지만, 그렇지 못한 경우도 있다. 
                    <ul>
                      <li>다양한 액션을 단일한 방식으로 실행하는 단순한 구조를 제공한다. </li>
                      <li>요청을 처리하는 로직의 구성을 런타임에 변경할 수 있다.</li>
                      <li>간단한 코드로 구현할 수 있다.</li>
                      <li>조건적 디스패처로도 충분한 상황에서는 괜히 설계만 복잡하게 만드는 것이다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse12;

import pattern.sample.patternuse12.building.Barrack;
import pattern.sample.patternuse12.code.UnitType;
import pattern.sample.patternuse12.unit.inf.Unit;

public class BattleGround {
    public static void main(String[] args) {
        Barrack barrack = new Barrack();

        Unit marineUnit = barrack.createUnit(UnitType.MARINE);
        Unit medicUnit = barrack.createUnit(UnitType.MEDIC);
    }
}

package pattern.sample.patternuse12.building;

import pattern.sample.patternuse12.code.UnitType;
import pattern.sample.patternuse12.unit.Marine;
import pattern.sample.patternuse12.unit.Medic;
import pattern.sample.patternuse12.unit.inf.Unit;

import java.util.HashMap;
import java.util.Map;

public class Barrack {

    private final Map&lt;UnitType, Unit> unitMap;

    public Barrack(){
        unitMap = new HashMap&lt;>();

        unitMap.put(UnitType.MARINE, new Marine());
        unitMap.put(UnitType.MEDIC, new Medic());
    }

    public Unit createUnit(UnitType unitType){
        return unitMap.get(unitType);
    }
}

package pattern.sample.patternuse12.code;

public enum UnitType {
    MARINE,
    MEDIC
}

package pattern.sample.patternuse12.unit.inf;

public interface Unit {
}

package pattern.sample.patternuse12.unit;

import pattern.sample.patternuse12.unit.inf.Unit;

public class Marine implements Unit {
}

package pattern.sample.patternuse12.unit;

import pattern.sample.patternuse12.unit.inf.Unit;

public class Medic implements Unit {
}
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Extract Adapter 
                    </h5>
                  </div>
                  <p class="mb-1">
                    하나의 클래스가 컴포넌트, 라이브러리, API 등의 여러 버전을 동시에 지원하기 위한 어댑터 역할을 하고 있다면, 각 버전을 위한 기능을 별도의 어댑터로 뽑아낸다. 
                    <hr>
                    <div class="card">
                      <div class="card-header">
                        Adapter 와 Facade
                      </div>
                      <div class="card-body">
                        <p class="card-text">
                          Adapter 패턴은 Facade 패턴과 자주 혼동된다. 두 패턴이 모두 어떤 코드를 더 쉽게 사용할 수 있도록 만든다는 공통점이 있지만 적용하는 수준이 다르다. Adapter 패턴은 객체 수준에서의 어댑팅을 수행하는 것이고, Facade 패턴은 어떤 
                          서브 시스템 전체를 어댑팅하는 것이다. Facade 패턴은 레거시 시스템과 통신하기 위해 사용하는 경우가 많다. 예를 들어, 어떤 기업에 COBOL 로 작성된 시스템이 있는데, 이 시스템의 코드가 매우 복잡 미묘하고 2백만 줄이나 된다고 하자. 이 시스템은 한번도 리팩토링 작업을 
                          거친 적이 없기 때문에 확장과 유지보수가 매우 어렵다. 그럼에도 불구하고 , 이 시스템에는 중욯나 기능이 포함되어 있기 때문에 새로 만드는 시스템도 이 레거시 시스템에 의존할 수 밖에 없다. 
                          이런 상황에서는 Facade패턴이 유용하다. 퍼사드는 새 시스템에 설계가 좋지 않고 복잡한 게러시 코드에 대한 좀더 단순한 뷰를 제공한다. 새 시스템은 퍼사드 객체와 통신하고 이 퍼사드 객체가 레거시 코드와 관련된 복잡한 작업을 대신하는 것이다. 
                          레거시 시스템의 서브시스템 하나씩을 퍼사드로 대체해 나가면서, 결국에는 레거시 시스템 전체를 안전하게 새로 구현할 수 있다. 
                          <ul>
                            <li>주어진 레거시 시스템의 서브시스템을 확인한다.</li>
                            <li>그 서브시스템을 위한 퍼사드를 구현한다.</li>
                            <li>앞서 만든 퍼사드를 사용하도록 클라이언트 코드를 수정한다.</li>
                            <li>레거시 시스템의 기능을 신기술로 다시 구현하고, 그를 어댑팅하는 새 퍼사드를 만든다. </li>
                            <li>기존의 퍼사드와 새 퍼사드가 동일하게 동작하는지 테스트한다.</li>
                            <li>새 퍼사드를 사용하도록 클라이언트 코드를 수정한다.</li>
                            <li>나머지 서브 시스템에 대해서 위의 과정을 반복한다. </li>
                          </ul>
                        </p>
                      </div>
                    </div>
                    <hr>
                    <ul>
                      <li>컴포넌트, 라이브러리 또는 API의 버전에 따른 차이점을 격리한다. </li>
                      <li>클래스가 하나의 버전만 책임지도록 한다.</li>
                      <li>자주 변하는 코드를 시스템과 분리할 수 있다. </li>
                      <li>원래 있던 중요 기능을 어댑터에서 제공하지 못하면, 클라이언트가 그런 중요 기능에 접근하는데 장벽이 될 수 있다. </li>
                    </ul>
                    <hr>
                    <pre>
                      <code>
Java의 첫 버전에서는 Enumeration이라는 인터페이스가 있어서 Vector나 HashTable 같은 컬렉션을 순회하는 데 사용되었다. 그런데 Java가 점점더 발전하면서
JDK에 더 나은 컬렉션 클래스들이 추가되었고 Iterater 인터페이스가 그 역할을 대신하게 되었다. 그러나 Enumeration 인터페이스를 사용해 작성된 코드와도 상호 동작이 가능해 하므로, 
JDK 에는 다음과 같이 익명 내부 클래스 기능을 이용해 Iterator를 어댑팅하는 생성 메서드를 제공한다. 

public class Collections ... 
    public static Enumeration enumeration(filnal Collection c){
        return new Enumeration() {
            Iterator i = c.iterator();

            public boolean hasMoreElements() {
              return i.hasNext();
            }

            public Object nextElement() {
              return i.next();
            }
        }
    }                        
}
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Unify Interfaces with Adapter
                    </h5>
                  </div>
                  <p class="mb-1">
                    클라이언트가 두 개의 유사한 클래스를 사용하고 있는데, 그중 한 인터페이스가 다른 하나보다 더 좋아 보이면, 어댑터를 도입해 인터페이스를 도입한다. 
                    <hr>
                    아래와 같은 상황 일 경우 Adapter 패턴으로 리팩터링하는 것이 좋다. 
                    <ul>
                      <li>두 클래스가 동일하거나 유사한 작업을 수행하지만 인터페이스가 서로 다른 경우, </li>
                      <li>두 클래스가 공통 인터페이스를 가지면, 클라이언트 코드가 더 간단하고 명료해질 수 있는 경우,</li>
                      <li>외부 라이브러리 라서 인터페이스를 바꾸고 싶어도 쉽게 바꿀 수 없는 경ㅇ, 또는 인터페이스가 프레임워크의 일부라거 이미 많은 클라이언트에서 사용되고 있는 경으, 또는 소스 코드를 갖고 있지 않는 경우, </li>
                    </ul>
                    <ul>
                      <li>클라이언트가 대체 클래스들을 하나의 인터페이스를 통해서 사용하도록 통합함으로써, 코드의 중복을 업애거나 줄인다. </li>
                      <li>클라이언트의 코드가 간단해진다. </li>
                      <li>클라이언트가 대체 클래스들을 사용하는 방식이 통합된다. </li>
                      <li>해당 클래스의 인터페이스를 직접 바꾸는 것이 가능한 상황에서 Adapter 패턴을 구현하면, 쓸데 없이 설계만 복잡해진다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse14;

import pattern.sample.patternuse14.v1.weapon.WeaponAdapter;
import pattern.sample.patternuse14.v1.weapon.inf.Weapon;
import pattern.sample.patternuse14.v2.weapon.SpeedGun;

public class Barrack {
    public static void main(String[] args)
    {
        Weapon weapon = new WeaponAdapter(new SpeedGun());

        weapon.checkStatus();
    }
}

package pattern.sample.patternuse14.v2.weapon;

public interface NewWeapon {
    public void checkStatus();
}


package pattern.sample.patternuse14.v2.weapon;

public class SpeedGun implements NewWeapon {
    @Override
    public void checkStatus() {

    }
}

package pattern.sample.patternuse14.v1.weapon.inf;

public interface Weapon {

    public void checkStatus();
}


package pattern.sample.patternuse14.v1.weapon;

import pattern.sample.patternuse14.v1.weapon.inf.Weapon;

public class Gun implements Weapon {
    @Override
    public void checkStatus() {

    }
}

package pattern.sample.patternuse14.v1.weapon;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse14.v1.weapon.inf.Weapon;
import pattern.sample.patternuse14.v2.weapon.NewWeapon;

@RequiredArgsConstructor
public class WeaponAdapter implements Weapon {

    private final NewWeapon newWeapon;

    @Override
    public void checkStatus() {
        newWeapon.checkStatus();
    }
}

                        
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Type Code wit Class
                    </h5>
                  </div>
                  <p class="mb-1">
                      어떤 필드 타입이 부적합한 값의 대입이나 유효하지 않은 동일성 검사(비교)를 방지하지 못한다면, 필드의 타입을 클래스로 바꿔 값의 대입과 동일성 검사에 제약 조건을 부여한다. 
                      <hr>
                      타입 코드를 클래스로 리팩터링하는 주된 이유는 코드의 타입 안정성을 보장하려는 것이다. 그러기 위한 한 가지 방법은 대입이나 동일성 검사에 사용될 수 있는 값을 제한하는 것이다. <br>
                      아래의 코드는 그 타입 안정성을 보장하지 않는 주된 예이다. 현재 해당 클래스는 String 값으로 값을 비교하고 세팅하는 구조이기 때문에 언제든지 오탈자의 문제나 문자열로 비교 및 값을 세팅하기 때문에 
                      타입에 대한 안정성을 보장하기 어렵게 된다. <br>
                      예를 들어 문자열을 실수로 잘못 입력해도 컴파일 에러는 발생하지 않는다. 
                      <pre>
                        <code class="java" >
public void testHelloWorld() {
  HelloWorld helloWorld = new HelloWrold();

  assertEquals(helloWorld.state(), "GOOD_WORLD");
}

// 아래의 HelloWorld에서 정의된 state와 HELLO_WORLD가 String 값이라고 할 때, 
// 해당 값이 타입 안정성을 지킬 수 있는 구조는 절대 아니다. 
public class HelloWorld {

  public String BYE_WORLD = "BYE_WORLD";
  public String HELLO_WORLD = "HELLO_WORLD";

  private String state = "";

  public HelloWorld () {
    state = HELLO_WORLD;
  }

  public String state(){
    return state;
  }
}
                        </code>
                      </pre>
                      <hr>
                      <ul>
                        <li>부적절할 값의 대입이나 유요하지 않은 동일성 검사로부터 코드를 보호한다. </li>
                        <li>타입 안정성이 결여된 경우보다 더 많은 코드가 필요하다. </li>
                      </ul>
                      <hr>
                      <pre>
                        <code class="java" >
public class PermissionState {
  public final static PermissionState REQUESTED = new PermissionState();
  public final static PermissionState CLAIMED = new PermissionState();
  public final static PermissionState GRANTED = new PermissionState();
  public final static PermissionState DENIED = new PermissionState();
}
                        </code>
                      </pre>
                      <Strong>Sample Code</Strong>
                      <pre>
                        <code class="java" >
package pattern.sample.patternuse15;

import pattern.sample.patternuse15.unit.impl.Marine;
import pattern.sample.patternuse15.unit.impl.Medic;
import pattern.sample.patternuse15.unit.inf.Unit;
import pattern.sample.patternuse15.unit.state.UnitState;

public class BattleGround {
    public static void main(String[] args) {
        Unit marine = new Marine(UnitState.NORMAL);
        Unit medic = new Medic(UnitState.HURT);

        marine.checkStatus();
        medic.checkStatus();

    }
}

package pattern.sample.patternuse15.unit.state;

public class UnitState {
    private final String name;

    private UnitState(String name){
        this.name = name;
    }

    public String toString(){
        return name;
    }

    public final static UnitState NORMAL = new UnitState("NORMAL");
    public final static UnitState HURT = new UnitState("HURT");
    public final static UnitState DEAD = new UnitState("DEAD");
}

package pattern.sample.patternuse15.unit.inf;

public interface Unit {
    public void checkStatus();
}

package pattern.sample.patternuse15.unit.impl;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse15.unit.inf.Unit;
import pattern.sample.patternuse15.unit.state.UnitState;

@RequiredArgsConstructor
@Slf4j
public class Marine implements Unit {

    private final UnitState unitState;

    @Override
    public void checkStatus() {
        log.info(unitState.toString());
    }
}

package pattern.sample.patternuse15.unit.impl;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse15.unit.inf.Unit;
import pattern.sample.patternuse15.unit.state.UnitState;

@RequiredArgsConstructor
@Slf4j
public class Medic implements Unit {

    private final UnitState unitState;

    @Override
    public void checkStatus() {
        log.info(unitState.toString());
    }
}    
                        </code>
                      </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace State-Altering Conditional with State
                    </h5>
                  </div>
                  <p class="mb-1">
                      어떤 객체의 상태 전이를 제어하는 조건 로직이 복잡하다면, 각 상태에 해당하는 스테이트 클래스를 하나씩 만들고 그들이 스스로 다른 상태로 전이하는 것을 책임지도록하는 복잡한 조건 로직을 제거한다. 
                      <hr>
                      State 패턴으로 리팩터링하는 주된 목적은 상태 전이를 위한 조건 로직이 지나치게 복잡한 경우 이를 해소하는 것이다. 상태 전이 로직이란 객체의 상태와 이들 같의 전이 방법을 제어하는 것으로 , 
                      클래스 내부 여기 저기에 흩어져 존재하는 경향이 있다. State 패턴을 구현한다는 것은 각 상태에 대응하는 별도의 클래스를 만들고 상태 전이 로직을 그 클래스들로 옮기는 작업을 뜻한다. 
                      <hr>
                      State 패턴은 이떤 객체가 여러 상태 간의 전이를 쉽게 하는 데 유용한 반면, Strategy 패턴은 대리 객체를 런타임에 바꿀 수 있게 하여 상황에 맞는 로직 선택을 쉽게 하는 데 유용하다. 
                      <ul>
                        <li>상태 전이를 위한 조건 로직을 줄이거나 제거할 수 있다. </li>
                        <li>복잡한 상태 전이 로직이 단순해진다. </li>
                        <li>상태 전이 로직을 더 쉽게 알아볼 수 있다. </li>
                        <li>원래의 상태 전이 로직이 별로 복잡하지 않다면, 괜히 설계만 복잡하게 만드는 것이다. </li>
                      </ul>
                      <pre>
                        <code class="java" >
package pattern.sample.patternuse16;

import pattern.sample.patternuse16.unit.Marine;
import pattern.sample.patternuse16.unit.code.ActionType;

public class BattleGround {
    public static void main(String[] args) {
        Marine marine = new Marine();

        marine.actionByMouse(ActionType.MOVING);

        marine.actionByMouse(ActionType.ATTACK);

        marine.actionByMouse(ActionType.MOVING);

        marine.actionByMouse(ActionType.HEALING);
    }
}

package pattern.sample.patternuse16.unit;

import pattern.sample.patternuse16.unit.action.Action;
import pattern.sample.patternuse16.unit.code.ActionType;
import pattern.sample.patternuse16.unit.state.structure.UnitState;

public class Marine {

    public void actionByMouse(ActionType actionType){

        Action action = UnitState
                .byState(actionType)
                .byAction();

        action.act();
    }
}

package pattern.sample.patternuse16.unit.state.structure;

import pattern.sample.patternuse16.unit.action.Action;
import pattern.sample.patternuse16.unit.code.ActionType;
import pattern.sample.patternuse16.unit.state.AttackState;
import pattern.sample.patternuse16.unit.state.HealingState;
import pattern.sample.patternuse16.unit.state.MovingState;

public abstract class UnitState {

    public final static UnitState MOVING = new MovingState();
    public final static UnitState ATTACK = new AttackState();
    public final static UnitState HEALING = new HealingState();

    public static UnitState byState(ActionType actionType){
        switch (actionType){
            case ATTACK:
                return ATTACK;
            case MOVING:
                return MOVING;
            case HEALING:
                return HEALING;
            default:
                return null;
        }
    }

    public abstract Action byAction();
}

package pattern.sample.patternuse16.unit.state;


import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse16.unit.action.Action;
import pattern.sample.patternuse16.unit.action.impl.Attack;
import pattern.sample.patternuse16.unit.code.ActionType;
import pattern.sample.patternuse16.unit.state.structure.UnitState;

@Slf4j
public class AttackState extends UnitState {

    @Override
    public Action byAction() {
        return new Attack();
    }
}

package pattern.sample.patternuse16.unit.state;


import pattern.sample.patternuse16.unit.action.Action;
import pattern.sample.patternuse16.unit.action.impl.Healing;
import pattern.sample.patternuse16.unit.code.ActionType;
import pattern.sample.patternuse16.unit.state.structure.UnitState;

public class HealingState extends UnitState {
    @Override
    public Action byAction() {
        return new Healing();
    }
}

package pattern.sample.patternuse16.unit.state;


import pattern.sample.patternuse16.unit.action.Action;
import pattern.sample.patternuse16.unit.action.impl.Moving;
import pattern.sample.patternuse16.unit.state.structure.UnitState;

public class MovingState extends UnitState {
    @Override
    public Action byAction() {
        return new Moving();
    }
}

package pattern.sample.patternuse16.unit.code;

public enum ActionType {
    MOVING,
    ATTACK,
    HEALING
}

package pattern.sample.patternuse16.unit.action;

public interface Action {
    public void act();
}

package pattern.sample.patternuse16.unit.action.impl;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse16.unit.action.Action;

@Slf4j
public class Attack implements Action {
    @Override
    public void act() {
        log.info("Attack 합니다. ");
    }
}

package pattern.sample.patternuse16.unit.action.impl;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse16.unit.action.Action;

@Slf4j
public class Healing implements Action {
    @Override
    public void act() {
        log.info("치료합니다. ");
    }
}


package pattern.sample.patternuse16.unit.action.impl;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse16.unit.action.Action;

@Slf4j
public class Moving implements Action {
    @Override
    public void act() {
        log.info("움직입니다. ");
    }
}
                        </code>
                      </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Introduce Null Object
                    </h5>
                  </div>
                  <p class="mb-1">
                      어떤 필드나 변수의 값이 널인지 검사하는 로직이 코드의 여기 저기 중복되어 있다면, 값이 널인 경우에 행할 작업을 대신하는 널 객체를 사용하도록 수정한다. 
                      <hr>
                      <pre>
                        <code class="java" >
if ( someObject != null ){
  someObject.doSomething();
} else {
  performAlternativeBehavior();
}
                        </code>
                      </pre>
                      위와 같은 널 검사 로직이 시스템의 한두 곳에서 반복되는 것은 별도 문제되지 않는다. 그러나 여러 곳에서 반복된다면 얘기가 다른다. 널 검사 로직이 없는 코드와 비교했을 때, 그런 코드는 이해하기가 더 어렵고
                      확장을 하려먼 더 많은 생각을 해야한다. 또 기존의 널 검사 로직으로는 새로 추가한 코드를 보호할 수가 없다. 따라서 새로운 코드를 작성할 때 프로그래머가 널 검사 로직을 빠뜨린다면,
                      널 관련 오류가 발생하기 시작한다. 
                      <hr> 
                      Null Object 패턴은 이런 문제를 위한 해결책으로, 필드나 변수가 항상 설이 아니도록 유지하여 별도의 검사를 하지 않아도 된다. 이 방법은 사실 약간의 속임수다. 평소에는 필드나 변수에 적당한 객체를 대입하고, 
                      널 일 경우에는 널 객체를 대입하는 것이다. 이 때 널 객체의 해당 메서드는 아무일도 하지 않거나 디폴드 대입하는 것이다. 
                      <ul>
                        <li>수많은 널 검사 로직 없이도 널 값으로 인한 에러를 막을 수 있다.</li>
                        <li>널 검사 로직이 최소화되어 코드가 간단해진다. </li>
                        <li>시스템에 널 검사 로직이 별도 필요하지 않은 상황에서는 설꼐만 복잡하게 된다. </li>
                        <li>프로그래머가 널 객체의 존재를 모르고 있다면 , 동일한 널 검사를 쓸데 없이 여러번 하게 될 수 도 있다. </li>
                        <li>유지보수가 복잡해진다. 널 객체의 수퍼클래스에 새 public 메서드를 추가할 때 마다 널 객체 클래스에서 이를 오버라이드 해야 한다. </li>
                      </ul>
                      <pre>
                        <code class="java" >
package pattern.sample.patternuse17;

import pattern.sample.patternuse17.unit.Marine;
import pattern.sample.patternuse17.unit.action.impl.Move;
import pattern.sample.patternuse17.unit.action.impl.NullAction;

public class BattleGround {
    public static void main(String[] args) {
        Marine marine = new Marine();

        marine.setAction(new Move());

        marine.act();

        marine.setAction(new NullAction());

        marine.act();
    }
}

package pattern.sample.patternuse17.unit;

import pattern.sample.patternuse17.unit.action.Action;

import java.util.Optional;

public class Marine {

    public Action action;

    public void setAction(Action action){
        this.action = action;
    }

    public void act(){
        Optional.ofNullable(this.action)
                .ifPresent(action -> {
                    action.act();
                });
    }
}

package pattern.sample.patternuse17.unit.action;

public interface Action {
    public void act();
}

package pattern.sample.patternuse17.unit.action.impl;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse17.unit.action.Action;

@Slf4j
public class Move implements Action {
    @Override
    public void act() {
        log.info("Move!!");
    }
}

package pattern.sample.patternuse17.unit.action.impl;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse17.unit.action.Action;

@Slf4j
public class NullAction implements Action {
    @Override
    public void act() {
        log.info("Null Action");
    }
}

package pattern.sample.patternuse17.unit.action.impl;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse17.unit.action.Action;

@Slf4j
public class Run implements Action {
    @Override
    public void act() {
        log.info("Run!");
    }
}                          
                        </code>
                      </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Inline Singleton
                    </h5>
                  </div>
                  <p class="mb-1">
                    코드의 여러곳에서 접근할 수 있어야 하지만 전역적일 필요 까지는 없는 객체가 싱글턴으로 구현되어 있다면, 싱글턴 객체를 저장하고 그에 대한 접근 경로를 제공하는 클래스로 싱글턴의 기능을 옮긴다. 그리고 싱글턴은 제거한다. 
                    <hr>
                    Singleton 패턴에 집착하는 사람들을 가리켜 싱글턴 중독자라고 한다. 물론 내가 지어낸 말이다. Singleton 패턴의 의도는 '어떤 클래스의 단 하나만 허용하고, 그에 대한 전역적인 접근을 가능하게 하려는 것이다. ' Singleton 패턴에 대한 생각이 
                    뼈속 깊이 침투해 있어 다른 패턴 또는 더 단순한 설계보다 싱글턴이 좋다고 믿기 시작해 지나치게 많은 싱글턴을 만들고 있다면, 싱글턴에 중독된 것이다. 
                    <hr>
                    Singleton 패턴에 대한 Ward Cunningham의 견해  <br>
                    실제로 구현되는 싱클턴의 대부분은 프로그래밍 언어가 제공하는 여러 보호 기능을 '유일성'이라는 하나의 측면으로 몰아가는 것이다. 물론 개인적으로는 유일성을 보장하는 것이 중요할 수도 있다고 생각하지만, 너무 지나치게 강조되는 면이 있다. 
                    모든 데이터는 적당한 컨텍스트에서 사용되어야 한다. 많은 객체지향 프로그래밍 기법이 컨텍스트를 설정하고 그에 따라 변수의 생존 기간을 적절하게 조절해 필요한 동안만 존재하다가 우아하게 소멸될 수 있도록 하는 것이다. 전역 데이터가 몇 개 정도 존재하는 것은
                    별 문제가 되지 않는다. 시스템의 모든 곳에서 이해할 수 있는 컨텍스트에서 사용되는 데이터라면 말이다. 그러나 너무 많은 전역데이터가 존재해서는 안된다. 그런 시스템을 나더러 수정하라고 하면, 나는 줄행랑을 칠 것이다. 
                    <hr>
                    Singleton 패턴에 대한 Kent Beck의 견해 <br>
                    싱글턴이 야기하는 진짜 문제는 어떤 객체의 가시 범위를 어떻게 정할지를 크게 고민하지 않아도 되게 만든다는 점이다. 객체의 노출 영역과 보호 영역에 대한 균형을 적절하게 맞추는 것은 융통성을 유지하기 위한 필수 조건이다. 
                    Massimo Arnoldi 와 싱글턴에 환전율을 저장하는 어떤 시스템을 개발하던 때였다. 여러 통화를 한꺼번에 다루는 테스트 코드를 작성할 때 마다, 기존의 환전율을 따로 저장했다가 새 환전율을 입력하고 다시 기존의 환전율을 복원하는 과정을 반복해야 했다. 따라서 
                    실수로 잘못된 환전율을 테스트에 사용하는 일이 계속 발생했고, 우리는 그런 상황을 더는 견딜 수 없었다. 그러나 그 환전율은 시스템 전체에서 사용하는 데이터 였으므로 , 그것을 처리하는 방법을 바꾸는 작업은 보통 일이 아닐거라 생각했다. 그래도 한번 시도해보기로 마음 먹고, 
                    환전율을 사용하는 코드를 모두 찾아 필요한 환전율을 파라미터를 통해 명시적으로 넘겨줬다. 처음에는 매우 많은 곳을 고쳐야할 것라고 생각했지만, 막상 해보니 30분 밖에 걸리지 않았다. 때로는 필요한 환전율을 접근하기 어려운 위치에 코드도 있었지만, 그것을 어떻기 리팬터링해야할지는 자명했다. 
                    그리고 그렇게 리팩터링한 결과로, 어떻게 해결할지를 몰라 난감했던 몇몇 설계문제도 함께 해결되었다. 
                    <br>
                    <ul>
                      <li>전체 설꼐가 더 명확하고 유연해졌다.</li>
                      <li>안정적인 테스트 코드 작성이 가능해졌다. </li>
                      <li>시스템에 대한 신뢰도가 높아졌다. </li>
                    </ul>
                    <hr>
                    <ul>
                      <li>객체 간의 협력 관곌ㄹ 좀더 명확하게 만든다.</li>
                      <li>싱글턴 객체를 보호하기 위한 특수 코드가 필요 없어진다. </li>
                      <li>객체의 참조를 호출 트리의 여러 계층에서 넘겨야 해서 불편하고 힘들어졌다면, 설계를 더 복잡하게 만든 것이다. </li>
                    </ul>
                    <hr>
                    <strong>싱글턴 뽀개기</strong>
                    <ul>
                      <li>
                        싱글턴이 구현하고 있는 public 메서드를 흡수클래스에 선언한다. 그리기고 이 새 메서드의 구현은 기존의 싱글턴에 위임하도록 한다. 이 때 그 메서드 중에 static에 메서드가 있다면, 흡수 클래스에 그에 대응하는 메서드를 선언할 때 
                        static 키워드를 제거한다. 만약 기존 싱글턴 클래스를 그대로 흡수 클래스로 삼을 생각이라면, static 메서드를 그대로 놔두어도 무방하다. 
                      </li>
                      <li>
                        클라이언트 코드에서 싱글턴을 참조하는 부분을 모두 흡수 클래스를 참조하도록 수정한다. 
                      </li>
                      <li>
                        싱글턴에 아무 기등도 남아있지 않도록, Move Method와 Move Field 리팩터링을 통해 싱글 턴의 모든 기능을 흡수 클래스로 옮긴다. 
                      </li>
                      <li>
                        싱글턴을 제거한다. 
                      </li>
                    </ul>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Limit Instantiation with Singleton
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 클래스의 인스턴스를 여러 개 생성해 사용하고 있는데, 그로 인해 메모리 사용량이 너무 커지거나 시스템 성능이 저하된다면, 여러개의 객체를 하나의 싱글턴 객체로 대체한다. 
                    <hr>
                    훌륭한 소프트웨어 설계자가 되고 싶다면, 코드를 조금하게 최적화하는 것을 피해야 한다. 조금하게 최적화를 시도한 코드는 그렇지 않는 코드보다 리팩터링하기 어렵다. 
                    만약 여러분이 '코드를 더 효율적으로 만들어준다'는 이유로 Singleton 패턴을 습관적으로 사용하고 있다면, 이는 조급하게 코드를 최적화하고 있는 것이다. 반면에 아래와 같은 상황의 경우라면 
                    Singleton패턴으로 리팩터링 하는 것이 적합하다. 
                    <ul>
                      <li>시스템 성능에 대한 사용자의 불만이 높다. </li>
                      <li>프로파일러를 통해 확인한 결과, 어떤 객체를 계속 반복해서 생성하는 것이 시스템 성능에 악영향을 미치고 있다. </li>
                      <li>공유하려는 객체가 상태를 갖지 않거나, 갖더라도 상태를 공유할 수 있다. </li>
                    </ul>
                    <ul>
                      <li>성능을 향상시킨다. </li>
                      <li>어느 곳에서나 객체에 접근할 수 있게 된다. 많은 경우, 이는 좋지 않는 설계로 평가된다. </li>
                      <li>객체를 공유하면 안되는 상태가 존재할 때에는 적용할 수 없다. </li>
                    </ul>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Hard-Coded Notifications with Observer
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 상속 구조 내의 서브클래스들이 자신과 관련된 클래스에 통보하는 기능을 하드 코딩으로 각자 구현하고 있다면, 
                    Observer 인터페이스를 통해 그 수퍼 클래스가 임의의 다른 클래스에 통보할 수 있도록 일반적인 통보 기능을 만들고 서브 클래스는 제거한다. 
                    <hr>
                    <ul>
                      <li>통보 주체 클래스와 관찰자 클래스 사이의 결합을 느슨하게 하간다. </li>
                      <li>관찰자가 여럿인 경우도 지원한다.</li>
                      <li>하드 코딩으로 구현된 통보 기능으로도 충분한 상황에서 적용한다면 설계만 복작해진다.</li>
                      <li>통보 체인이 불가피한 상황에서는 설계가 더 복잡해진다. </li>
                      <li>관찰자 객체에 대한 참조를 제때 삭제하지 않으면 메모리 누수가 발생한다. </li>
                    </ul>
                    <pre>
                      <code class="java" > 
package pattern.sample.patternuse19.action;

import lombok.extern.slf4j.Slf4j;

@Slf4j
public class Move implements Action {
    @Override
    public void act() {
        log.info("Moving");
    }
}

package pattern.sample.patternuse19.action;

public interface Action {
    public void act();
}

package pattern.sample.patternuse19.mouse;

import pattern.sample.patternuse19.action.Action;

import java.util.ArrayList;
import java.util.List;

public class Mouse {

    private final List&lt;Action> actionList = new ArrayList&lt;>();

    public void addAction(Action action){
        actionList.add(action);
    }

    public void notifyForAction(){
        actionList.forEach(Action::act);
    }
}

                        
package pattern.sample.patternuse19;

import pattern.sample.patternuse19.action.Move;
import pattern.sample.patternuse19.mouse.Mouse;

public class BattleGround {
    public static void main(String[] args) {
        Mouse mouse = new Mouse();

        mouse.addAction(new Move());
        mouse.addAction(new Move());
        mouse.addAction(new Move());
        mouse.addAction(new Move());

        mouse.notifyForAction();
    }
}
                        
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Move Embellishment to Decorator
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 클래스에서 핵심 기능을 위한 코드와 꾸밈 코드가 뒤섞여 있으면, 꾸밈 코드를 데코레이터로 옮긴다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Unify Interfaces
                    </h5>
                  </div>
                  <p class="mb-1">
                    수퍼클래스(또는 인터페이스)가 서브 클래스와 동일한 인터페이스를 가질 필요가 있다면, 
                    서브 클래스에서 수퍼클래스에 없는 모든 public 메서드를 찾아 이를 수퍼 클래스에 추가한다. 이때 메서드 몸체는 비워놓아 아무 일도 하지 않도록 만든다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Extract Parameter
                    </h5>
                  </div>
                  <p class="mb-1">
                    메서드나 생성자 내에서 생성한 값을 필드에 저장하고 있다면,
                    대입문의 우변을 새 파라미터로 대체해 클라이언트가 그 값을 저장할 수 있도록 한다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Move Creation Knowlege to Factory
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 클래스에 인스턴스를 생성하는데 사용되는 데이터와 코드가 여러 클래스에 퍼져있다면 , 
                    그 생성  지식을 하나의 팩터리 클래스로 옮긴다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Move Accumulation to Visitor 
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 메서드가 이질적인 여러 클래스들로 부터 정보를 언더 축적하고 있다면,
                    각 클래스를 방문해 정보를 축적하는 방문자 객체로 축적 기능을 옮긴다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Implicit Language with Interpreter
                    </h5>
                  </div>
                  <p class="mb-1">
                    한 클래스 내의 여러 메서드에서 일종의 묵시적 언어를 이루는 요소들을 조합하고 있다면, 
                    그 묵시적 언어의 요소들을 각각의 클래스로 정의하고 그 객체의 조합을 해석 가능한 수식을 만들어 낼 수 있도록 한다. 
                  </p>
                </a>
              </div>
            </div>
        </div>
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
   
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
 
    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Page level plugin JavaScript-->
    <script src="../vendor/chart.js/Chart.min.js"></script>

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>

    <!-- Demo scripts for this page-->
    <script src="../js/demo/chart-area-demo.js"></script>
    <script src="../js/demo/chart-bar-demo.js"></script>
    <script src="../js/demo/chart-pie-demo.js"></script>

  </body>

</html>
