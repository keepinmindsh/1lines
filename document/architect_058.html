<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines - 패턴을 활용한 리팩터링</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1 Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">도서 정리</h6>
            <a class="dropdown-item" href="../document/architect_057.html">The Object</a>
            <a class="dropdown-item" href="../document/architect_058.html">패턴을 활용한 리팩터링</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>
            <li class="breadcrumb-item active"></li>
          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
              패턴을 활용한 리팩터링
            </div>
            <div class="card-body">
              <div class="list-group">
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                     &lt; 설계를 위한 예제 >
                    </h5>
                  </div>
                  <p class="mb-1">
                    스타크래프트를 이용한 예제 
                    <br>
                    테란의 커맨드 센터에서 SCV을 통해서 미네랄을 캐고, 가스를 캐어 배럭을 건설한다. 
                    건설된 배럭에서 마린, 메딕을 생산하여 저그를 공격해가는 과정을 정의한다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Constructors with Creation Methods
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 클래스의 인스턴스를 생성할 때 그것이 제공하는 여러 생성자 중 어떤 것을 호출해야 할 지 결정하기가 어렵다면, 
                    인스턴스를 생성해 리턴하는 생성 메서드로 각 생성자를 내체하여 그 용도가 명확히 드러나도록 한다. 
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse01;

import pattern.sample.patternuse01.building.Barrack;
import pattern.sample.patternuse01.code.UnitType;
import pattern.sample.patternuse01.unit.inf.Unit;

public class BattleGround {

    public static void main(String[] args) {

        Unit marine = Barrack.createUnit(UnitType.MARINE);

        marine.checkStatus();

        Unit medic = Barrack.createUnit(UnitType.MEDIC);

        medic.checkStatus();

    }
}

package pattern.sample.patternuse01.building;

import pattern.sample.patternuse01.code.UnitType;
import pattern.sample.patternuse01.unit.Empty;
import pattern.sample.patternuse01.unit.Marine;
import pattern.sample.patternuse01.unit.Medic;
import pattern.sample.patternuse01.unit.inf.Unit;

public class Barrack {

    public static Unit createUnit(UnitType unitType){
        switch (unitType){
            case MEDIC:
                return new Medic();
            case MARINE:
                return new Marine();
            default:
                return new Empty();
        }

    }
}

package pattern.sample.patternuse01.unit.status;

import lombok.Builder;
import lombok.Getter;

@Builder
@Getter
public class UnitStatus {
    private final int health;
}


package pattern.sample.patternuse01.code;

public enum UnitType {
    MARINE,
    MEDIC
}

package pattern.sample.patternuse01.unit.inf;

public interface Unit {

    public void checkStatus();
}

package pattern.sample.patternuse01.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse01.unit.inf.Unit;

@Slf4j
public class Empty implements Unit {

    @Override
    public void checkStatus() {
        log.info("Empty, do nothing!");
    }
}

package pattern.sample.patternuse01.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse01.unit.inf.Unit;
import pattern.sample.patternuse01.unit.status.UnitStatus;

@Slf4j
public class Marine implements Unit {

    private final UnitStatus unitStatus;

    public Marine(){
        unitStatus = UnitStatus.builder().health(70).build();
    }

    @Override
    public void checkStatus() {
        log.info("Marine Health : {}", unitStatus.getHealth());
    }
}

package pattern.sample.patternuse01.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse01.unit.inf.Unit;
import pattern.sample.patternuse01.unit.status.UnitStatus;

@Slf4j
public class Medic implements Unit {
    private final UnitStatus unitStatus;

    public Medic(){
        unitStatus = UnitStatus.builder().health(50).build();
    }

    @Override
    public void checkStatus(){
        log.info("Medic Health : {}", unitStatus.getHealth());
    }
}


                        
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Chain Constructors
                    </h5>
                  </div>
                  <p class="mb-1">
                    중복된 코드를 갖는 생성자가 여러 개 있다면, 중복을 최소화하기 위해 생성자들이 서로 호출하게 한다.
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse02;

import pattern.sample.patternuse02.building.inf.Constructor;
import pattern.sample.patternuse02.code.BuildType;
import pattern.sample.patternuse02.unit.creator.SCV;

public class BattleGround {
    public static void main(String[] args) {

        Constructor barrack1 = SCV.createBuilding(BuildType.BARRACK, 150, 0);

        Constructor factory1 = SCV.createBuilding(BuildType.FACTORY, 150, 150);

        barrack1.createBuilding();
        factory1.createBuilding();
    }
}

package pattern.sample.patternuse02.code;

public enum BuildType {
    BARRACK,
    FACTORY
}
                        
package pattern.sample.patternuse02.unit.creator;

import pattern.sample.patternuse02.building.Barrack;
import pattern.sample.patternuse02.building.constructor.BuildingConstructor;
import pattern.sample.patternuse02.building.Factory;
import pattern.sample.patternuse02.code.BuildType;

public class SCV {
    public static BuildingConstructor createBuilding(BuildType buildType, int mineral, int gas){
        switch (buildType){
            case BARRACK:
                return new BuildingConstructor(mineral, gas, new Barrack());
            case FACTORY:
                return new BuildingConstructor(mineral, gas, new Factory());
            default:
                return null;
        }
    }
}

package pattern.sample.patternuse02.building.constructor;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse02.building.inf.Building;
import pattern.sample.patternuse02.building.inf.Constructor;

@RequiredArgsConstructor
public class BuildingConstructor implements Constructor {

    private final int mineral;
    private final int gas;
    private final Building building;

    public Building createBuilding(){
        return building;
    }
}

package pattern.sample.patternuse02.building;

import pattern.sample.patternuse02.ability.Heal;
import pattern.sample.patternuse02.ability.Shot;
import pattern.sample.patternuse02.building.inf.Building;
import pattern.sample.patternuse02.code.UnitType;
import pattern.sample.patternuse02.unit.Marine;
import pattern.sample.patternuse02.unit.Medic;
import pattern.sample.patternuse02.unit.NotUnit;
import pattern.sample.patternuse02.unit.inf.Unit;

public class Barrack implements Building {

    public Unit makeUnit(UnitType unitType){

        switch (unitType){
            case MARINE:
                return new Marine(new Shot());
            case MEDIC:
                return new Medic(new Heal());
            default:
                return new NotUnit();
        }
    }
}

package pattern.sample.patternuse02.building;

import pattern.sample.patternuse02.building.inf.Building;
import pattern.sample.patternuse02.code.UnitType;
import pattern.sample.patternuse02.unit.inf.Unit;

public class Factory implements Building {
    @Override
    public Unit makeUnit(UnitType unitType) {
        return null;
    }
}

                        
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Encapsulate Classes with Factory 
                    </h5>
                  </div>
                  <p class="mb-1">
                    클라이언트가 한 패키지 내의, 공통 인터페이스를 가지는 클래스들의 인스턴스를 직접 생성하고 있다면, 
                    그 클래스의 생성자를 클라이언트가 직접 볼 수 없게 바꾸고 클라이언트는 팩터리 를 통해 그 인스턴스를 얻도록 한다. 
                    <hr>
                    <ul>
                      <li>용도를 쉽게 알아볼 수 있는 생성 메서드를 제공하여, 클라이언트가 원하는 종류의 객체르리 쉽게 생성할 수 있도록 한다. </li>
                      <li>공개될 필요가 없는 클래스들을 숨겨 패키지의 '개념적 무게'를 줄인다. </li>
                      <li>클라이언트가 '구현에 대해서가 아니라, 인터페이스에 대해 프로그래밍' 하게 된다. </li>
                      <li>새로운 종류의 객체가 필요할 경우에는 생성 메서드를 추갛거나 수정해야 한다. </li>
                      <li>팩터리의 소스 코드가 아닌 바이너리만 배포할 경우에는 클라이언트가 쉽게 수정할 수 없게 된다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse03;

import pattern.sample.patternuse03.building.Barrack;
import pattern.sample.patternuse03.operation.Armed;

public class BattleGround {
    public static void main(String[] args) {
        Armed armedMarine = Barrack.forMarine();

        Armed armedMedic = Barrack.forMedic();
    }
}

package pattern.sample.patternuse03.building;

import pattern.sample.patternuse03.equipment.AttackingGloves;
import pattern.sample.patternuse03.equipment.CMCArmor;
import pattern.sample.patternuse03.equipment.HealGloves;
import pattern.sample.patternuse03.equipment.MedicArmor;
import pattern.sample.patternuse03.operation.Armed;
import pattern.sample.patternuse03.unit.Marine;
import pattern.sample.patternuse03.unit.Medic;

public class Barrack {

    public static Armed forMarine(){
        return new Armed(new Marine(new CMCArmor(), new AttackingGloves()));
    }

    public static Armed forMedic(){
        return new Armed(new Medic(new MedicArmor(), new HealGloves()));
    }
}

package pattern.sample.patternuse03.operation;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse03.unit.inf.Unit;

@RequiredArgsConstructor
public class Armed {

    private final Unit unit;
}


package pattern.sample.patternuse03.equipment.inf;

public interface Armor {
}

package pattern.sample.patternuse03.equipment;

import pattern.sample.patternuse03.equipment.inf.Armor;

public class CMCArmor implements Armor {
}

package pattern.sample.patternuse03.equipment;

import pattern.sample.patternuse03.equipment.inf.Armor;

public class MedicArmor implements Armor {
}

package pattern.sample.patternuse03.equipment.inf;

public interface Gloves {
}

package pattern.sample.patternuse03.equipment;

import pattern.sample.patternuse03.equipment.inf.Gloves;

public class AttackingGloves implements Gloves {
}

package pattern.sample.patternuse03.equipment;

import pattern.sample.patternuse03.equipment.inf.Gloves;

public class HealGloves implements Gloves {
}

package pattern.sample.patternuse03.unit.inf;

public interface Unit {
}

package pattern.sample.patternuse03.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse03.equipment.inf.Armor;
import pattern.sample.patternuse03.equipment.inf.Gloves;
import pattern.sample.patternuse03.unit.inf.Unit;

@RequiredArgsConstructor
public class Marine implements Unit {
    private final Armor armor;
    private final Gloves gloves;
}

package pattern.sample.patternuse03.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse03.equipment.inf.Armor;
import pattern.sample.patternuse03.equipment.inf.Gloves;
import pattern.sample.patternuse03.unit.inf.Unit;

@RequiredArgsConstructor
public class Medic implements Unit {
    private final Armor armor;
    private final Gloves gloves;
}
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Introduce Polymorphic Creation with Factory Method
                    </h5>
                  </div>
                  <p class="mb-1">
                    한 상속 구조 내의 클래스들이 어떤 메서드를 각자 구현하는데 객체 생성 단계만 제외하고 나머지가 서로 유사하다면, 
                    그 메서드를 수퍼 클래스로 옮기고 객체 생성은 팩터리 메서드에 맡기도록 한다. 
                    <hr>
                    <ul>
                      <li>객체를 생성하는 과정에서의 코드 중복을 줄인다.</li>
                      <li>객체를 생성하는 곳이 실제로는 어디고, 또 어떻게 오버라이드 하면 되는지 잘 드러난다. </li>
                      <li>팩터리 메서드에서 인스턴스로 만들 클래스가 특정 타입을 구현하도록 강제할 수 있다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse04;

import pattern.sample.patternuse04.building.Barrack;
import pattern.sample.patternuse04.code.UnitType;
import pattern.sample.patternuse04.unit.inf.Unit;

public class BattleGround {
    public static void main(String[] args) {

        Unit marine = Barrack.createUnit(UnitType.MARINE);
        Unit medic = Barrack.createUnit(UnitType.MEDIC);
        Unit firebat = Barrack.createUnit(UnitType.FIREBAT);

        marine.action();
        medic.action();
        firebat.action();
    }
}

package pattern.sample.patternuse04.building;

import pattern.sample.patternuse04.code.UnitType;
import pattern.sample.patternuse04.trainer.FireBatTrainer;
import pattern.sample.patternuse04.trainer.MarineTrainer;
import pattern.sample.patternuse04.trainer.MedicTrainer;
import pattern.sample.patternuse04.trainer.factory.Trainer;
import pattern.sample.patternuse04.unit.inf.Unit;

public class Barrack {

    public static Unit createUnit(UnitType unitType){

        Trainer trainer;

        switch (unitType){
            case MARINE:
                trainer = new MarineTrainer();
            case MEDIC:
                trainer = new MedicTrainer();
            default:
                trainer = new FireBatTrainer();
        }

        return trainer.createUnit();
    }
}

package pattern.sample.patternuse04.code;

public enum UnitType {
    MARINE,
    MEDIC,
    FIREBAT
}

package pattern.sample.patternuse04.trainer.factory;

import pattern.sample.patternuse04.unit.inf.Unit;

public abstract class Trainer {

    public abstract Unit createUnit();
}

package pattern.sample.patternuse04.trainer;

import pattern.sample.patternuse04.trainer.factory.Trainer;
import pattern.sample.patternuse04.unit.FireBat;
import pattern.sample.patternuse04.unit.inf.Unit;

public class FireBatTrainer extends Trainer {
    @Override
    public Unit createUnit() {
        return new FireBat();
    }
}

package pattern.sample.patternuse04.trainer;

import pattern.sample.patternuse04.trainer.factory.Trainer;
import pattern.sample.patternuse04.unit.Marine;
import pattern.sample.patternuse04.unit.inf.Unit;

public class MarineTrainer extends Trainer {
    @Override
    public Unit createUnit() {
        return new Marine();
    }
}

package pattern.sample.patternuse04.trainer;

import pattern.sample.patternuse04.trainer.factory.Trainer;
import pattern.sample.patternuse04.unit.Medic;
import pattern.sample.patternuse04.unit.inf.Unit;

public class MedicTrainer extends Trainer {
    @Override
    public Unit createUnit() {
        return new Medic();
    }
}

package pattern.sample.patternuse04.unit.inf;

public interface Unit {

    public void action();
}

package pattern.sample.patternuse04.unit;

import pattern.sample.patternuse04.unit.inf.Unit;

public class FireBat implements Unit {
    @Override
    public void action() {

    }
}

package pattern.sample.patternuse04.unit;

import pattern.sample.patternuse04.unit.inf.Unit;

public class Marine implements Unit {
    @Override
    public void action() {

    }
}

package pattern.sample.patternuse04.unit;

import pattern.sample.patternuse04.unit.inf.Unit;

public class Medic implements Unit {
    @Override
    public void action() {

    }
}

                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Conditional Logic with Strategy
                    </h5>
                  </div>
                  <p class="mb-1">
                    메서드 내의 조건문을 통해 여러 개의 서로 다른 로직(계산법) 가운데 어떤 것을 실행할 지 선택하고 있다면, 
                    각 계산법에 대응하는 스트레티지(Strategy) 클래스를 만들고 해당 스트레티지 인스턴스에 계산을 위임하도록 메서드를 수정한다. 
                    <hr>
                    <ul>
                      <li>조건 로직을 줄이거나 제거해 알고리즘을 명확하게 한다.</li>
                      <li>알고지름 내의 여러 로직을 상속 구조로 옮겨 클래스를 단순화 한다. </li>
                      <li>런타임에 어떤 알고리즘을 다른 알고리즘으로 변경하기가 쉬어진다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse05;

import pattern.sample.patternuse05.building.Barrack;
import pattern.sample.patternuse05.code.UnitType;
import pattern.sample.patternuse05.unit.inf.Unit;

public class BattleGround {
    public static void main(String[] args) {
        Unit marine = Barrack.createUnit(UnitType.MARINE);

        Unit medic = Barrack.createUnit(UnitType.MEDIC);

        marine.action();

        medic.action();
    }
}

package pattern.sample.patternuse05.ability.inf;

public interface Action {
    public void act();
}

package pattern.sample.patternuse05.ability;

import pattern.sample.patternuse05.ability.inf.Action;

public class Attack implements Action {
    @Override
    public void act() {

    }
}

package pattern.sample.patternuse05.ability;

import pattern.sample.patternuse05.ability.inf.Action;

public class Heal implements Action {
    @Override
    public void act() {

    }
}

package pattern.sample.patternuse05.building;

import pattern.sample.patternuse05.ability.Attack;
import pattern.sample.patternuse05.ability.Heal;
import pattern.sample.patternuse05.code.UnitType;
import pattern.sample.patternuse05.unit.Marine;
import pattern.sample.patternuse05.unit.Medic;
import pattern.sample.patternuse05.unit.inf.Unit;

public class Barrack {
    public static Unit createUnit(UnitType unitType){
        switch (unitType){
            case MARINE:
                return new Marine(new Attack());
            case MEDIC:
                return new Medic(new Heal());
            default:
                return null;
        }
    }
}

package pattern.sample.patternuse05.code;

public enum UnitType {
    MARINE,
    MEDIC
}

package pattern.sample.patternuse05.unit.inf;

public interface Unit {
    public void action();
}

package pattern.sample.patternuse05.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse05.ability.inf.Action;
import pattern.sample.patternuse05.unit.inf.Unit;

@RequiredArgsConstructor
public class Marine implements Unit {

    private final Action action;

    @Override
    public void action() {
        action.act();
    }
}

package pattern.sample.patternuse05.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse05.ability.inf.Action;
import pattern.sample.patternuse05.unit.inf.Unit;

@RequiredArgsConstructor
public class Medic implements Unit {

    private final Action action;

    @Override
    public void action() {
        action.act();
    }
}
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Form Template Method
                    </h5>
                  </div>
                  <p class="mb-1">
                    한 상속 구조 내의 어떤 두 서브 클래스가 유사한 단위 작업을 같은 순서로 실행하는 메서드를 각자 구현하고 있다면, 
                    각 단위 작업을 별도의 메서드로 뽑아내어 두 메서드를 일반화하고 이렇게 일반화 된 메서드를 수퍼 클래스로 올려 템플릿 메서드로 만든다. 
                    <ul>
                      <li>서브 클래스 들의 공통 기능을 수퍼 클래스로 옮겨, 중복 코드가 제거 된다. </li>
                      <li>알고리즘의 과정이 단순해지고, 쉽게 알아볼 수 있다. </li>
                      <li>서브 클래스에서 알고리즘의 구현을 재정의하는 것이 쉬워진다. </li>
                      <li>서브 클래스가 꼭 구현해야하는 메서드의 개수가 많다면, 설계가 복잡해진다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse06;

import pattern.sample.patternuse06.building.Barrack;
import pattern.sample.patternuse06.code.UnitType;
import pattern.sample.patternuse06.unit.inf.Unit;

public class BattleGround {
    public static void main(String[] args) {
        Unit marine = Barrack.createUnit(UnitType.MARINE);

        marine.Action();

        Unit medic = Barrack.createUnit(UnitType.MEDIC);

        medic.Action();
    }
}

package pattern.sample.patternuse06.building;

import pattern.sample.patternuse06.code.UnitType;
import pattern.sample.patternuse06.template.Training;
import pattern.sample.patternuse06.template.impl.MarineTraining;
import pattern.sample.patternuse06.template.impl.MedicTraining;
import pattern.sample.patternuse06.unit.Marine;
import pattern.sample.patternuse06.unit.Medic;
import pattern.sample.patternuse06.unit.inf.Unit;

import static pattern.sample.patternuse06.code.UnitType.MARINE;
import static pattern.sample.patternuse06.code.UnitType.MEDIC;

public class Barrack {
    public static Unit createUnit(UnitType unitType){
        Training training;

        switch (unitType){
            case MARINE:
                training = new MarineTraining();

                return new Marine(training.trainingUnit(MARINE));

            case MEDIC:
                training = new MedicTraining();

                return new Medic(training.trainingUnit(MEDIC));

            default:
                return null;
        }
    }
}


package pattern.sample.patternuse06.code;

public enum UnitType {
    MARINE,
    MEDIC
}

package pattern.sample.patternuse06.template;

import pattern.sample.patternuse06.code.UnitType;
import pattern.sample.patternuse06.unit.action.inf.Action;

public abstract class Training {

    public Action trainingUnit(UnitType unitType){

        return training();
    }

    public abstract Action training();
}


package pattern.sample.patternuse06.template.impl;

import pattern.sample.patternuse06.template.Training;
import pattern.sample.patternuse06.unit.action.Attack;
import pattern.sample.patternuse06.unit.action.inf.Action;

public class MarineTraining extends Training {
    @Override
    public Action training() {
        return new Attack();
    }
}

package pattern.sample.patternuse06.template.impl;

import pattern.sample.patternuse06.template.Training;
import pattern.sample.patternuse06.unit.action.Heal;
import pattern.sample.patternuse06.unit.action.inf.Action;

public class MedicTraining extends Training {
    @Override
    public Action training() {
        return new Heal();
    }
}

package pattern.sample.patternuse06.unit.action.inf;

public interface Action {
    public void act();
}

package pattern.sample.patternuse06.unit.action;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse06.unit.action.inf.Action;

@Slf4j
public class Attack implements Action {
    @Override
    public void act() {
        log.info("공격하다.");
    }
}

package pattern.sample.patternuse06.unit.action;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse06.unit.action.inf.Action;

@Slf4j
public class Heal implements Action {
    @Override
    public void act() {
        log.info("치료하다.");
    }
}

package pattern.sample.patternuse06.unit.inf;

public interface Unit {
    public void Action();
}

package pattern.sample.patternuse06.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse06.unit.action.inf.Action;
import pattern.sample.patternuse06.unit.inf.Unit;

@RequiredArgsConstructor
public class Marine implements Unit {

    private final Action action;

    @Override
    public void Action() {
        action.act();
    }
}

package pattern.sample.patternuse06.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse06.unit.action.inf.Action;
import pattern.sample.patternuse06.unit.inf.Unit;

@RequiredArgsConstructor
public class Medic implements Unit {

    private final Action action;

    @Override
    public void Action() {
        action.act();
    }
}
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Compose Method
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 메서드의 내부 로직이 한 눈에 이해하기 어렵다면, 그 로직을 의도가 잘 드러나며 동등한 수준의 작업을 하는 여러 단계로 나눈다. 
                    <ul>
                      <li>어떤 메서드가 무슨일을 하고, 또 그 일을 수행하는지 효과적으로 표현한다. </li>
                      <li>동등한 수준의 작업을 하며 이름이 적절하게 붙은 몇 단계로 내부를 나눔으로써, 메서드를 단순하게 만든다. </li>
                      <li>작은 메서드가 지나치게 많이 생길 수 있다.</li>
                      <li>로직이 여러 곳에 흩어지기 때문에 디버깅이 어려울 수 있다. </li>
                    </ul>
                    <hr>
                    절차 
                    <ul>
                      <li>
                        <strong>작게 만든다.</strong> 
                        Composed Method의 코드는 10줄을 잘 넘어가지 않는다. 보통 5줄 정도다. 
                      </li>
                      <li>
                        <strong>사용되지 않거나 중복된 코드를 제거한다. </strong> 
                        이렇게 함으로써 메서드 내부의 코드량을 줄일 수 있다. 중복된 코드 중에는 명확하게 드러나는 것도 있지만 유심히 살펴봐야 발견할 수 있는 경우도 있음을 명심하기 바란다. 
                      </li>
                      <li>
                        <strong>코드의 의도가 잘 드러나도록 한다. </strong> 
                        변수와 메서드, 파라미터의 이름이 그 목적을 잘 표현하도록 짓는다. ( 예를 들어, public void addChildTo(Nodeparent) 와 같은 식으로 )
                      </li>
                      <li>
                        <strong>단순화 한다.</strong>
                        코드를 가능한 한 단순하게 변경한다. 기존의 코드가 어떻게 작성됐는지 고착하고, 다른 대안을 시험해본다. 
                      </li>
                      <li>
                        <strong>동등한 수준으로 단계를 나눈다.</strong>
                        메서드를 여러 작업 단계로 나눌 때, 각 단계가 동등한 수준이 되도록 해야한다. 예를 들어, 세부 조건을 검사하는 로직과 몇 개의 고수준 메서드를 호출하는 코드가 섞여 있다면, 동등하지 않은 수준의 단계들로 이루어진것이다. 세부 조건 로직을 이름이 잘 지어진 별도의 메서드로 뽑아내, 다른 
                        고수준 메서드와 동등한 수준으로 맞춰야 한다. 
                      </li>
                    </ul>
                    예제 
                    <pre>
                      <code class="java" >
public class List... 
 
  // 매직 넘버 10은 그 목적을 전혀 표현하지 못하는 숫자로 하드 코딩 되어 있으므로, 먼저 이를 상수로 변경한다. 
  private final static int GROWTH_INCREMENT = 10;                        

  public void add(Object element) {
    // 조건 문으로 메서드 전체를 감싸기보다는 다음과 같이 초반에 메서드를 빠져 나가도록 함으로써 메서드의 실행 요건을 명시하는 것이 낫다. 
    if ( readOnly )
      return;
    
    // elements 배열의 크기를 늘릴 필요가 있는지를 검사하는 코드에 Extract Method 리팩터링을 적용한다. 
    if(atCapacity()){
      grow();
    }
    addElement(elements);
  }  
  
  private boolean atCapacity(){
    return (size + 1) > elements.length;
  }

  private void grow() {
    Object[] newElements = new Object[elements.length + GROWTH_INCREMENT];
    for ( int i = 0; i &lt; size ; i ++ ){
      newElements[i] = elements[i];
    }
    elements = newElements;
  }

  private void addElement(Object element){
    element[size++] = element;
  }
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Implicit Tree with Composite 
                    </h5>
                  </div>
                  <p class="mb-1">
                    실질적으로 트리 구조인 데이터를 String 과 같은 기본 타입으로 표현하고 있다면, 그 기본 타입의 표현을 컴포짓 구조로 바꾼다. 
                    <ul>
                      <li>코드를 더 단순하게 만들기 위해서 Composite 패턴을 사용한다. </li>
                      <li>노드를 추가/삭제/포매팅하는 등의 반복적인 코드를 캡슐화 한다. </li>
                      <li>빈번하게 사용하는 유사한 로직을 다루기 위한 일반화된 방법을 제공한다.</li>
                      <li>클라이언트가 데이터를 생성하는 방법이 단순해진다. </li>
                    </ul>
                    <hr>
                    묵시적 트리 중에서 새로운 클래스로 모델화할 수 있는 부분인, 묵시적 종단을 찾는다. 이 때 새로운 클래스는 종단 노드를 나타내는 것으로, Composite:Leaf에 해당한다. 종단 노드 클래스는 리팩터링 또는 테스트 주도 갭잘을 통해서 생성할 수 있다. 
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse07;

import pattern.sample.patternuse07.building.Barrack;
import pattern.sample.patternuse07.unit.UnitComposite;
import pattern.sample.patternuse07.unit.type.MarineType;
import pattern.sample.patternuse07.unit.type.MedicType;

public class BattleGround {
    public static void main(String[] args) {
        UnitComposite unitList = Barrack.requestUnit();

        unitList.addTrainedUnit(new MedicType());
        unitList.addTrainedUnit(new MarineType());
        unitList.addTrainedUnit(new MarineType());
        unitList.addTrainedUnit(new MarineType());
        unitList.addTrainedUnit(new MarineType());
        unitList.addTrainedUnit(new MedicType());
        unitList.addTrainedUnit(new MedicType());
        unitList.addTrainedUnit(new MedicType());
        unitList.addTrainedUnit(new MedicType());

        unitList.trainingUnit();

        unitList.checkTrainedUnit();
    }
}

package pattern.sample.patternuse07.building;

import pattern.sample.patternuse07.unit.UnitComposite;

public class Barrack {
    public static UnitComposite requestUnit(){
        return new UnitComposite();
    }
}


package pattern.sample.patternuse07.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse07.unit.impl.Marine;
import pattern.sample.patternuse07.unit.impl.Medic;
import pattern.sample.patternuse07.unit.inf.Unit;
import pattern.sample.patternuse07.unit.type.MarineType;
import pattern.sample.patternuse07.unit.type.MedicType;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@RequiredArgsConstructor
public class UnitComposite {

    private final List&lt;UnitComposite> unitCompositeList = new ArrayList&lt;>();
    private List&lt;Unit> unitList;

    public void trainingUnit(){
        unitList = unitCompositeList.stream().map(trainingType -> {
            trainingType.trainingUnit();

            if(trainingType instanceof MarineType){
                return new Marine();
            }else if(trainingType instanceof MedicType){
                return new Medic();
            }else {
                return null;
            }
        }).collect(Collectors.toList());
    }

    public void checkTrainedUnit(){
        unitList.forEach(Unit::checkUnit);
    }

    public void addTrainedUnit(UnitComposite unitComposite){
        unitCompositeList.add(unitComposite);
    }
}

package pattern.sample.patternuse07.unit.type;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse07.unit.UnitComposite;

@Slf4j
public class MedicType extends UnitComposite {
    @Override
    public void trainingUnit() {
        log.info("메딕 훈련을 시작합니다. ");
    }
}

package pattern.sample.patternuse07.unit.type;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse07.unit.UnitComposite;

@Slf4j
public class MarineType extends UnitComposite {

    @Override
    public void trainingUnit() {
        log.info("마린 훈련을 시작합니다. ");
    }
}

package pattern.sample.patternuse07.unit.inf;

public interface Unit {
    public void checkUnit();
}

package pattern.sample.patternuse07.unit.impl;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse07.unit.inf.Unit;

@Slf4j
public class Marine implements Unit {
    @Override
    public void checkUnit() {
        log.info("Marine 입니다.");
    }
}

package pattern.sample.patternuse07.unit.impl;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse07.unit.inf.Unit;

@Slf4j
public class Medic implements Unit {
    @Override
    public void checkUnit() {
        log.info("Medic 입니다.");
    }
}



                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Encapsulate Composite with Builder
                    </h5>
                  </div>
                  <p class="mb-1">
                    컴포짓 구조를 생성하는 과정이 반복적으로 수행되고 복잡하며 에러 발생 가능성도 많은 상태라면, 그 세부 사항을 처리하는 별도의 빌더를 제공하여 
                    컴포짓 구조를 쉽게 생성할 수 있도록 한다. 
                    <hr>                  
                    <ul>
                      <li>컴포짓 구조를 생성하는 클라이언트의 코드를 단순화 한다.</li>
                      <li>반복적이고 에러 발생 가능성이 높은 컴포짓 구조 생성 작업의 단점을 개선한다. </li>
                      <li>클라이언트 코드의 컴포짓 구조 사이의 결합을 느슨하게 한다.</li>
                      <li>캡슐화된 컴포짓 구조 또는 복잡한 객체의 여러 다양한 표현이 가능하게 한다.</li>
                      <li>인터페이스의 의도가 덜 명확해질 수 있다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse08;

import pattern.sample.patternuse08.building.Barrack;
import pattern.sample.patternuse08.code.UnitType;
import pattern.sample.patternuse08.unit.inf.Unit;
import pattern.sample.patternuse08.unitBuilder.UnitBuilder;

public class BattleGround {
    public static void main(String[] args) {
        Unit marine = Barrack.createUnit(UnitBuilder.builder()
                                    .unitName("Marine")
                                    .unitType(UnitType.MARINE).build());


    }
}

package pattern.sample.patternuse08.building;

import pattern.sample.patternuse08.unit.inf.Unit;
import pattern.sample.patternuse08.unitBuilder.UnitBuilder;

public class Barrack {

    public static Unit createUnit(UnitBuilder unitBuilder){
        return unitBuilder.createUnit();
    }

}

package pattern.sample.patternuse08.code;

public enum UnitType {
    MARINE,
    MEDIC,
    SCV
}

package pattern.sample.patternuse08.unit.inf;

public interface Unit {
}

package pattern.sample.patternuse08.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse08.unit.inf.Unit;

@Slf4j
public class Marine implements Unit {
    public Marine() {
        log.info("Marine이 생성되었습니다. ");
    }
}

package pattern.sample.patternuse08.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse08.unit.inf.Unit;

@Slf4j
public class Medic implements Unit {
    public Medic(){
        log.info("Medic이 생성되었습니다.");
    }
}

package pattern.sample.patternuse08.unit;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse08.unit.inf.Unit;

@Slf4j
public class SCV implements Unit {
    public SCV() {
        log.info("SCV이 생성되었습니다.");
    }
}

package pattern.sample.patternuse08.unitBuilder;

import lombok.Builder;
import pattern.sample.patternuse08.code.UnitType;
import pattern.sample.patternuse08.unit.Marine;
import pattern.sample.patternuse08.unit.Medic;
import pattern.sample.patternuse08.unit.SCV;
import pattern.sample.patternuse08.unit.inf.Unit;

public class UnitBuilder {

    private final String unitName;
    private final UnitType unitType;

    @Builder
    public UnitBuilder(String unitName, UnitType unitType){
        this.unitName = unitName;
        this.unitType = unitType;
    }

    public Unit createUnit(){
        switch (unitType){
            case MEDIC:
                return new Medic();
            case MARINE:
                return new Marine();
            default:
                return new SCV();
        }
    }
}                    
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Move Accumulation to Collecting Parameter
                    </h5>
                  </div>
                  <p class="mb-1">
                    지역변수에 정보를 축적하는 매우 긴 메서드가 있다면, 그것을 여러 메서드로 분해하고 각 메서드에 수집 파라미터를 넘겨 정보를 축적하도록 한다. 
                    <hr>
                    다루기 어려울 정도로 비대한 메서드를 분해해 Composed Method로 만들려면, 
                    Composed Method에 의해 호출되는 각 메서드로부터 정보를 얻어 어떻게 축적할 것인지 
                    결정해야 한다. 각 메서드가 리턴한 정보를 보관해 두었다가 나중에 최종 형태로 합칠 수도 있지만 각 메서드에 수집 파라미터를 넘겨 정보를 점진적으로 축적할 수도 있다. 각 메서드는 자신의 정보를 수집 파라미터에 쓰고, 그 결과로 정보가 축적된다. 
                    
                    <ul>
                      <li>다루기 어려울 정도로 비대한 메서드를 작고 간단하며 이해하기 쉬운 여러 개의 메서드로 분해하는 데 도움이 된다. </li>
                      <li>코드의 실행 속도가 향상될 수 있다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse09;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse09.building.Barrack;
import pattern.sample.patternuse09.code.UnitType;
import pattern.sample.patternuse09.unit.inf.Unit;

@Slf4j
public class BattleGround {
    public static void main(String[] args) {
        Unit unit = Barrack.getUnit(UnitType.MARINE);

        Unit unitMedic = Barrack.getUnit(UnitType.MEDIC);

        log.info("결과 : {}" ,unit.checkAbility());
        log.info("결과 : {}" ,unitMedic.checkAbility());
    }
}

package pattern.sample.patternuse09.builder;

import lombok.Builder;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@Builder
public class TrainingBuilder {
    private final Training walking;
    private final Training running;
    private final Training jumping;
    private final Training hiding;
    private final Training watching;
    private final Unit unit;

    public Unit trainingUnit(){

        walking.practice(unit);

        running.practice(unit);

        jumping.practice(unit);

        hiding.practice(unit);

        watching.practice(unit);

        return unit;
    }
}

package pattern.sample.patternuse09.building;

import pattern.sample.patternuse09.builder.TrainingBuilder;
import pattern.sample.patternuse09.code.UnitType;
import pattern.sample.patternuse09.order.*;
import pattern.sample.patternuse09.unit.Marine;
import pattern.sample.patternuse09.unit.Medic;
import pattern.sample.patternuse09.unit.inf.Unit;

public class Barrack {
    public static Unit getUnit(UnitType unitType){

        if(unitType == UnitType.MARINE){
            return TrainingBuilder
                    .builder()
                    .unit(new Marine())
                    .hiding(new Hiding())
                    .jumping(new Jumping())
                    .running(new Running())
                    .walking(new Walking())
                    .watching(new Watching())
                    .build().trainingUnit();
        }else{
            return TrainingBuilder
                    .builder()
                    .unit(new Medic())
                    .hiding(new Hiding())
                    .jumping(new Jumping())
                    .running(new Running())
                    .walking(new Walking())
                    .watching(new Watching())
                    .build().trainingUnit();
        }
    }
}

package pattern.sample.patternuse09.code;

public enum UnitType {
    MARINE,
    MEDIC,
    SCV
}

package pattern.sample.patternuse09.order.inf;

public interface Training&lt;ReturnR> {

    public ReturnR practice(ReturnR returnR);
}

package pattern.sample.patternuse09.order;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@RequiredArgsConstructor
public class Hiding implements Training&lt;Unit> {

    @Override
    public Unit practice(Unit unit) {

        unit.trainAbility(" 숨기 능력이 추가되었습니다.");

        return unit;
    }
}

package pattern.sample.patternuse09.order;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@RequiredArgsConstructor
public class Jumping implements Training&lt;Unit> {

    @Override
    public Unit practice(Unit unit) {
        unit.trainAbility(" 점프 능력이 추가되었습니다.");
        return unit;
    }
}

package pattern.sample.patternuse09.order;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@RequiredArgsConstructor
public class Running  implements Training&lt;Unit> {

    @Override
    public Unit practice(Unit unit) {
        unit.trainAbility(" 달리기 능력이 추가되었습니다.");
        return unit;
    }
}

package pattern.sample.patternuse09.order;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@RequiredArgsConstructor
public class Walking  implements Training&lt;Unit> {

    @Override
    public Unit practice(Unit unit) {
        unit.trainAbility(" 걷기 능력이 추가되었습니다.");
        return unit;
    }
}

package pattern.sample.patternuse09.order;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse09.order.inf.Training;
import pattern.sample.patternuse09.unit.inf.Unit;

@RequiredArgsConstructor
public class Watching  implements Training&lt;Unit> {

    @Override
    public Unit practice(Unit unit) {
        unit.trainAbility(" 보기 능력이 추가되었습니다.");
        return unit;
    }
}

package pattern.sample.patternuse09.unit.inf;

public interface Unit {

    public void trainAbility(String ability);

    public String checkAbility();
}

package pattern.sample.patternuse09.unit;

import pattern.sample.patternuse09.unit.inf.Unit;

public class Marine implements Unit {

    private StringBuilder abilities = new StringBuilder();
    private final String unitName;

    public Marine(){
        unitName = "Marine";
    }

    public void trainAbility(String ability){
        abilities.append("능력 : " + ability + "\r\n");
    }

    public String checkAbility(){
        return abilities.toString();
    }

}

package pattern.sample.patternuse09.unit;

import pattern.sample.patternuse09.unit.inf.Unit;

public class Medic implements Unit {

    private StringBuilder abilities = new StringBuilder();
    private final String unitName;

    public Medic(){
        unitName = "Medic";
    }

    public void trainAbility(String ability){
        abilities.append("능력 : " + ability + "\r\n");
    }

    public String checkAbility(){
        return abilities.toString();
    }
}


                        
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Extract Composite
                    </h5>
                  </div>
                  <p class="mb-1">
                    한 상속 구조 내의 서브 클래스가 동일한 컴포짓 기능을 각자 구현하고 있다면, 컴포짓 기능을 수퍼 클래스로 옮겨 구현한다. 
                    <hr>
                    어떤 상속 구조 내의 서브 클래스들이 자신의 자식 객체를 컬렉션에 저장하고 그 자식 객체들의 기능에 접근하기 위한 메서드를 각자 구현하는 것은 자주 볼 수 있다. 
                    이때 만약 자식 객체의 타입이 부모 객체와 동일한 상속 구조 내의 타임이라면 , Composite패턴으로 리팩터링하여 많은 코드 중복을 제거할 수 있다. 
                    <ul>
                      <li>중복된 자식 객체 저장/처리 로직을 제거한다.</li>
                      <li>자식 객체 처리 로직을 상속 받아 그대로 사용할 수 있음이 명확히 드러난다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse10;

import pattern.sample.patternuse10.action.Act;
import pattern.sample.patternuse10.action.Hiding;
import pattern.sample.patternuse10.action.Running;
import pattern.sample.patternuse10.action.Walking;
import pattern.sample.patternuse10.action.composite.Action;
import pattern.sample.patternuse10.code.ActionType;
import pattern.sample.patternuse10.unit.Marine;
import pattern.sample.patternuse10.unit.inf.Unit;

public class BattleGround {
    public static void main(String[] args) {

        Action action = new Act();

        action.actionAdd(new Running());
        action.actionAdd(new Hiding());
        action.actionAdd(new Walking());

        Unit marine = new Marine(action);

        marine.act(ActionType.HIDING);
        marine.act(ActionType.HIDING);
        marine.act(ActionType.WALK);
        marine.act(ActionType.RUNNING);
    }
}

package pattern.sample.patternuse10.action.composite;

import pattern.sample.patternuse10.action.Hiding;
import pattern.sample.patternuse10.action.Running;
import pattern.sample.patternuse10.action.Walking;
import pattern.sample.patternuse10.code.ActionType;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;

public abstract class Action {

    protected List&lt;Action> actionList = new ArrayList&lt;>();

    public void actionAdd(Action action){
        actionList.add(action);
    }

    public Action action(ActionType actionType){

        AtomicReference&lt;Action> action = new AtomicReference&lt;>();

        actionList.forEach(actionFromList -> {
            switch (actionType){
                case RUNNING:
                    if(actionFromList instanceof Running){
                        action.set(actionFromList);
                    }
                    return;
                case HIDING:
                    if(actionFromList instanceof Hiding) {
                        action.set(actionFromList);
                    }
                    return;
                case WALK:
                    if(actionFromList instanceof Walking ){
                        action.set(actionFromList);
                    }
                    return;
                }
        });

        return action.get();
    }

    public abstract void act();
}

package pattern.sample.patternuse10.action;

import pattern.sample.patternuse10.action.composite.Action;
import pattern.sample.patternuse10.code.ActionType;

import java.util.concurrent.atomic.AtomicReference;

public class Act extends Action {

    @Override
    public Action action(ActionType actionType){

        AtomicReference&lt;Action> action = new AtomicReference&lt;>();

        super.actionList.forEach(actionFromList -> {
            switch (actionType){
                case RUNNING:
                    if(actionFromList instanceof Running){
                        action.set(actionFromList);
                    }
                    return;
                case HIDING:
                    if(actionFromList instanceof Hiding) {
                        action.set(actionFromList);
                    }
                    return;
                case WALK:
                    if(actionFromList instanceof Walking ){
                        action.set(actionFromList);
                    }
                    return;
            }
        });

        return action.get();
    }

    @Override
    public void act() {

    }
}

package pattern.sample.patternuse10.action;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse10.action.composite.Action;

@Slf4j
public class Hiding extends Action {
    @Override
    public void act() {
        log.info("Hiding Action start!");
    }
}

package pattern.sample.patternuse10.action;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse10.action.composite.Action;

@Slf4j
public class Running  extends Action {
    @Override
    public void act() {
        log.info("Running Action start!");
    }
}

package pattern.sample.patternuse10.action;

import lombok.extern.slf4j.Slf4j;
import pattern.sample.patternuse10.action.composite.Action;

@Slf4j
public class Walking  extends Action {
    @Override
    public void act() {
        log.info("Waling Action start!");
    }
}

package pattern.sample.patternuse10.code;

public enum ActionType {
    WALK,
    RUNNING,
    HIDING
}

package pattern.sample.patternuse10.unit.inf;

import pattern.sample.patternuse10.code.ActionType;

public interface Unit {

    public void act(ActionType actionType);
}

package pattern.sample.patternuse10.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse10.action.composite.Action;
import pattern.sample.patternuse10.code.ActionType;
import pattern.sample.patternuse10.unit.inf.Unit;

@RequiredArgsConstructor
public class Marine implements Unit {
    private final Action action;

    @Override
    public void act(ActionType actionType) {
        action.action(actionType).act();
    }
}                    
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace One/Many Distinctions with Composite
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 클래스에서 주어진 객체를 처리 할 때, 그 객체의 개수에 따라 서로 다른 로직을 사용하고 있다면, 컴포짓을 사용해 객체의 개수에 상관없이 한 로직으로 처리할 수 있도록 만든다. 
                    <hr>
                    어떤 클래스에 하나의 객체를 처리하는 메서드가 있는데, 로직이 이와 거의 비슷하면서 여러 객체를 처리하는 메서드가 있다면, 이는 한 객체와 여러 객체를 구별하고 있는 것이다. 이와 같은 경우에는 
                    코드가 중복되고, 클라이언트의 코드가 복잡해지고, 처리 결과를 취합하기 위해서 추가적인 처리가 필요해진다. `
                    <ul>
                      <li>객체가 하나일 때와 여러 개일 때를 처리하기 위해 각각 존재했던 중복된 처리 코드를 제거할 수 있다. </li>
                      <li>객체 하나를 처리하는 방법과 객체 여러 개를 처리하는 방법이 하나로 통일된다. </li>
                      <li>여러 개의 객체를 처리하기 위해 필요한 추가적인 기능을 부여할 수 있다. ( 예를 들어, OR 조건 표현 ) </li>
                      <li>컴포짓을 생성하는 동안 타입 안전성을 위해 런타임 타입 검사가 필요할 수 있다. </li>
                    </ul> 
                    <hr>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse11;

import pattern.sample.patternuse11.building.Barrack;
import pattern.sample.patternuse11.unit.Marine;
import pattern.sample.patternuse11.unit.Medic;

import java.util.Arrays;

public class BattleGround {
    public static void main(String[] args) {

        Barrack barrack = new Barrack();

        barrack.isTrainedUnit(new Marine());

        barrack.isTrainedUnit(Arrays.asList(new Marine(), new Medic()));
    }
}

package pattern.sample.patternuse11.building;

import pattern.sample.patternuse11.unit.UnitPackage;
import pattern.sample.patternuse11.unit.composit.Unit;

import java.util.List;

public class Barrack {

    public boolean isTrainedUnit(Unit unit){

        // isTrainedUnit에 대한 중복 로직을 해당 메소드에서 공통적으로 처리할 수 있다.

        return unit.checkUnitStatus();
    }

    public boolean isTrainedUnit(List&lt;Unit> unitList){
        return isTrainedUnit(new UnitPackage(unitList));
    }
}

package pattern.sample.patternuse11.unit.composit;
public abstract class Unit {

    public abstract boolean checkUnitStatus();
}

package pattern.sample.patternuse11.unit;

import pattern.sample.patternuse11.unit.composit.Unit;

public class Marine extends Unit {
    @Override
    public boolean checkUnitStatus() {
        return false;
    }
}

package pattern.sample.patternuse11.unit;

import pattern.sample.patternuse11.unit.composit.Unit;

public class Medic extends Unit {
    @Override
    public boolean checkUnitStatus() {
        return false;
    }
}

package pattern.sample.patternuse11.unit;

import lombok.RequiredArgsConstructor;
import pattern.sample.patternuse11.unit.composit.Unit;

import java.util.ArrayList;
import java.util.List;

@RequiredArgsConstructor
public class UnitPackage extends Unit {

    private final List&lt;Unit> unitList;
    private List&lt;Unit> filteredUnitList = new ArrayList&lt;>();

    public void add(Unit unit){
        unitList.add(unit);
    }

    public List&lt;Unit> getSpecs(){
        return filteredUnitList;
    }

    @Override
    public boolean checkUnitStatus() {
        return false;
    }
}                       
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Conditional Dispatcher with Command 
                    </h5>
                  </div>
                  <p class="mb-1">
                    요청에 대한 디스패처가 조건 로직으로 구현되어 있다면, 각 액션에 대한 커맨드 객체를 만들어 컬렉션에 저장해두고, 
                    조건 로직은 컬렉션에서 원하는 커맨드를 찾아 실행하는 코드로 대체한다. 
                    <hr>
                    많은 시스템에서 외부 요청을 받아 분배하고 실행하는 동작이 일어난다. 이때 요청을 분배하고 실행하는 조건문을 조건적 디스패처라 부른다. 어떤 경우에는 조건적 디스패처로 충분히 작업을 수행할 수 있지만, 그렇지 못한 경우도 있다. 
                    <ul>
                      <li>다양한 액션을 단일한 방식으로 실행하는 단순한 구조를 제공한다. </li>
                      <li>요청을 처리하는 로직의 구성을 런타임에 변경할 수 있다.</li>
                      <li>간단한 코드로 구현할 수 있다.</li>
                      <li>조건적 디스패처로도 충분한 상황에서는 괜히 설계만 복잡하게 만드는 것이다. </li>
                    </ul>
                    <pre>
                      <code class="java" >
package pattern.sample.patternuse12;

import pattern.sample.patternuse12.building.Barrack;
import pattern.sample.patternuse12.code.UnitType;
import pattern.sample.patternuse12.unit.inf.Unit;

public class BattleGround {
    public static void main(String[] args) {
        Barrack barrack = new Barrack();

        Unit marineUnit = barrack.createUnit(UnitType.MARINE);
        Unit medicUnit = barrack.createUnit(UnitType.MEDIC);
    }
}

package pattern.sample.patternuse12.building;

import pattern.sample.patternuse12.code.UnitType;
import pattern.sample.patternuse12.unit.Marine;
import pattern.sample.patternuse12.unit.Medic;
import pattern.sample.patternuse12.unit.inf.Unit;

import java.util.HashMap;
import java.util.Map;

public class Barrack {

    private final Map&lt;UnitType, Unit> unitMap;

    public Barrack(){
        unitMap = new HashMap&lt;>();

        unitMap.put(UnitType.MARINE, new Marine());
        unitMap.put(UnitType.MEDIC, new Medic());
    }

    public Unit createUnit(UnitType unitType){
        return unitMap.get(unitType);
    }
}

package pattern.sample.patternuse12.code;

public enum UnitType {
    MARINE,
    MEDIC
}

package pattern.sample.patternuse12.unit.inf;

public interface Unit {
}

package pattern.sample.patternuse12.unit;

import pattern.sample.patternuse12.unit.inf.Unit;

public class Marine implements Unit {
}

package pattern.sample.patternuse12.unit;

import pattern.sample.patternuse12.unit.inf.Unit;

public class Medic implements Unit {
}
                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Extract Adapter 
                    </h5>
                  </div>
                  <p class="mb-1">
                    하나의 클래스가 컴포넌트, 라이브러리, API 등의 여러 버전을 동시에 지원하기 위한 어댑터 역할을 하고 있다면, 각 버전을 위한 기능을 별도의 어댑터로 뽑아낸다. 
                    <hr>
                    <div class="card">
                      <div class="card-header">
                        Adapter 와 Facade
                      </div>
                      <div class="card-body">
                        <p class="card-text">
                          Adapter 패턴은 Facade 패턴과 자주 혼동된다. 두 패턴이 모두 어떤 코드를 더 쉽게 사용할 수 있도록 만든다는 공통점이 있지만 적용하는 수준이 다르다. Adapter 패턴은 객체 수준에서의 어댑팅을 수행하는 것이고, Facade 패턴은 어떤 
                          서브 시스템 전체를 어댑팅하는 것이다. Facade 패턴은 레거시 시스템과 통신하기 위해 사용하는 경우가 많다. 예를 들어, 어떤 기업에 COBOL 로 작성된 시스템이 있는데, 이 시스템의 코드가 매우 복잡 미묘하고 2백만 줄이나 된다고 하자. 이 시스템은 한번도 리팩토링 작업을 
                          거친 적이 없기 때문에 확장과 유지보수가 매우 어렵다. 그럼에도 불구하고 , 이 시스템에는 중욯나 기능이 포함되어 있기 때문에 새로 만드는 시스템도 이 레거시 시스템에 의존할 수 밖에 없다. 
                          이런 상황에서는 Facade패턴이 유용하다. 퍼사드는 새 시스템에 설계가 좋지 않고 복잡한 게러시 코드에 대한 좀더 단순한 뷰를 제공한다. 새 시스템은 퍼사드 객체와 통신하고 이 퍼사드 객체가 레거시 코드와 관련된 복잡한 작업을 대신하는 것이다. 
                          레거시 시스템의 서브시스템 하나씩을 퍼사드로 대체해 나가면서, 결국에는 레거시 시스템 전체를 안전하게 새로 구현할 수 ㅇㅆ다. 
                          <ul>
                            <li>주어진 레거시 시스템의 서브시스템을 확인한다.</li>
                            <li>그 서브시스템을 위한 퍼사드를 구현한다.</li>
                            <li>앞서 만든 퍼사드를 사용하도록 클라이언트 코드를 수정한다.</li>
                            <li>레거시 시스템의 기능을 신기술로 다시 구현하고, 그를 어댑팅하는 새 퍼사드를 만든다. </li>
                            <li>기존의 퍼사드와 새 퍼사드가 동일하게 동작하는지 테스트한다.</li>
                            <li>새 퍼사드를 사용하도록 클라이언트 코드를 수정한다.</li>
                            <li>나머지 서브 시스템에 대해서 위의 과정을 반복한다. </li>
                          </ul>
                        </p>
                      </div>
                    </div>
                    <ul>
                      <li>컴포넌트, 라이브러리 또는 API의 버전에 따른 차이점을 격리한다. </li>
                      <li>클래스가 하나의 버전만 책임지도록 한다.</li>
                      <li>자주 변하는 코드를 시스템과 분리할 수 있다. </li>
                      <li>원래 있던 중요 기능을 어댑터에서 제공하지 못하면, 클라이언트가 그런 중요 기능에 접근하는데 장벽이 될 수 있다. </li>
                    </ul>
                    <pre>
                      <code>

                      </code>
                    </pre>
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Unify Interfaces with Adapter
                    </h5>
                  </div>
                  <p class="mb-1">
                    클라이언트가 두 개의 유사한 클래스를 사용하고 있는데, 그중 한 인터페이스가 다른 하나보다 더 좋아 보이면, 어댑터를 도입해 인터페이스를 도입한다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Type Code wit Class
                    </h5>
                  </div>
                  <p class="mb-1">
                      어떤 필드 타입이 부적합한 값의 대입이나 유효하지 않은 동일성 검사(비교)를 방지하지 못한다면, 필드의 타입을 클래스로 바꿔 값의 대입과 동일성 검사에 제약 조건을 부여한다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace State-Altering Conditional with State
                    </h5>
                  </div>
                  <p class="mb-1">
                      어떤 객체의 상태 전이를 제어하는 조건 로직이 복잡하다면, 각 상태에 해당하는 스테이브 클래스를 하나씩 만들고 그들이 스스로 다른 상태로 전이하는 것을 책임지도록하는 복잡한 조건 로직을 제거한다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Introduce Null Object
                    </h5>
                  </div>
                  <p class="mb-1">
                      어떤 필드나 변수의 값이 널인지 검사하는 로직이 코드의 여기 저기 중복되어 있다면, 값이 널인 경우에 행할 작업을 대신하는 널 객체를 사용하도록 수정한다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Inline Singleton
                    </h5>
                  </div>
                  <p class="mb-1">
                    코드의 여러곳에서 접근할 수 있어야 하지만 전역적일 필요 까지는 없는 객체가 싱글턴으로 구현되어 있다면, 싱글턴 객체를 저장하고 그에 대한 접근 경로를 제공하는 클래스로 싱글턴의 기능을 옮긴다. 그리고 싱글턴은 제거한다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Limit Instantiation with Singleton
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 클래스의 인스턴스를 여러 개 생성해 사용하고 있는데, 그로 인해 메모리 사용량이 너무 커지거나 시스템 성능이 저하된다면, 여러개의 객체를 하나의 싱글턴 객체로 대체한다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Hard-Coded Notifications with Observer
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 상속 구조 내의 서브클래스들이 자신과 관련된 클래스에 통보하는 기능을 하드 코딩으로 각자 구현하고 있다면, 
                    Observer 인터페이스를 통해 그 수퍼 클래스가 임의의 다른 클래스에 통보할 수 있도록 일반적인 통보 기능을 만들고 서브 클래스는 제거한다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Move Embellishment to Decorator
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 클래스에서 핵심 기능을 위한 코드와 꾸밈 코드가 뒤섞여 있으면, 꾸밈 코드를 데코레이터로 옮긴다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Unify Interfaces
                    </h5>
                  </div>
                  <p class="mb-1">
                    수퍼클래스(또는 인터페이스)가 서브 클래스와 동일한 인터페이스를 가질 필요가 있다면, 
                    서브 클래스에서 수퍼클래스에 없는 모든 public 메서드를 찾아 이를 수퍼 클래스에 추가한다. 이때 메서드 몸체는 비워놓아 아무 일도 하지 않도록 만든다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Extract Parameter
                    </h5>
                  </div>
                  <p class="mb-1">
                    메서드나 생성자 내에서 생성한 값을 필드에 저장하고 있다면,
                    대입문의 우변을 새 파라미터로 대체해 클라이언트가 그 값을 저장할 수 있도록 한다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Move Creation Knowlege to Factory
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 클래스에 인스턴스를 생성하는데 사용되는 데이터와 코드가 여러 클래스에 퍼져있다면 , 
                    그 생성  지식을 하나의 팩터리 클래스로 옮긴다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Move Accumulation to Visitor 
                    </h5>
                  </div>
                  <p class="mb-1">
                    어떤 메서드가 이질적인 여러 클래스들로 부터 정보를 언더 축적하고 있다면,
                    각 클래스를 방문해 정보를 축적하는 방문자 객체로 축적 기능을 옮긴다. 
                  </p>
                </a>
                <a href="#" class="list-group-item list-group-item-action">
                  <div class="d-flex w-100 justify-content-between">
                    <h5 class="mb-1">
                      Replace Implicit Language with Interpreter
                    </h5>
                  </div>
                  <p class="mb-1">
                    한 클래스 내의 여러 메서드에서 일종의 묵시적 언어를 이루는 요소들을 조합하고 있다면, 
                    그 묵시적 언어의 요소들을 각각의 클래스로 정의하고 그 객체의 조합을 해석 가능한 수식을 만들어 낼 수 있도록 한다. 
                  </p>
                </a>
              </div>
            </div>
        </div>
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
   
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
 
    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Page level plugin JavaScript-->
    <script src="../vendor/chart.js/Chart.min.js"></script>

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>

    <!-- Demo scripts for this page-->
    <script src="../js/demo/chart-area-demo.js"></script>
    <script src="../js/demo/chart-bar-demo.js"></script>
    <script src="../js/demo/chart-pie-demo.js"></script>

  </body>

</html>
