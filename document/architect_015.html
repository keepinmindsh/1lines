<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1Lines - Architecture</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">
    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">1 Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="true">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu show" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">서론</h6>
            <a class="dropdown-item" href="../document/architect_001.html">서론</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">사례연구</h6>
            <a class="dropdown-item" href="../document/architect_002.html">사례연구</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">생성 패턴</h6>
            <a class="dropdown-item" href="../document/architect_003.html">추상 팩토리</a>
            <a class="dropdown-item" href="../document/architect_004.html">빌더</a>
            <a class="dropdown-item" href="../document/architect_005.html">팩토리 메서드</a>
            <a class="dropdown-item" href="../document/architect_006.html">원형</a>
            <a class="dropdown-item" href="../document/architect_007.html">단일체</a>
            <a class="dropdown-item" href="../document/architect_008.html">생성 패턴에 대한 논의</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">구조 패턴</h6>
            <a class="dropdown-item" href="../document/architect_009.html">적응자</a>
            <a class="dropdown-item" href="../document/architect_010.html">가교</a>
            <a class="dropdown-item" href="../document/architect_011.html">복합체</a>
            <a class="dropdown-item" href="../document/architect_012.html">장식자</a>
            <a class="dropdown-item" href="../document/architect_013.html">퍼사드</a>
            <a class="dropdown-item" href="../document/architect_014.html">플라이급</a>
            <a class="dropdown-item" href="../document/architect_015.html">프록시</a>
            <a class="dropdown-item" href="../document/architect_016.html">구조패턴에 대한 논의</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">행동 패턴</h6>
            <a class="dropdown-item" href="../document/architect_017.html">책임 연쇄</a>
            <a class="dropdown-item" href="../document/architect_018.html">명령</a>
            <a class="dropdown-item" href="../document/architect_019.html">해석자</a>
            <a class="dropdown-item" href="../document/architect_020.html">반복자</a>
            <a class="dropdown-item" href="../document/architect_021.html">중재자</a>
            <a class="dropdown-item" href="../document/architect_022.html">메멘토</a>
            <a class="dropdown-item" href="../document/architect_023.html">감시자</a>
            <a class="dropdown-item" href="../document/architect_024.html">상태</a>
            <a class="dropdown-item" href="../document/architect_025.html">전략</a>
            <a class="dropdown-item" href="../document/architect_026.html">템플릿 메서드</a>
            <a class="dropdown-item" href="../document/architect_027.html">방문자</a>
            <a class="dropdown-item" href="../document/architect_028.html">행동 패턴에 대한 논의</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">결론</h6>
            <a class="dropdown-item" href="../document/architect_029.html">디자인 패턴에서 무엇을<br> 기대할 수 있는가?</a>
            <a class="dropdown-item" href="../document/architect_030.html">간략한 역사</a>
            <a class="dropdown-item" href="../document/architect_031.html">패턴 커뮤니티</a>
            <a class="dropdown-item" href="../document/architect_032.html">초대의 글</a>
            <a class="dropdown-item" href="../document/architect_033.html">책을 마무리하며</a>
            <div class="dropdown-divider"></div>
            <h6 class="dropdown-header">System Archtecture</h6>
            <a class="dropdown-item" href="../document/architect_053.html">API with Zuul</a>
            <a class="dropdown-item" href="../document/architect_037.html">Cloud System</a>
            <a class="dropdown-item" href="../document/architect_047.html">Cassandra</a>
            <a class="dropdown-item" href="../document/architect_036.html">DevOps</a>
            <a class="dropdown-item" href="../document/architect_045.html">IAC</a>
            <a class="dropdown-item" href="../document/architect_043.html">Kuberneties</a>
            <a class="dropdown-item" href="../document/architect_034.html">MVC</a>
            <a class="dropdown-item" href="../document/architect_049.html">MSA</a>
            <a class="dropdown-item" href="../document/architect_044.html">MOM</a>
            <a class="dropdown-item" href="../document/architect_039.html">PAAS</a>
            <a class="dropdown-item" href="../document/architect_035.html">REST API</a>
            <a class="dropdown-item" href="../document/architect_046.html">SAAS</a>
            <a class="dropdown-item" href="../document/architect_040.html">SCA</a>
            <a class="dropdown-item" href="../document/architect_042.html">SOA</a>
            <a class="dropdown-item" href="../document/architect_041.html">TDD(DDD)</a>
            <a class="dropdown-item" href="../document/architect_048.html">Web Cache</a>
            <a class="dropdown-item" href="../document/architect_050.html">Various Pattern</a>
            <a class="dropdown-item" href="../document/architect_055.html">Hexagonal Architecture</a>
            <a class="dropdown-item" href="../document/architect_056.html">Visualizing Architecture</a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>
            <li class="breadcrumb-item active">Proxy</li>
          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
                Proxy 
            </div>
            <div class="card-body">
                
              <p class="card-text">

                  <div class="accordion" id="accordionExample">
                      <div class="card">
                        <div class="card-header" id="headingOne">
                          <h2 class="mb-0">
                            <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapseOne" aria-expanded="true" aria-controls="collapseOne">
                              의도 
                            </button>
                          </h2>
                        </div>
                        <div id="collapseOne" class="collapse" aria-labelledby="headingOne" data-parent="#accordionExample">
                          <div class="card-body">
                            다른 객체에 대한 접근을 제어하기 위한 대리자 또는 자리 채움자 역할을 하는 객체를 둡니다.
                          </div>
                        </div>
                      </div>
                      <div class="card">
                        <div class="card-header" id="headingTwo">
                          <h2 class="mb-0">
                            <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseTwo" aria-expanded="false" aria-controls="collapseTwo">
                              동기
                            </button>
                          </h2>
                        </div>
                        <div id="collapseTwo" class="collapse" aria-labelledby="headingTwo" data-parent="#accordionExample">
                          <div class="card-body">
                            <ul>
                              <li>
                                어떤 객체에 대한 접근을 제어하는 한 가지 이유는 실제로 그 객체를 사용할 수 있을 때까지 객체 생성과 초기화에 들어가는 비용 및 시간을 물지 않겠다는 것입니다. 
                                그래픽 객체를 문서 안에 넣을 수 있는 문서 편집기의 예를 다시 생각해 봅시다. 
                                래스터 이미지와 같은 그래픽 객체를 생성하려면 비용이 많이 듭니다. 그러나 문서를 읽어내는 것은 이런 그래픽 객체가 있든 없든 매우 빠르게 진행되어야 합니다. 
                                또한 문서가 읽히는 그 시점에서 모든 내용을 다 읽어올 필요는 없습니다. 이미지의 모든 내용이 한꺼번에 한 문서에 다 보일 필요는 없기 때문입니다. 
                              </li>
                              <li>
                                이런 제약 사항들로 생성이나 관리가 어려운 객체라면 꼭 필요한 때에만 이 객체를 생성하도록 하는 방법이 제기되었습니다. 그러나 이미지가 찍힐 자리에 어떤
                                내용을 채워넣을 수 있을까요? 이 이미지가 필요할 때만 생성된다는 사실을 감추면서 어떻게 전체 편집기의 구현을 복잡하게 만들지 않을 수 있을까요? 이런 
                                최적화가 렌더링 혹은 서식 설정 코드에 영향을 주어서도 안됩니다. 
                              </li>
                            </ul>
                            <hr>
                              위의 동기에 대한 해결책은 실제 이미지의 대역을 맡을 이미지 프록시라는 또 다른 객체를 사용하는 것입니다. 프록시는 이미지 처럼 동작하고, 필요할 때 
                              이미지의 인스턴스를 만들어 냅니다. 
                            <hr>
                            <div class="alert alert-info" role="alert">
                              이미지 프록시는 문서 편집기가 실제로 Draw() 연산을 통해서 화면에 그리기 원할 때만 실제 이미지를 생성합니다. 프록시는 자신이 받는 메세지를 
                              실제 이미지에 전달하고 이미지 생성후 이미지에 대한 참고를 계속 유지해야 합니다. 
                              <hr>
                              이미지가 다른 파일에 저장되어 있다면 실제 객체에 대한 참조자로 파일 이름을 관리하면 됩니다. 또한 프록시는 자신이 책임져야할 이미지의 넓이와 높이를
                              한계 정보로 관리합니다. 이는 이미지의 실제적인 인스턴스 없이도 문서가 관리해야하는 이미지의 크기에 대한 요청을 처리할 수 있게 됩니다. 
                              즉, 문서를 읽을 때 이미지 자리에 일단 이미지 크기 만큼 정보다 있다는 정도는 알려줘야 한다는 것입니다. 
                            </div>
                          </div>
                        </div>
                      </div>
                      <div class="card">
                        <div class="card-header" id="headingThree">
                          <h2 class="mb-0">
                            <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseThree" aria-expanded="false" aria-controls="collapseThree">
                              활용성
                            </button>
                          </h2>
                        </div>
                        <div id="collapseThree" class="collapse" aria-labelledby="headingThree" data-parent="#accordionExample">
                          <div class="card-body">
                              <img src="../document/Proxy.png" class="img-fluid" alt="">
                              <hr>
                              <ul>
                                <li>
                                   원격지 프록시 ( Remote Proxy )
                                   <hr>
                                  서로 다른 주소 공간에 존재하는 객체를 가리키는 대표 객체 
                                </li>
                                <hr>
                                <li>
                                    가상 프록시 ( Virtual Proxy )
                                    <hr>
                                    요청이 있을 때만 고비용 객체를 생성합니다. 
                                </li>
                                <hr>
                                <li>
                                    보호용 프록시 (Protection Proxy)
                                    <hr>
                                    원래 객체에 대한 실제 접근을 제어 합니다. 
                                </li>
                                <hr>
                                <li>
                                    스마트 참조자 (Smart Reference)
                                    <hr>
                                    실제 객체에 접근이 일어날 때 추가적인 행동을 수행합니다.
                                </li>
                                <hr>
                              </ul>
                          </div>
                        </div>
                      </div>
                      <div class="card">
                          <div class="card-header" id="headingFour">
                            <h2 class="mb-0">
                              <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseFour" aria-expanded="false" aria-controls="collapseFour">
                               항목에 대한 설명
                              </button>
                            </h2>
                          </div>
                          <div id="collapseFour" class="collapse" aria-labelledby="headingFour" data-parent="#accordionExample">
                            <div class="card-body">
                                <div class="card" >
                                  <div class="card-body">
                                      <h5 class="card-title">Proxy</h5>
                                      <h6 class="card-subtitle mb-2 text-muted">Image Proxy</h6>
                                      <p class="card-text">
                                          <ul>
                                            <li>
                                              실제로 참조할 대상에 대한 참조자를 관리합니다. Real Subject 와 Subject 인터페이스가 동일하면 프록시는 Subject에 대한 
                                              참조자를 갖습니다. 
                                            </li>
                                            <li>
                                              Subject와 동일한 인터페이스를 제공하여 실제 대상을 대체할 수 있어야 합니다. 
                                            </li>
                                            <li>
                                              실제 대상에 대한 접근을 제어하고 실제 대상의 생성과 삭제를 책임집니다. 
                                            </li>
                                            <li>
                                              <ul>
                                                <li>
                                                  원격지 프록시 : 요청 메세지와 인자를 인코딩 하여 이를 다른 주소 공간에 있는 실제 대상에게 전달합니다. 
                                                </li>
                                                <li>
                                                  가상의 프록시 : 실제 대상에 대한 추가적 정보를 보유하여 실제 접근을 지연할 수 있도록 해야합니다. 
                                                </li>
                                                <li>
                                                  보호용 프록시 : 요청한 대상이 실제 요청할 수 있는 권한이 있는지 확인합니다. 
                                                </li>
                                              </ul>
                                            </li>
                                          </ul>
                                      </p>
                                  </div>
                                </div> 
                                <div class="card" >
                                  <div class="card-body">
                                      <h5 class="card-title">Subject</h5>
                                      <h6 class="card-subtitle mb-2 text-muted">Graphic</h6>
                                      <p class="card-text">
                                        RealSubject와 Proxy에 공통적인 인터페이스를 정의하여, RealSubject가 요청되는 곳에 Proxy를 사용할 수 있게 합니다. 
                                      </p>
                                  </div>
                                </div> 
                                <div class="card" >
                                  <div class="card-body">
                                      <h5 class="card-title">RealSubject</h5>
                                      <h6 class="card-subtitle mb-2 text-muted">Image</h6>
                                      <p class="card-text">
                                        프록시가 대표하는 실제 객체 입니다.   
                                      </p>
                                  </div>
                                </div>
                            </div>
                          </div>
                        </div>
                        <div class="card">
                            <div class="card-header" id="heading5">
                              <h2 class="mb-0">
                                <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse5" aria-expanded="false" aria-controls="collapse5">
                                 결과 
                                </button>
                              </h2>
                            </div>
                            <div id="collapse5" class="collapse" aria-labelledby="heading5" data-parent="#accordionExample">
                              <div class="card-body">
                                  프록시 패턴은 어떤 객체에 접근할 때 추가적인 간접화 통로를 제공합니다. 이렇게 추가된 간접화 통로는 프록시의 종류에 따라서 
                                  여러가지 쓰임새가 있습니다. 
                                  <hr>
                                  <ul>
                                    <li>원격지 프록시는 객체가 다른 주소 공간에 존재한다는 사실을 숨길 수 있습니다.</li>
                                    <li>가상 프록시는 요구에 따라 객체를 생성하는 등 처리를 최적화 할 수 있습니다.</li>
                                    <li>보호용 프록시 및 스마트 참조자는 객체가 접근할 때 마다 추가 관리를 책임 집니다. 객체를 생성할 것인지 삭제할 것인지를 관리합니다. </li>
                                    <li>기록 시점 복사 : 이 최적화는 요구가 들어올 때만 객체를 생성하는 개념과 관련있는데, 덩치가 크고 복잡한 객체를 복사하려면 비용이 만만치 않습니다. 
                                      만약, 사본이 변경되지 않고 원본과 똑같다면, 굳이 이 비용을 물 필요가 없습니다. 프록시를 사용해서 복사 절차를 미룸으로써, 사본이 수정될 때만 실제 
                                      복사 비용을 물게 만드는 것입니다. 
                                    </li>
                                    <li>
                                      프록시에서 중요한 부분 중의 하나는 흐름제어만 할 뿐 결과값을 조장하거나 변경시키면 안됩니다. 
                                    </li>
                                  </ul>
                              </div>
                            </div>
                          </div>
                        <div class="card">
                            <div class="card-header" id="headingFive">
                              <h2 class="mb-0">
                                <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseFive" aria-expanded="false" aria-controls="collapseFive">
                                 코드 예제 #1
                                </button>
                              </h2>
                            </div>
                            <div id="collapseFive" class="collapse" aria-labelledby="headingFive" data-parent="#accordionExample">
                              <pre>
                                <code class="java" >
package DesignPattern.gof_proxy.sample01;

public class OrderMain {

    public static void main(String[] args) throws Exception {

        OrderExecutor orderExecutor = new OrderExecutorProxy();

        orderExecutor.callOrder("커피요청");
    }
}                                 
                                </code>
                              </pre>
                              <hr>
                              <hr>
                              <pre>
                                <code class="Java" >
package DesignPattern.gof_proxy.sample01;

public interface OrderExecutor {
    public void callOrder(String requestName) throws Exception;
}

package DesignPattern.gof_proxy.sample01;

public class CoffeOrder implements OrderExecutor {
    public void callOrder(String requestName) throws Exception {
        System.out.println(requestName + " is waiting for receiving result.");
    }
}

package DesignPattern.gof_proxy.sample01;

public class OrderExecutorProxy implements OrderExecutor {

    private OrderExecutor orderExecutor;

    public OrderExecutorProxy(){
        orderExecutor = new CoffeOrder();
    }

    public void callOrder(String requestName) throws Exception {
        System.out.println("커피를 요청 하기 위한 사전 작업 진행 !");

        orderExecutor.callOrder(requestName);

        System.out.println("커피를 전달 받아 추가 작업 진행 !");
    }
}                                           
                                </code>
                              </pre>
                          </div>
                        </div>

                        <div class="card">
                          <div class="card-header" id="headingSix">
                            <h2 class="mb-0">
                              <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapseSix" aria-expanded="false" aria-controls="collapseSix">
                                코드 예제 #2
                              </button>
                            </h2>
                          </div>
                          <div id="collapseSix" class="collapse" aria-labelledby="headingSix" data-parent="#accordionExample">
                            <div class="card-body">
<pre>
  <code class="java" >
package DesignPattern.gof_proxy.sample02;

import java.sql.SQLException;

public class SQLCaller {
    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        JDBCExecutor jdbcExecutor = new JDBCExecutorProxy(new SelectExecutor());

        jdbcExecutor.executeQuery("SELECT * FROM USERS;");
    }
}    
  </code>
</pre>
<pre>
    <code class="java" >


// STMTExecutor
package DesignPattern.gof_proxy.sample02;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;

public interface STMTExecutor {

    public ResultSet executeSTMT(String SQL, Connection connection) throws SQLException;
}

// SelectExecutor
package DesignPattern.gof_proxy.sample02;

import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;

public class SelectExecutor implements STMTExecutor {

    /**
     * STMT를 실행하는 함수
     * @param SQL
     * @param connection
     * @return
     * @throws SQLException
     */
    public ResultSet executeSTMT(String SQL, Connection connection) throws SQLException {
        ResultSet rs;
        Statement statement = connection.createStatement();

        try{
            rs = statement.executeQuery(SQL);
        }finally {
            statement.close();
        }

        return rs;
    }
}


// JDBCExecutor
package DesignPattern.gof_proxy.sample02;

import java.sql.SQLException;

public interface JDBCExecutor {

    public void executeQuery(String SQL) throws SQLException, ClassNotFoundException;
}


// JDBCExecutorProxy
package DesignPattern.gof_proxy.sample02;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;

public class JDBCExecutorProxy implements JDBCExecutor {

    private static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";
    private static final String DB_URL = "jdbc:mysql://localhost/EMP";

    private static final String USER = "username";
    private static final String PASS = "password";

    STMTExecutor stmtExecutor;

    public JDBCExecutorProxy(STMTExecutor stmtExecutor) {
        this.stmtExecutor = stmtExecutor;
    }

    /**
     * SQL을 실행하는 Proxy 함수
     * @param SQL
     * @throws SQLException
     */
    public void executeQuery(String SQL) throws SQLException , ClassNotFoundException{

        Class.forName(JDBC_DRIVER);

        Connection conn =  DriverManager.getConnection(DB_URL, USER, PASS);
        ResultSet rs = stmtExecutor.executeSTMT(SQL, conn);

        try{
            rs.beforeFirst();
            while (rs.next()) {
                //Retrieve by column name
                int id = rs.getInt("id");
                String first = rs.getString("first");
                System.out.print("ID: " + id);
                System.out.print(", First: " + first);
            }
        }finally {
            rs.close();
            conn.close();
        }
    }
}

        
    </code>
</pre>
                            </div>
                          </div>
                        </div>
                        <div class="card">
                          <div class="card-header" id="heading7">
                            <h2 class="mb-0">
                              <button class="btn btn-link collapsed" type="button" data-toggle="collapse" data-target="#collapse7" aria-expanded="false" aria-controls="collapse7">
                                문제를 풉시다.  제한시간 : 30분 
                              </button>
                            </h2>
                          </div>
                          <div id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#accordionExample">
                            <div class="card-body">
                                Java의 리플렉션 및 JDBC Library를 활용하여 Aspect Of Programming에 따라 Transaction 내에서 DB를 실행하는 프로세스를 작성하라.  <br>
                                PostgreSQL DB를 이용해서 테이블을 생성하라 <br>
                                테이블 명 : STUDY <br>
                                컬럼명    : SUBJECT ( VARCHAR2(20) ), TYPE( VARCHAR2(10) ), CONTENT( VARCHAR2(30) ), USE_YN ( VARCHAR2(1) ) <br>
                                제약조건   : Primary Key - SUBJECT <br>
                                위의 테이블을 생성하고 정보를 저장, 수정, 삭제 프로세스를 넣습니다. <br>
                                메소드명 : InsertStudy, UpdateStudy, DeleteStudy <br>
                                각각의 메소드가 실행될 때 프록스 패턴에 따라서 해당 자바 메소드가 Transaction 범위에서 실행되게 하되, Java 리플렉션을 이용헤서 메소드를 동적으로 <br>
                                실행시킬 수 있게, Class 내의 메소드가 실행될 경우 자동으로 Proxy 패턴이 호출될 수 있도록하라. <br>
                                예를 들어, InsertStudy 메소드가 실행되면 자동으로 Transaction 범위에서 해당 메소드가 실행되어야 한다. <br>
                                에러가 발생하였을 경우 Role Back이 일어나야 한다. <br>
                              <hr>
                              <span id="time1" ></span>
                                <a  id="btnStart" class="btn btn-primary">코드 시작! 30분</a>
                            </div>
                          </div>
                        </div>
                    </div>
                </p>
            </div>
        </div>
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
 

    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Page level plugin JavaScript-->
    <script src="../vendor/chart.js/Chart.min.js"></script>

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>

    <!-- Demo scripts for this page-->
    <script src="../js/demo/chart-area-demo.js"></script>
    <script src="../js/demo/chart-bar-demo.js"></script>
    <script src="../js/demo/chart-pie-demo.js"></script>

  </body>

</html>
