<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1Lines - Clean Code</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="../index.html">Clean Code</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      <form class="d-none d-md-inline-block form-inline ml-auto mr-0 mr-md-3 my-2 my-md-0">
        <div class="input-group">
          <input type="text" class="form-control" placeholder="Search for..." aria-label="Search" aria-describedby="basic-addon2">
          <div class="input-group-append">
            <button class="btn btn-primary" type="button">
              <i class="fas fa-search"></i>
            </button>
          </div>
        </div>
      </form>

      <!-- Navbar -->
      <ul class="navbar-nav ml-auto ml-md-0">
        <li class="nav-item dropdown no-arrow mx-1">
          <a class="nav-link dropdown-toggle" href="#" id="alertsDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-bell fa-fw"></i>
            <span class="badge badge-danger">9+</span>
          </a>
          <div class="dropdown-menu dropdown-menu-right" aria-labelledby="alertsDropdown">
            <a class="dropdown-item" href="#">Action</a>
            <a class="dropdown-item" href="#">Another action</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="#">Something else here</a>
          </div>
        </li>
        <li class="nav-item dropdown no-arrow mx-1">
          <a class="nav-link dropdown-toggle" href="#" id="messagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-envelope fa-fw"></i>
            <span class="badge badge-danger">7</span>
          </a>
          <div class="dropdown-menu dropdown-menu-right" aria-labelledby="messagesDropdown">
            <a class="dropdown-item" href="#">Action</a>
            <a class="dropdown-item" href="#">Another action</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="#">Something else here</a>
          </div>
        </li>
        <li class="nav-item dropdown no-arrow">
          <a class="nav-link dropdown-toggle" href="#" id="userDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-user-circle fa-fw"></i>
          </a>
          <div class="dropdown-menu dropdown-menu-right" aria-labelledby="userDropdown">
            <a class="dropdown-item" href="#">Settings</a>
            <a class="dropdown-item" href="#">Activity Log</a>
            <div class="dropdown-divider"></div>
            <a class="dropdown-item" href="#" data-toggle="modal" data-target="#logoutModal">Logout</a>
          </div>
        </li>
      </ul>

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="../index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu show" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">Clean Code</h6>
            <a class="dropdown-item" href="../cleancode/cleancode_001.html">코딩 기본</a>
            <a class="dropdown-item" href="../cleancode/cleancode_002.html">객체자료/예외/경계</a>
            <a class="dropdown-item" href="../cleancode/cleancode_003.html">클래스</a>
            <a class="dropdown-item" href="../cleancode/cleancode_004.html">시스템</a>
            <a class="dropdown-item" href="../cleancode/cleancode_005.html">테스트</a>
            <a class="dropdown-item" href="../cleancode/cleancode_006.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_007.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_008.html"></a>          
            <a class="dropdown-item" href="../cleancode/cleancode_009.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_010.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_011.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_012.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_013.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_014.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_015.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_016.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_017.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_018.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_019.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_020.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_021.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_022.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_023.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_024.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_025.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_026.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_027.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_028.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_029.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_030.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_031.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_032.html"></a>
            <a class="dropdown-item" href="../cleancode/cleancode_033.html"></a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>
            <li class="breadcrumb-item active">Clean Code</li>
          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
            </div>
            <div class="card-body">
              <div class="accordion" id="accordionExample">
                <div class="card">
                  <div class="card-header" id="heading1">
                    <h2 class="mb-0">
                      <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse1" aria-expanded="true" aria-controls="collapse1">
                        자료추상화 
                      </button>
                    </h2>
                  </div>
              
                  <div id="collapse1" class="collapse" aria-labelledby="heading1" data-parent="#accordionExample">
                    <div class="card-body">
                        변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다. <br>
                        구현을 감추려면 추상화가 필요하다! <br>
                        그저 조회함수와 설정 함수로 변수를 다룬다고 클래스가 되지는 않는다. <br>
                        그보다는 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다. <br>
                        <strong>자료를 세세하게 공개하기 보다는 추상적인 개념으로 표한하는 편이 좋다. <br>
                          
                          아무 생각 없이 조회/설정 함수를 추가하는 방법이 가장 나쁘다.</strong>
                      <hr>
                      <pre>
                        <code class="Java" >
  public interface Vehicle {
    double getPercentFuelRemaining();
  }
                        </code>
                      </pre>  
                    </div>
                  </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading2">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse2" aria-expanded="true" aria-controls="collapse2">
                      객체의 대칭/비대칭
                    </button>
                  </h2>
                </div>
            
                <div id="collapse2" class="collapse" aria-labelledby="heading2" data-parent="#accordionExample">
                  <div class="card-body">
                      절차지향과 객체지향은 상호 보완적인 관계가 존재한다. 
                    <hr>
                    <ul>
                      <li>(자료 구조를 사용하는) 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체지향 코드는 기본 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다.</li>
                      <li>절차지향 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 모든 클래스를 고쳐야 한다. </li>
                    </ul>
                    <hr>
                      정리하면, 객체 지향 코드에서 어려운 변경은 절차적인 코드에서 쉬우며, 절차적인 코드에서 어려운 변경은 객체 지향 코드에서 쉽다.!
                    <hr>

                    객체는 동작을 공개하고 자료를 숨긴다. 그래서 기본 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면에 기존의 객체에 새 동작을 추가하기는 어렵다.<br>
                     자료구조는 별다른 동작없이 자료를 노출한다. <br> 
                    그래서 기존 자료구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다. <br>
                    시스템을 구현할 때, <br>
                    <strong>
                    새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. <br>
                    다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료구조와 절차적인 코드가 더 적합하다. <br>
                  </strong>
                    <hr>
                    <strong>절차지향 </strong>
                    <pre>
                      <code class="Java" >
public class Square {
  public Point topLeft;
  public double side;
}

public class Rectangle {
  public Point topLeft;
  public double height;
  public double width;
}

public class Circle {
  public Point center;
  public double radius;
}

public class Geometry {
  public final double PI = 3.141592653589793;

  public double area(Object shape) throws NoSuchShapeException {
    if( shape instanceof Square ){
      Square s = (Square)shape;
      return s.side * s.side;
    }
    else if ( shape instanceof Rectangle) {
      Rectangle r = (Rectangle)shape;
      return r.height * r.width;
    }
    else if ( shape instanceof Circle) {
      Circle c = (Circle)shape;
      return PI * c.radius * c.radius;
    }

    throw new NoSuchShapeException();
  }
}
                      </code>
                    </pre>  
                    <hr>
                    <strong>객체지향</strong>
                    <pre>
                      <code class="Java" >
public class Square implements Shape {
  private Point topLeft;
  private double side;

  public double area(){
    return side * side;
  }
}

public class Rectangle implements Shape {
  private Point topLeft;
  private double height;
  private double width;

  public double area() {
    return height * width;
  }
}

public class Circle implements Shape {
  private Point center;
  private double radius;
  public final double PI = 3.141592653589793;

  public double area() {
    return height * width;
  }
}
                      </code>
                    </pre>  
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading3">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse3" aria-expanded="true" aria-controls="collapse3">
                      절차지향 시에 고려할 수 있는 대안 
                    </button>
                  </h2>
                </div>
            
                <div id="collapse3" class="collapse" aria-labelledby="heading3" data-parent="#accordionExample">
                  <div class="card-body">
                    노력한 객체 지향 설계자는 VISITOR 혹은 Dual-Patch 등과 같이 잘 알려진 기법을 사용해 이 문제를 해결한다. <br>
                    하지만 이들 기법 역시 대가가 따르며, 일반적으로 절차적인 프로그램에서 볼수 있는 구조를 반환한다. 
                    <hr>
                    <p>
                      <Strong>Visitor Pattern</Strong> <br>
                      GOF : 객체 구조를 이루는 원소에 대해 수행할 연산을 표현하는 패턴으로, 연산을 적용할 원소의 클래스를 변경하지 않고도 새로운 연산을 정의할 수 있게 합니다.<br>
                      알고리즘을 객체 구조에서 분리시키는 방법 
                    </p>
                    <pre>
                      <code class="java">
public class VisitorDemo {
    static public void main(String[] args){
        // 사업
        Business business = new Business();
        // 전체 사업의 틀에서 어떤 분야를 상세하게 진행할 것인지 
        business.accept(new HospitalBusiness());
        business.accept(new AirplanBusiness());
    }
}

class Plan implements BusinessStructure{
  public void accept(BusiVisitor busiVisitor){
    busiVisitor.visit();
  }
}

class Meeting implements BusinessStructure {
  public void accept(BusiVisitor busiVisitor){
    busiVisitor.visit();
  }
}

class Business implements BusinessStructure {

  private ArrayList&lt;BusinessStructure> elements = null;

  public void AddStartegy(BusiVisitor busiVisitor){
    elements.add(elements);
  }

  public void accept(BusiVisitor busiVisitor){
    for(BusinessStructure busiStrategy : elements ){
      busiStrategy.visit();
    }
    busiVisitor.visit();
  }
}
                      </code>
                    </pre>
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading4">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse4" aria-expanded="true" aria-controls="collapse4">
                      디미터의 법칙 
                    </button>
                  </h2>
                </div>
            
                <div id="collapse4" class="collapse" aria-labelledby="heading4" data-parent="#accordionExample">
                  <div class="card-body">
                    <p>
                      <Strong>디미터 법칙</Strong><br>
                      모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. <br>
                      클래스의 성향이 자료구조냐, 객체냐에 따라 달라짐 <br>
                      객체일 경우, 추상적일 필요가 있음 <br>
                        - 뭔가를 하려고 이야기를 해야지 속을 드러내서 표현하면 안됨. 
                    </p>
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading5">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse5" aria-expanded="true" aria-controls="collapse5">
                       기차 충돌
                    </button>
                  </h2>
                </div>
            
                <div id="collapse5" class="collapse" aria-labelledby="heading5" data-parent="#accordionExample">
                  <div class="card-body">
                    <pre>
                      <code class="Java" >
final string outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath();
                      </code>
                    </pre>  
                    <hr>
                    흔히 위와 같은 코드를 기차 충돌이라 부른다. <br>
                    일반적으로 조잡하다고 여겨지는 방식이므로 피하는 편이 좋다. <br>
                    따라서 아래와 같이 작성하는 것이 더욱 좋다. <br>
                    <hr>
                    <pre>
                      <code class="Java" >
Options opts = ctxt.getOptions();
File scratchDir = opts.getScratchDir();
final String outputDir = scratchDir.getAbsolutePath();
                      </code>
                    </pre>
                    <hr>
                    위의 예제가 디미터 법칙을 위반하는지 여부는 ctxt, Options, scratchDir 이 객체인지 아니면 자료 구조인지에 달렸다. <br>
                    객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다. 반면, 자료 구조라면 당연히 내부 구조를 노출하므로 <br>
                    디미터 법칙이 적용되지 않는다. 
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading6">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse6" aria-expanded="true" aria-controls="collapse6">
                       잡종 구조
                    </button>
                  </h2>
                </div>
            
                <div id="collapse6" class="collapse" aria-labelledby="heading6" data-parent="#accordionExample">
                  <div class="card-body">
                    잡속 구조는 중요한 기능을 수행하는 함수도 있고, 공개 변수나 공개 조회/설정 함수도 있다. <br>
                    공개 조회/설정 함수는 비공개 변수를 그대로 노출한다. 
                    <hr>
                    <pre>
                      <code class="Java" >
String outFile = outputDir + "/" + className.replace('.','/') + ".class";
FileOutputStream fout = new FileOutputStream(outFile);
BufferedOutputStream bos = new BufferedOutputStream(fout);

// 위의 구조보다 아래의 구조가 디미터의 법칙을 위반하지 않는 객체 자료구조를 가지게 된다. 
BufferedOutputStream box = ctxt.createScratchFileStream(classFileName);
                      </code>
                    </pre>
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading7">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse7" aria-expanded="true" aria-controls="collapse7">
                      자료 전달 객체 
                    </button>
                  </h2>
                </div>
            
                <div id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#accordionExample">
                  <div class="card-body">
                    자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 이런 자료 구조체를 때로는 자료 전달 객체라 한다. <br>
                    DTO 는 굉장히 유용한 구조체다. 특히 데이터 베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다. <br>
                    <hr>
                    <ul>
                      <li>
                        DAO ( Data Access Object) : DB를 사용해 데이터를 조회하거나 조작하는 기능을 전담하도록 만든 오브젝트  
                      </li>
                      <li>
                        DTO ( Data Transfer Object ) : VO로 바꿔 말할 수 있는데, 계층간 데이터 교환을 위한 자바빈즈를 말한다. 여기서 말하는 계층간의 컨트롤러,뷰,비즈니스계층을 말하며 각 계층 간의 데이터 교환을 위한 객체 
                      </li>
                    </ul>
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading8">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse8" aria-expanded="true" aria-controls="collapse8">
                      오류 코드 보다는 예외를 사용하라. 
                    </button>
                  </h2>
                </div>
            
                <div id="collapse8" class="collapse" aria-labelledby="heading8" data-parent="#accordionExample">
                  <div class="card-body">
                    코드가 확실히 깨끗해질 수 있다. 앞서 뒤섞였던 개념, 즉 디바이스를 종료하는 알고리즘과 오류를 처리하는 알고리즘을 분리했다. 
                    <hr>
                    <pre>
                      <code class="Java" >
private DeviceHandle getHandle(DeviceId id){
  ... 
  throw new DeviceShutdownError("Invalid handle for : " + id.toString());
  ... 
}
                      </code>
                    </pre>  
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading9">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse9" aria-expanded="true" aria-controls="collapse9">
                      Try-Catch-Finally 문부터 작성하라 
                    </button>
                  </h2>
                </div>
            
                <div id="collapse9" class="collapse" aria-labelledby="heading9" data-parent="#accordionExample">
                  <div class="card-body">
                      예외에서 프로그램 안에다 범위를 정의한다는 사실은 매우 흥미롭다. <br>
                      try-catch-finally 문에서 try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후 catch 블록으로 넘어갈 수 있다. 
                    <hr>
                      어떤 면에서 try 블록은 트랜잭션과 비슷하다. try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. <br>
                      그러므로 예외악 발생할 코드를 짤 때는 try-catch-finally 문으로 시작하는 편이 낫다. <br>
                      그러면 try 블록에서 무슨일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다. 
                    <hr>
                     먼저 <strong> 강제로 예외를 일으키는 테스트 케이스를 작성한 후 테스트를 통과하게 코드를 작성하는 방법</strong>을 권장한다. <br>
                     그러면 자연스럽게 try 블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다. <br>
                    <pre>
                      <code class="Java" >
@Test(expected = StorageException.class)
public void retrieveSectionShouldThrowOnInvalidFileName(){
  sectionStore.retrieveSection("invalide - file");
}         

public List&lt;RecordedGrip> retrieveSection(String sectionName){
  try{
    FileInputStream stream = new FileInputStream(sectionName);
    stream.close();
  }catch(FileNotFoundException e){
    throw new StorageException("retrieval error", e);
  }
  return new ArrayList&lt;RecordedGrip>();
}
                      </code>
                    </pre>  
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading10">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse10" aria-expanded="true" aria-controls="collapse10">
                      미확인 예외를 사용하라. 
                    </button>
                  </h2>
                </div>
            
                <div id="collapse10" class="collapse" aria-labelledby="heading10" data-parent="#accordionExample">
                  <div class="card-body">
                      확인된 예외는 OCP를 위반한다. 메서드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메서드 모두가 선언부에 해당 예외를 정의해야 한다. <br>
                      즉, 하위 단계에서 코드를 변경하면 상위 단계 메서드 선언부를 전부 고쳐야 한다는 말이다. 확인된 예외를 위해서 메서드에 선언하는 구체적인 예외는 캡슐화를 깨트린다. <br>
                    
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading11">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse11" aria-expanded="true" aria-controls="collapse11">
                      예외에 의미를 제공하라. 
                    </button>
                  </h2>
                </div>
            
                <div id="collapse11" class="collapse" aria-labelledby="heading11" data-parent="#accordionExample">
                  <div class="card-body">
                     예외를 던질때는 전수 상황을 충분히 덧 붙인다. 그러면 오류가 발생한 원인과 위치를 찾기가 쉬워진다. 자바는 모든 예외에 호출 스택을 제공한다. 하지만 <br>
                     실패한 코드의 의도를 파악하라면 호출 스택 만으로 부족하다. 오류 메세지에 정보를 담아 예외와 함께 던진다. <br>
                     실패한 연산 이름과 실패 유형도 언급한다. 
                    
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading12">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse12" aria-expanded="true" aria-controls="collapse12">
                      호출자를 고려해 예외 클래스를 정의하라. 
                    </button>
                  </h2>
                </div>
            
                <div id="collapse12" class="collapse" aria-labelledby="heading12" data-parent="#accordionExample">
                  <div class="card-body">
                    호출하는 라이브러리 API를 감싸면서 예외 유형을 하나만 반환하는 방식의 처리 방법이 효율적이다. <br>
                    아래와 같이 외부 API를 사용할 때는 감싸기 기법이 최선이다 ( Adapter 패턴 ). 외부 API를 감싸면 외부 라이브러리와의 의존성이 크게 줄어든다. <br>
                    나중에 다른 라이브러리로 갈아타도 비용이 적다. <br> 
                    감싸기 기법을 사용하면 특정 업체가 API를 설계한 방식에 발목 잡히지 않는다. 프로그램이 사용하기 편한 API를 정의하면 그만이다. 
                    <hr>
                    <pre>
                      <code class="Java" >
LocalPort port = new LocalPort(12);

try {
  port.open();
} catch(PortDeviceFailure e){
  reportError(e);
  logger.log(e.getMessage(), e);
} finally {
  ...
}


public class LocalPort {
  private ACMEPort innerPort;

  public LocalPort(int portNumber){
    innerPort = new ACMEPort(portNumber);
  }
}

public void open(){
  try {
    innerPort.open()
  } catch (DeviceResponseException e) {
    throw new PortDeviceFailure(e);
  } catch ( ATM1212UnlockedException e) {
    throw new PortDeviceFailure(e);
  } catch ( GMXError e) {
    throw new PortDeviceFailure(e);    
  } 
  ...
}
                      </code>
                    </pre>  
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading13">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse13" aria-expanded="true" aria-controls="collapse13">
                      정상 흐름을 정의하라.
                    </button>
                  </h2>
                </div>
            
                <div id="collapse13" class="collapse" aria-labelledby="heading13" data-parent="#accordionExample">
                  <div class="card-body">
                    예외에서 코드를 작성하면 예외로 인해서 논리를 따라가기가 어렵다. 
                    <pre>
                      <code class="Java" >
// 해당 소스는 로직에 대한 처리를 예외에서 처리하여 분석시 혼란이 가중될 수 있다.                         
try {
  ShoppingExpenses expenses = expenseDAO.getShoppingPrice(shopping.getProductId());
  m_total += expenses.getTotalPrice();
}catch(ShoppingExceptionNotFound e){
  m_total += getExpenseForEntryFee;
}

// 위와 같은 코드는 ShoppingExpenses 객체를 구현하는 클래스를 생성하여 예외가 아닌 정상흐름에서 값을 반환한다. 
public class ExpenseForEntryFee implements ShoppingExpenses {
  public int getTotalPrice(){
      // 쇼핑 내역이 없을 경우, 입장료만 반환한다. 
  }
}
                      </code>
                    </pre>
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading14">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse14" aria-expanded="true" aria-controls="collapse14">
                        null을 반환하지 마라.
                    </button>
                  </h2>
                </div>
            
                <div id="collapse14" class="collapse" aria-labelledby="heading14" data-parent="#accordionExample">
                  <div class="card-body">
                      오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 <br>
                      튼튼하고 깨끗한 코드를 작성할 수 있다. 
                      <hr>
                      기본적으로 null을 사용할 경우 null을 반환받는 로직에서 null에 대한 체크 불가피하게 반드시 들어가게 된다. <br>
                      이와 같을 때 기본적으로 개발자는 NullPointerException에 대한 두려움이 생길 수 밖에 없다. <br>
                      <strong>메서드에서 null을 반환하고픈 유폭이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 구현한다. </strong>
                      <hr>
                      <pre>
                        <code class="Java" >
public List&lt;Employee> getEmployees() {
  if ( .. 직원이 없다면 .. ) 
    return Collections.emptyList();
}
                        </code>
                      </pre>
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading15">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse15" aria-expanded="true" aria-controls="collapse15">
                      null을 전달하지 마라. 
                    </button>
                  </h2>
                </div>
            
                <div id="collapse15" class="collapse" aria-labelledby="heading15" data-parent="#accordionExample">
                  <div class="card-body">
                    메서드에서 null을 반환하는 방식도 나쁘지만 메서드로 null을 전달하는 방식은 더 나쁘다. <br>
                    정상적인 인수로 null을 기대하는 API가 아니라면 메서드로 null을 전달하는 코드는 최대한 피한다. <br>
                    <hr>
                    <pre>
                      <code class="Java" >
public class MoneyCalculator {
  public double xProjection(Point p1, Point p2) {
    if( p1 == null ||  p2 == null){
      throw InvalidArgumentException(
        "Invalide argument for MoneyCalculator"
      )
    } 
    return (p2.x - p1.x) * 1.5;
  }

}
                      </code>
                    </pre>
                    <hr>
                    위의 코드 또한 예외를 반환하지만 null을 전달하면 여전히 실행 홍류가 발생한다. 
                    <hr>
                    대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다. 그렇다면 애초에 null을 넘기지 못하다록 금지하는 정책이 합리적이다. 
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading16">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse16" aria-expanded="true" aria-controls="collapse16">
                        경계를 관리하기 
                    </button>
                  </h2>
                </div>
            
                <div id="collapse16" class="collapse" aria-labelledby="heading16" data-parent="#accordionExample">
                  <div class="card-body">
                    <p>
                          Map 객체를 사용할 때, 제네릭스(Generics)를 사용하면 가독성이 높아진다. 
                          <pre>
                            <code class="java">
Map&lsaquo;String, Business&rsaquo; busies = new HashMap&lsaquo;String, Business&rsaquo;()
                            </code>
                          </pre>
                      <hr>
                        하지만 Map 객체를 여기저기 파라미터로 넘겨서는 안된다. <br>
                          <pre>
                            <code class="java">
// Generics 자체를 넘기기 보다 실제 사용되어어할 클래스를 생성하여 Generics 자체는 숨긴다.                               
Public class Business {
  private Map business = new HashMap();

  public Business getByBusiness(String businessName){
    return (Business)business.get(businessName);
  }
}
                          </code>
                        </pre>
                        즉, Map을 여기저기 넘기지 말라는 이야기이다. 
                    </p>
                    <hr>
                    <p>
                      외부 API를 바로 적용하는 것이 아닌 간단한 테스트 케이스를 작성해 외부코드를 익힌다. <br>
                      <Strong>학습 테스트</Strong><br>
                      해당 모듈에 대한 별도의 테스트 케이스 모듈을 개발 <br>
                    </p>
                    <hr>
                    <p>
                      경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다. <br>
                      때로는 우리 지식이 경계를 너머 미치지 못하는 코드 영역도 있다. 외부 시스템에서 인터페이스 개발이 늦어지고, <br>
                      내부 시스템 동작을 구현해야한다면, 이때 우리는 외부와 내부의 경계를 구분하여 개발할 수 밖에 없다. <br>
                      <hr> 
                      이와 같은 경우, 우리가 아직 모르는 경계에 대해서 Adapter 패턴을 구현하고, 내부 프로세스를 설계한다. <br>
                      <img src="../document/adapter_sample003.png"  class="img-fluid"   alt="" srcset="">
                      <hr>
                      <img src="AdapterPattern.png" class="img-fluid" >
                    </p>
                      <hr>
                      Adapter 패턴은 신규 인터페이스나 외부 인터페이스 등에 대해서 기존의 시스템에 연동할 때 <br>
                      Adapter 패턴을 통해 외부의 경계를 구성하여 내부의 시스템에 최소한의 영향으로 신규 시스템 연결 시 활용할 수 있다. 
                    </p>
                    <hr>
                    <p>
                      외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리한다. <br>
                      Map에서 보았듯이, 새로운 클래스로 경계를 감싸거나 아니면 Adapter 패턴을 사용해 우리가 원하는 인터페이스를 <br>
                      패키지가 제공하는 인터페이스로 변환한다. 
                    </p>
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading17">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse17" aria-expanded="true" aria-controls="collapse17">
                      
                    </button>
                  </h2>
                </div>
            
                <div id="collapse17" class="collapse" aria-labelledby="heading17" data-parent="#accordionExample">
                  <div class="card-body">
                  </div>
                </div>
              </div>
              <div class="card">
                <div class="card-header" id="heading18">
                  <h2 class="mb-0">
                    <button class="btn btn-link" type="button" data-toggle="collapse" data-target="#collapse18" aria-expanded="true" aria-controls="collapse18">
                      
                    </button>
                  </h2>
                </div>
            
                <div id="collapse18" class="collapse" aria-labelledby="heading18" data-parent="#accordionExample">
                  <div class="card-body">
                  </div>
                </div>
              </div>
            </div>
          </div>
        <div class="card-footer small text-muted">Updated yesterday at 11:59 PM</div>
      </div>
        </div>
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © Your Website 2018</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
    <div class="modal fade" id="logoutModal" tabindex="-1" role="dialog" aria-labelledby="exampleModalLabel" aria-hidden="true">
      <div class="modal-dialog" role="cleancode">
        <div class="modal-content">
          <div class="modal-header">
            <h5 class="modal-title" id="exampleModalLabel">Ready to Leave?</h5>
            <button class="close" type="button" data-dismiss="modal" aria-label="Close">
              <span aria-hidden="true">×</span>
            </button>
          </div>
          <div class="modal-body">Select "Logout" below if you are ready to end your current session.</div>
          <div class="modal-footer">
            <button class="btn btn-secondary" type="button" data-dismiss="modal">Cancel</button>
            <a class="btn btn-primary" href="login.html">Logout</a>
          </div>
        </div>
      </div>
    </div>

    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Page level plugin JavaScript-->
    <script src="../vendor/chart.js/Chart.min.js"></script>

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>

    <!-- Demo scripts for this page-->
    <script src="../js/demo/chart-area-demo.js"></script>
    <script src="../js/demo/chart-bar-demo.js"></script>
    <script src="../js/demo/chart-pie-demo.js"></script>

  </body>

</html>
