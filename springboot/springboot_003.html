<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines - Spring Boot</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">

    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>

  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="index.html">1 Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">Spring Boot</h6>
            <a class="dropdown-item" href="../springboot/springboot_001.html">스프링 부트란?</a>
            <a class="dropdown-item" href="../springboot/springboot_002.html">스프링 프로젝트 만들기 </a>
            <a class="dropdown-item" href="../springboot/springboot_003.html">스프링 부트 활용</a>
            <a class="dropdown-item" href="../springboot/springboot_004.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_005.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_006.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_007.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_008.html"></a>          
            <a class="dropdown-item" href="../springboot/springboot_009.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_010.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_011.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_012.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_013.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_014.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_015.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_016.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_017.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_018.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_019.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_020.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_021.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_022.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_023.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_024.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_025.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_026.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_027.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_028.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_029.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_030.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_031.html">Reactive Web</a>
            <a class="dropdown-item" href="../springboot/springboot_032.html"></a>
            <a class="dropdown-item" href="../springboot/springboot_033.html"></a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>
            <li class="breadcrumb-item active">Spring Boot</li>
          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
                스프링 부트 활용 
            </div>

            <div class="card-body">
              <div class="card">
                <div class="card-header">
                  ModelAttribute, RequestParam, RequestBody
                </div>
                <div class="card-body">
                  <h5 class="card-title">GET/POST</h5>
                  <p class="card-text">
                    <hr>
                    위의 각각의 항목에 대해서 이해하기 전에 GET/POST의 방식의 차이에 대해서 이해해야 한다. 
                    <ul>
                      <li>GET 방식의 경우 URL에 데이터를 담아 전송하는 방식이다. 따라서 Request가 Controller로 전달될 때 body 영역에 데이터가 존재하지 않는다. </li>
                      <li>POST 방식의 경우 Request의 Body에 데이터를 담아 전송하는 방식이다. 따라서 Request가 Controller로 전달 될 때 body 영역에 데이터가 존재한다. </li>
                    </ul>
                  </p>
                  <h5 class="card-title">ModelAttribute</h5>
                  <p class="card-text">
                    ModelAttribute에 추가된 파라미터는 Modal 객체에 자동으로 추가가 되기 때문에 View가 생성되는 시점에 Modal에 들어있는 값을 사용할 수 있게 된다. 
                    해당 부분을 이해하지 못한채 사용하게 되면 왜 Modal을 통해 전달된 파라미터/데이터를 화면상에 엉뚱하게 표시하는 경우가 생길 수 있다. <br>
                    ModelAttribute는 서브밋된 폼의 내용을 저장해서 전달받거나, 다시 뷰로 넘겨서 출력하기 위해 사용되는 오브젝트이다. <br>
                    ModelAttribute는 @ModelAttribute를 생략한채 Map, VO 등을 사용할 수 있다. <br>
                    Controller에 정의된 Mapping URL를 HandlerAdapter에 의해 전달되는 메소드에 별도의 파라미터 Annotations을 붙이지 않을 경우, 기본이 ModelAttribute 이기 때문에 Model 에 값이 바인딩되는 부분에 대해서 주의할 것 
                  </p>
                  <h5 class="card-title">ReqeustParam</h5>
                  <p class="card-text">
                    GET URL을 통해 전달되는 파라미터를 받아서 Controller에서 사용하는 경우 활용할 수 있다. <br>
                    Request Body를 통해서 전달되는 데이터는 받을 수 없다. 
                  </p>
                  <h5 class="card-title">RequestBody</h5>
                  <p class="card-text">
                    POST URL을 통해 전달되는 파라미터를 받아서 Controller에서 사용하는 경우 활용할 수 있다. <br>
                    Request의 URL를 통해서 전달되는 파라미터는 받을 수 없고, body를 통해서 전달될 경우 해당 값이 바인딩 될 수 있다 
                  </p>                  
                </div>
                <div class="alert alert-warning" role="alert">
                  Multipart 데이터와 파라미터를 form submit을 이용해서 파라미터를 받을 때 ModelAttribute을 이용하면 Class VO를 통해서 멀티파트 파일과 추가적인 파라미터를 함께 받을 수 있다. 
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  Component Scan
                </div>
                <div class="card-body">
                  <h5 class="card-title">Component Scan에 대해서</h5>
                  <p class="card-text">
                    @Componentscan 어노테이션은 @Component 어노테이션 및 streotype(@Service, @Repository, @Controller) 어노테이션이 부여된 Class들을 자동으로 Scan 하여 
                    Bean으로 등록해주는 역할을 하는 어노테이션입니다. 
                    <pre class="java" >
                      <code>
package com.example.componentscan.repository;

import org.springframework.stereotype.Repository;

@Repository
public class CodeRepository {
}
                        
                      </code>
                    </pre>
                    <pre class="java" >
                      <code>
package com.example.componentscan;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan
public class ApplicationConfig {

}
                        
                      </code>
                    </pre>
                    <pre class="java" >
                      <code>
package com.example.componentscan;

import com.example.componentscan.repository.CodeRepository;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class ComponentscanApplication {

  public static void main(String[] args) {
    ApplicationContext context = new AnnotationConfigApplicationContext(ApplicationConfig.class);

    CodeRepository codeRepository = (CodeRepository)context.getBean("codeRepository");

    System.out.println(codeRepository != null);
  }

}                     
                      </code>
                    </pre>
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  Lombok   
                </div>
                <div class="card-body">
                  <h5 class="card-title">

                  </h5>
                  <p class="card-text">
                    <pre class="java" >
                      <code>
// 접근자, 설정자 자동 생성                        
@Getter @Setter
private String name;

user.setName("김아무개");
String userName = user.getName();

// 생성자 자동 생성 
@NoArgsConstructor
@RequiredArgsConstructor
@AllArgConstructor
pulic class Sample {
  private String name;
  @NonNull
  private String uniqueId;
  @NonNull
  private String content;
}

// ToString 메소드 자동 생성 
@ToString
pulic class Sample {
  private String name;
  private String uniqueId;
  private String content;
}

// equals, hashCode 자동 생성 
@EqualsAndHashCode(callsuper = true)
public class Sample extends SuperSample {

}

// @Getter, @Setter, @RequiredArgsConstructor, @ToString, @EqualsAndHashCode 를 
// 한꺼번에 같이 사용할 수 있도록 해주는 Annotation입니다. 
@Data
public class Sample{

}

// Immutable class 를 쉽게 만들 수 있다. 
@Value
public class Sample{

}

// Builder 패턴을 사용할수 있다. 
@Value
public class Sample{
  private String name;

  @Builder
  public Sample(String name){
    this.name = name;
  }
}

@Synchronized

@Log
                      </code>
                    </pre>
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  Fluent builder api
                </div>
                <div class="card-body">
                  <h5 class="card-title">Fluent builder api</h5>
                  <p class="card-text">
                    우리는 어플리케이션을 구성시에 도메인에 따라서 parent-child 관계로 구성할 수 있다. 
                    Context의 상속 구조는 다수의 자식이 Parent Context에 Bean을 공유할 수 있다는 것을 의미한다. 
                    <hr>
                    SpringApplicationBuilder 는 context 사이에 부모-자식 관계를 구성하기 위해서 fluent API를 제공한다. 

                    <ul>
                      <li>
                        SpringApplicationBuilder를 이용하면 SpringApplication의 세부 사항들을 조절 할 수 있다. ApplicationContext의 구현체를 지정하거나 ApplicationListener 등도 조정 가능하다.
                      </li>
                      <li>
                        스프링부트의 AutoConfiguration 기능은 여러 오픈 소스들을 지원하고 기본적인 설정등을 해준다.
                      </li>
                    </ul>
                    <hr>
                    Fluent API : 함수들을 작성하고 나면, 마치 그 문장이 영어 문장 처럼 읽히는 API를 말합니다. <br>
                    소프트웨어 공학에서 플루언트 인터페이스(fluent interface)는 메소드 체이닝에 상당 부분 기반한 객체 지향 API 설계 메소드이며, 소스 코드의 가독성을 산문과 유사하게 만드는 것이 목적이다. 특히 인터페이스 안에 도메인 특화 언어를 작성한다. 에릭 에반스와 마틴 폴러가 처음 만든 용어이다. JMock 테스팅 프레임워크에서 유연한 테스트 예측의 예는 다음과 같다:
                    <pre>
                      <code>
mock.expects(once()).method("m").with( or(stringContains("hello"),
stringContains("howdy")) );                        
                      </code>
                    </pre>
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  Application Events and Listeners 
                </div>
                <div class="card-body">
                  <h5 class="card-title">Application Events and Listeners </h5>
                  <p class="card-text">
                    
                    <ul>
                      <li>ApplicationStartedEvent
                        <hr>
                        run이 시작시 전송된다. 
                        <pre class="java" >
                          <code>
package com.lines.springeventlisteners.listeners;

import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Configuration
public class StartListener {

    @EventListener(ApplicationStartedEvent.class)
    public void eventListenerStart(){
        System.out.println("Application Start Event");
    }
}
                            
                          </code>
                        </pre>
                      </li>
                      <li>ApplicationEnvironmentPreparedEvent
                        <hr>
                        컨텍스트에 알려진 Evironment가 사용될 때 전송된다. 그러나 컨텍스트 생성 전이다. 
                      </li>
                      <li>ApplicationPreparedEvent
                        <hr>
                        컨텍스트 리프레쉬 전에 전송된다. 빈 정의가 다 로딩된 시점이다. 

                      </li>
                      <li>
                        ContextRefreshedEvent
                        <hr>
                        Application Context가 갱신되었을 때 실행된다. ( Refreshed 되었을 때 )
                        <pre class="java" >
                          <code>
package com.lines.springeventlisteners.listeners;

import com.lines.springeventlisteners.beans.EventHolderBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;

@Component
public class ContextRefreshedListener implements ApplicationListener&lt;ContextRefreshedEvent> {

    private EventHolderBean eventHolderBean;

    @Autowired
    public void setEventHolderBean(EventHolderBean eventHolderBean){
        this.eventHolderBean = eventHolderBean;
    }

    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        System.out.println("ContextRefreshedListener");

        this.eventHolderBean.setEventFired(true);
    }
}
                            
                          </code>
                        </pre>
                      </li>
                      <li>ApplicationFailedEvent
                        <hr>
                        스타트업에 실패시 전송된다. 
                      </li>
                      <li>ApplicationReadyEvent
                        <hr>
                        스타트업 후 준비 완료시 전송된다. 
                        <pre class="java">
                          <code>
package com.lines.springeventlisteners.listeners;

import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.event.EventListener;

@Configuration
public class ReadyListener {

    @EventListener(ApplicationReadyEvent.class)
    public void EventListenerExecute(){
        System.out.println("Application Ready Event");
    }
}                            
                          </code>
                        </pre>
                      </li>
                    </ul>
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  CommandLineRunner 
                </div>
                <div class="card-body">
                  <h5 class="card-title"></h5>
                  <p class="card-text">
                      CommandLineRunner 를 이용하면 Sprng Application 이 기동될 때 필요한 특정 코드를 동작시킬수 있다. 
                      <pre class="java" >
                        <code>
@Bean
CommandLineRunner createException() {
  return args -> Integer.parseInt("test") ;
}
                        </code>
                      </pre>
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  Application exit/Destroy
                </div>
                <div class="card-body">
                  <h5 class="card-title"></h5>
                  <p class="card-text">
                    각 SpringApplication은 ApplicationContext가 종료될때  shutdown hook을 등록할 수 있다. 
                    모든 표준 스프링 라이프사이클 콜백( DisposableBean 이나 PreDestory)를 사용할 수 있다. 
                    <pre class="java" >
                      <code>
@Bean
ExitCodeExceptionMapper exitCodeToexceptionMapper() {
  return exception -> { // set exit code base on the exception type
      if (exception.getCause() instanceof NumberFormatException) {
        return 22;
      }
      return 1;
  };
}


@Component
public class DestoryEvent {

    //소멸 메소드
    @PreDestroy
    public void destory(){
        System.out.println("종료 직전!!");
    }
}
                      </code>
                    </pre>
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  Spring에서 Event 실행하기 
                </div>
                <div class="card-body">
                  <h5 class="card-title">일반적인 방식</h5>
                  <p class="card-text">
                    <pre class="java" >
                      <code>
CustomSpringEventPublisher customSpringEventPublisher = configurableApplicationContext.getBean(CustomSpringEventPublisher.class);

customSpringEventPublisher.doStuffAndPublishAnEvent("이벤트 실행!");


package com.lines.springeventlisteners.event.basic;

import org.springframework.context.ApplicationEvent;

public class CustomSpringEvent extends ApplicationEvent {

    private String message;

    public CustomSpringEvent(Object source, String message) {
        super(source);

        this.message = message;
    }

    public String getMessage() {
        return message;
    }
}

package com.lines.springeventlisteners.event.basic;

import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class CustomSpringEventListener implements ApplicationListener&lt;CustomSpringEvent> {
    @Override
    public void onApplicationEvent(CustomSpringEvent event) {
        System.out.println("Received spring custm event - " + event.getMessage());
    }
}

package com.lines.springeventlisteners.event.basic;

import org.springframework.context.ApplicationListener;
import org.springframework.stereotype.Component;

@Component
public class CustomSpringEventListener2 implements ApplicationListener&lt;CustomSpringEvent> {
    @Override
    public void onApplicationEvent(CustomSpringEvent event) {
        System.out.println("Received spring custm event - " + event.getMessage());
    }
}

                      </code>                      
                    </pre>
                  </p>
                  <h5 class="card-title">Generic을 이용한 방식</h5>
                  <p class="card-text">
                    <pre class="java" >
                      <code>
GenericCustomSpringEventPublisher genericSpringEventPublisher = configurableApplicationContext.getBean(GenericCustomSpringEventPublisher.class);

genericSpringEventPublisher.doStuffAndPublishAnEvent(new PrintCommand(), true);

package com.lines.springeventlisteners.event.custom;

import com.lines.springeventlisteners.command.Command;

public class GenericCommandSprintAppEvent extends GenericSpringEvent&lt;Command>
{
    public GenericCommandSprintAppEvent(Command what, boolean success) {
        super(what, success);
    }
}

package com.lines.springeventlisteners.event.custom;

public class GenericSpringEvent&lt;T> {

    private T what;
    protected boolean success;

    public GenericSpringEvent(T what, boolean success) {
        this.what = what;
        this.success = success;
    }

    public T getWhat() {
        return what;
    }

    public boolean isSuccess() {
        return success;
    }
}

package com.lines.springeventlisteners.event.custom;

import com.lines.springeventlisteners.command.Command;
import org.springframework.context.event.EventListener;
import org.springframework.stereotype.Component;

@Component
public class GenericSpringEventListener  {

    @EventListener
    public void handleSuccessful(GenericCommandSprintAppEvent event) {
        Command command = event.getWhat();

        command.execute();
    }
}

package com.lines.springeventlisteners.command;

public interface Command {

    public void execute();
}

package com.lines.springeventlisteners.command.impl;

import com.lines.springeventlisteners.command.Command;

public class PrintCommand implements Command {

    @Override
    public void execute() {
        System.out.println("나는 출력된다. ");
    }
}
                      </code>
                    </pre>
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  Spring Bean Lifecycle 
                </div>
                <div class="card-body">
                  <h5 class="card-title">기본적인 annotation에 의한 초기화, 종료 이벤트 </h5>
                  <p class="card-text">
                    <pre class="java" >
                      <code>
package com.lines.springeventlisteners.lifecycle;

import org.springframework.stereotype.Component;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;

@Component
public class DestoryEvent {

    @PostConstruct
    public void init(){
        System.out.println("초기화 메소드!!");
    }

    //소멸 메소드
    @PreDestroy
    public void destory(){
        System.out.println("종료 직전!!");
    }
}
                        
                      </code>
                    </pre>
                  </p>
                  <h5 class="card-title"> Bean에 의한 Destory, Init 방식</h5>
                  <p class="card-text">
                    <pre class="java" >
                      <code>
@Bean(destroyMethod = "destroy")
public LifeCycle lifeCycle(){
  return new LifeCycle();
}

package com.lines.springeventlisteners.lifecycle;

public class LifeCycle {
    public void destroy() throws Exception {
        System.out.println("destroy");
    }
}                        
                      </code>
                    </pre>
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  
                </div>
                <div class="card-body">
                  <h5 class="card-title"></h5>
                  <p class="card-text">
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  
                </div>
                <div class="card-body">
                  <h5 class="card-title"></h5>
                  <p class="card-text">
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  
                </div>
                <div class="card-body">
                  <h5 class="card-title"></h5>
                  <p class="card-text">
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  
                </div>
                <div class="card-body">
                  <h5 class="card-title"></h5>
                  <p class="card-text">
                  </p>
                </div>
              </div>
              <div class="card">
                <div class="card-header">
                  
                </div>
                <div class="card-body">
                  <h5 class="card-title"></h5>
                  <p class="card-text">
                  </p>
                </div>
              </div>
            </div>
            <div class="card-footer small text-muted"></div>
          </div>
        <!-- /.container-fluid -->
        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
    

    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Page level plugin JavaScript-->
    <script src="../vendor/chart.js/Chart.min.js"></script>

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>

    <!-- Demo scripts for this page-->
    <script src="../js/demo/chart-area-demo.js"></script>
    <script src="../js/demo/chart-bar-demo.js"></script>
    <script src="../js/demo/chart-pie-demo.js"></script>

  </body>

</html>
