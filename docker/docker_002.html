<!DOCTYPE html>
<html lang="en">

  <head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="description" content="">
    <meta name="author" content="">

    <title>1lines - Docker</title>

    <!-- Bootstrap core CSS-->
    <link href="../vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

    <!-- Custom fonts for this template-->
    <link href="../vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">

    <!-- Page level plugin CSS-->
    <link href="../vendor/datatables/dataTables.bootstrap4.css" rel="stylesheet">

    <!-- Custom styles for this template-->
    <link href="../css/sb-admin.css" rel="stylesheet">
    <link rel="stylesheet" href="../styles/default.css">
    <script src="../highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>

  <body id="page-top">

    <nav class="navbar navbar-expand navbar-dark bg-dark static-top">

      <a class="navbar-brand mr-1" href="index.html">1 Lines</a>

      <button class="btn btn-link btn-sm text-white order-1 order-sm-0" id="sidebarToggle" href="#">
        <i class="fas fa-bars"></i>
      </button>

      <!-- Navbar Search -->
      

      <!-- Navbar -->
      

    </nav>

    <div id="wrapper">

      <!-- Sidebar -->
      <ul class="sidebar navbar-nav">
        <li class="nav-item">
          <a class="nav-link" href="index.html">
            <i class="fas fa-fw fa-tachometer-alt"></i>
            <span>요약</span>
          </a>
        </li>
        <li class="nav-item dropdown">
          <a class="nav-link dropdown-toggle" href="#" id="pagesDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
            <i class="fas fa-fw fa-folder"></i>
            <span>목록</span>
          </a>
          <div class="dropdown-menu show" aria-labelledby="pagesDropdown">
            <h6 class="dropdown-header">Docker</h6>
            <a class="dropdown-item" href="../docker/docker_001.html">Docker Basics</a>
            <a class="dropdown-item" href="../docker/docker_002.html">Docker File</a>
            <a class="dropdown-item" href="../docker/docker_003.html">Docker Do It!</a>
            <a class="dropdown-item" href="../docker/docker_004.html">Linux For Docker</a>
            <a class="dropdown-item" href="../docker/docker_005.html"></a>
            <a class="dropdown-item" href="../docker/docker_006.html"></a>
            <a class="dropdown-item" href="../docker/docker_007.html"></a>
            <a class="dropdown-item" href="../docker/docker_008.html"></a>          
            <a class="dropdown-item" href="../docker/docker_009.html"></a>
            <a class="dropdown-item" href="../docker/docker_010.html"></a>
            <a class="dropdown-item" href="../docker/docker_011.html"></a>
            <a class="dropdown-item" href="../docker/docker_012.html"></a>
            <a class="dropdown-item" href="../docker/docker_013.html"></a>
            <a class="dropdown-item" href="../docker/docker_014.html"></a>
            <a class="dropdown-item" href="../docker/docker_015.html"></a>
            <a class="dropdown-item" href="../docker/docker_016.html"></a>
            <a class="dropdown-item" href="../docker/docker_017.html"></a>
            <a class="dropdown-item" href="../docker/docker_018.html"></a>
            <a class="dropdown-item" href="../docker/docker_019.html"></a>
            <a class="dropdown-item" href="../docker/docker_020.html"></a>
            <a class="dropdown-item" href="../docker/docker_021.html"></a>
            <a class="dropdown-item" href="../docker/docker_022.html"></a>
            <a class="dropdown-item" href="../docker/docker_023.html"></a>
            <a class="dropdown-item" href="../docker/docker_024.html"></a>
            <a class="dropdown-item" href="../docker/docker_025.html"></a>
            <a class="dropdown-item" href="../docker/docker_026.html"></a>
            <a class="dropdown-item" href="../docker/docker_027.html"></a>
            <a class="dropdown-item" href="../docker/docker_028.html"></a>
            <a class="dropdown-item" href="../docker/docker_029.html"></a>
            <a class="dropdown-item" href="../docker/docker_030.html"></a>
            <a class="dropdown-item" href="../docker/docker_031.html"></a>
            <a class="dropdown-item" href="../docker/docker_032.html"></a>
            <a class="dropdown-item" href="../docker/docker_033.html"></a>
          </div>
        </li>
      </ul>

      <div id="content-wrapper">
        <div class="container-fluid">
          <!-- Breadcrumbs-->
          <ol class="breadcrumb">
            <li class="breadcrumb-item">
              <a href="#">Dashboard</a>
            </li>
            <li class="breadcrumb-item active">Docker File</li>
          </ol>

          <!-- Area Chart Example-->
          <div class="card mb-3">
            <div class="card-header">
                Docker File
            </div>
            <div class="card-body">
              <a href="https://docs.docker.com/engine/reference/builder/" target="_blank" >Docker File에 대해서</a>
              <hr>
              <ul>
                <li>
                  Docker file과 같은 디렉터리에 들어 있는 모든 파일을 컨텍스트 (Context)라고 합니다. 특히 이미지를 생성할 때 컨텍스트를 모두 Docker 데몬에 전송하므로 필요 없는 파일이 포함되지 않도록 주의 합니다.  <br>
                  컨텍스트에서 파일이나 디렉터리를 제외하고 싶을 때는 .dockerimage 파일을 사용하면 됩니다. <br>
                  .dockerignore 
                  <pre>
                    <code script="shell" >
.dockerignore 
 example/hello.txt 
 example/*.cpp 
 wo* 
 *.cpp 
 .git 
 .svn                      
                    </code>
                  </pre>
                </li>
                <li>FROM
                  <hr>
                  <pre>
                    <code class="shell" >
FROM &lt;image>:&lt;tag>
FROM ubuntu:16.04
                    </code>
                  </pre>
                  <hr>
                  베이스 이미지를 지정합니다. 반드시 지정해야 하며 어떤 이미지도 베이스 이미지가 될 수 있습니다. tag는 될 수 있으면 latest(기본값)보다 구체적인 버전(16.04등)을 지정하는 것이 좋습니다. 이미 만들어진 다양한 베이스 이미지는 Docker hub에서 확인할 수 있습니다.
                  <hr>
                  FROM은 어떤 이미지를 기반으로 이미지를 생성할지 설정합니다. Dockerfile로 이미지를 생성할 때는 항상 기존에 있는 이미지를 기반으로 생성하기 때문에 FROM은 반드시 설정해야합니다. <br>
                  FROM &lt;이미지>:&lt;태그> <br>
                  앞에서 설명한 것 처럼  FROM 은 항상 설정해야 하고 맨 처음에 와야 합니다. <br>
                  <hr>
                  <br>

                </li>
                <li>MAINTAINER
                    <hr>
                    <pre>
                      <code class="shell" >
MAINTAINER &lt;name>
MAINTAINER subicura@subicura.com
                      </code>
                    </pre>
                  <hr>
                  Dockerfile을 관리하는 사람의 이름 또는 이메일 정보를 적습니다. 빌드에 딱히 영향을 주지는 않습니다. <br>
                  MAINTAINER &lt;작성자 정보> 형식으로 생략할 수 있습니다. 
                  <hr>
                </li>
                <li>
                  RUN
                  <hr>
                  RUN 은 FROM 에서 설정한 이미지 위에서 스크립트 혹은 명령을 실행합니다. 여기서 RUN 으로 실행한 결과가 새 이미지로 생성되고, <br>
                  실행 내역은 이미지의 히스토리에 기록됩니다. 
                  <pre>
                      <code class="shell" >
RUN &lt;command>
RUN ["executable", "param1", "param2"]
RUN bundle install
                    </code>
                  </pre>  
                  가장 많이 사용하는 구문입니다. 명령어를 그대로 실행합니다. 내부적으로 /bin/sh -c 뒤에 명령어를 실행하는 방식입니다.

                  <pre>
                    <code class="shell" >
# bin/sh 로 명령 실행하기 
> Dockerfile 
RUN apt-get install -y nginx 
RUN echo "Hello Docker " > /tmp/hello 
RUN curl -sSL https://golang.org/dl/go1.3.1.src.tar.gz | tar -v -C /usr/local -xz 
RUN git clon https://github.com/docker/docker.git 
                    </code>
                  </pre>
                  위와 샘플과 같이 셸 스크립트 구문을 사용할 수 있습니다. FROM으로 설정한 이미지에 포함된 /bin/sh 실행 파일을 사용하게 되며, /bin/sh 실행 파일이 없으면 사용할 수 없습니다. 
                  <hr>
                  셀 없이 바로 실행하기 
                  <pre>
                    <code class="shell" >
RUN ["apt-get", "install", "-y", "nginx"]
RUN ["/usr/local/bin/hello", "--help"]
                    </code>
                  </pre>
                  RUN [ "&lt;실행파일>", "&lt;매개변수1>", "&lt;매개변수2>" ] 형식이다. <br>
                  FROM 으로 설정한 이미지의 bin/bash 실행 파일을 사용하지 않는 방식이다. 
                  <hr>
                  <br>
                </li>
                <li>CMD
                  <hr>
                  <pre>
                    <code class="shell" >
CMD ["executable","param1","param2"]
CMD command param1 param2
CMD bundle exec ruby app.rb
                    </code>
                  </pre>                    
                  <hr>
                   도커 컨테이너가 실행되었을 때 실행되는 명령어를 정의합니다. 빌드할 때는 실행되지 않으며 여러 개의 CMD가 존재할 경우 가장 마지막 CMD만 실행됩니다. <br>
                  한꺼번에 여러 개의 프로그램을 실행하고 싶은 경우에는 run.sh파일을 작성하여 데몬으로 실행하거나 supervisord나 forego와 같은 여러 개의 프로그램을 <br>
                  실행하는 프로그램을 사용합니다.
                  <hr>
                  <pre>
                    <code class="shell" >
CMD touch /home/hello/hello.txt 
                    </code>
                  </pre>
                  CMD &lt;명령> 형식이며 셸 스크립트 구분을 사용할 수 있습니다. <br>
                  FROM 으로 설정한 이미지에 포함된 bin/sh 실행파일을 사용하게 되며 /bin/sh 실행 파일이 없으면 사용할 수 없습니다. 
                  <hr>
                  셸 없이 바로 실행하기 
                  <pre>
                    <code class="shell" >
CMD ["redis-server"]
                    </code>
                  </pre>
                  <hr>
                  셸 없이 실행할 때 매개 변수 설정하기 
                  <pre>
                    <code class="shell" >
CMD ["mysql", "--datadir=/var/lib/mysql" , "--user=mysql"]
                    </code>
                  </pre>
                  위의 방식은 FROM 이미지로 부터 bin/sh를 사용하지 않는 방식입니다. 
                  <hr>
                  ENTRYPOINT를 사용하였을 때 
                  <pre>
                    <code class="shell" >
ENTRYPOINT ["echo"]
CMD ["hello"]
                    </code>
                  </pre>
                  ENTRYPOINT 에 설정한 명령에 매개변수를 전달하여 실행합니다. DockerFile에 ENTRYPOINT가 있으면 CMD는 ENTRYPOINT에 매개 변수만 전달하는 역할을 <br>
                  합니다. 그래서 CMD 독자적으로 파일을 실행할 수 없게 됩니다. 
                  <hr>
                </li>
                <li>
                  ENTRYPOINT
                  <hr>
                  ENTRYPOINT는 컨테이너가 시작되었을 때 스크립트 혹은 명령을 실행합니다. <br>
                  즉 docker run 명령으로 컨테이너를 생성하거나, docker start 명령으로 정지된 컨테이너를 시작할 때 실행됩니다. <br>
                  ENTRYPOINT는 Dockerfile에서 단 한번만 사용할 수 있습니다. 
                  <hr>
                  셸(/bin/sh)로 명령 실행하기 
                  <pre>
                    <code class="shell" >
ENTRYPOINT touch /home/hello/hello.txt 
                    </code>
                  </pre> 
                  ENTRYPOINT &lt;명령> 형식이며 셸 스크립트 구문을 사용할 수 있습니다. <br>
                  FROM으로 설정한 이미지에 포함된 /bin/sh 실행 파일을 사용하게 되며 /bin/sh 파일이 없으면 사용할 수 없습니다. 
                  <hr>
                  셸(/bin/sh) 없이 바로 명령 실행하기
                  <pre>
                    <code class="shell" >

ENTRYPOINT [ "/home/hello/hello.sh"]

ENTRYPOINT [ "/home/hello/hello.sh", "--hello=1". "--world=2"]

                    </code>
                  </pre>
                  ENTRYPOINT ["/home/hello/hello.sh", "--hello=1", "--world=2"] 형식 <br>
                  <pre>
                    <code class="shell" >
FROM ubuntu:latest 
CMD ["echo", "hello"]

# 컨테이너를 생성할 때 docker run &lt;이미지> &lt;실행할 파일> 형식인데 이미지 다음에 실행할 파일을 설정할 수 있습니다. 
# docker run 명령에서 실행할 파일을 설정하면 CMD는 무시됩니다. 

$ docker build --tag example . 
$ docker run example echo world 

# CMD ["echo", "hello"] 는 무시되고 docker run 명령에서 설정한 echo world가 실행되어 world 가 출력되었습니다. 
# docker run 명령에서 설정한 &lt;실행한 파일>과 Dockerfile의 CMD는 같은 기능입니다. 

# ENTRY POINT의 경우 
FROM ubuntu:latest 
ENTRYPOINT [ "echo", "hello" ]

# ENTRYPOINT [ "echo", "hello" ] 에서 echo hello가 실행되어 hello가 출력되고, docker run 명령에서 설정한 내용이 
# ENTRYPOINT [ "echo", "hello" ] 의 매개 변수로 처리되어 echo world 도 함께 출력됩니다. 

$ echo hello echo world 

$ docker run example 1 2 3 4

# ENTRYPOINT 는 docker run 명령에서 --entrypoint 옵션으로 설정할 수 있습니다. 

# --entrypoint 옵션을 설정하면 Dockerfile에 설정한 ENTRYPOINT 무시 
$ docker run --entrypoint="cat" example /etc/hostname 

                    </code>
                  </pre>

                </li>
                <li>EXPOSE
                  <hr>
                  <pre>
                    <code class="shell" >
EXPOSE &lt;port> [&lt;port>...]
EXPOSE 4567
                    </code>
                  </pre>
                  <hr>
                  도커 컨테이너가 실행되었을 때 요청을 기다리고 있는(Listen) 포트를 지정합니다. 여러개의 포트를 지정할 수 있습니다.
                  <hr>
                  EXPOSE는 호스트와 연결할 포트 번호를 설정합니다. docker run 명령의 --expose 옵션과 동일합니다. 
                  <pre>
                    <code class="shell" >
#EXPOSE &lt;포트 번호> 형식입니다. EXPOSE 하나로 포트번호를 두 개 이상 동시에 설정할 수도 있습니다. 
#EXPOSE는 호스트와 연결만 할 뿐 외부에 노출은 되지 않습니다. 호트를 외부에 노출하려면 docker run 명령의 -p, -P 옵션을 사용해야합니다. 

EXPOSE 80
EXPOSE 443

EXPOSE 80 443 
                    </code>
                  </pre>
                </li>
                <li>ENV
                  <hr>
                  <pre>
                    <code class="shell" >
ENV &lt;key> &lt;value>
ENV &lt;key>=&lt;value> ...
ENV DB_URL mysql
                    </code>
                  </pre>   
                  <hr>
                  컨테이너에서 사용할 환경변수를 지정합니다. 컨테이너를 실행할 때 -e옵션을 사용하면 기존 값을 오버라이딩 하게 됩니다. <br>
                  ENV로 설정한 환경 변수는 RUN, CMD, ENTRYPOINT에 적용됩니다. 
                  <pre>
                    <code class="shell">
ENV GOPATH /go 
ENV PATH /go/bin:$PATH 
# ENV &lt;환경변수> &lt;값> 형식입니다. 환경 변수를 사용할 때는 $를 사용하면 됩니다. 

# ENV에서 설정한 환경 변수를 CMD로 출력합니다. 

ENV HELLO 1234 
CMD echo $HELLO 

# Dockerfile을 빌드하여 docker run 명령으로 실행 
$ docker build --tag example . 
$ docker run example 

# ENV에서 설정한 HELLO 의 값 1234가 출력됩니다. 환경 변수는 docker run 명령에서도 설정할 수 있음 . 
# -e &lt;환경 변수>=&lt;값> 형식으로 -e 옵션은 여려번 사용할 수 있고, --env 옵션과 같습니다. 
docker run -e HELLO=4321 example 

                    </code>
                  </pre>
                </li>
                
                <li>ADD
                    <hr>
                      <pre>
                        <code class="shell" >
  ADD &lt;src>... &lt;dest>
  ADD . /usr/src/app
                        </code>
                      </pre>  
                    <hr>
                    COPY명령어와 매우 유사하나 몇가지 추가 기능이 있습니다. src에 파일 대신 URL을 입력할 수 있고 src에 압축 파일을 입력하는 경우 자동으로 압축을 해제하면서 복사됩니다. <br>
                    파일을 이미지에 추가합니다. 
                    <pre>
                      <code class="shell" >
# Dockerfile 
# ADD &lt;복사할 파일 경로> &lt;이미지에서 파일이 위치한 경로> 형식 
ADD hello-entrypoint.sh /entrypoint.sh 
ADD hello-dir /hello-dir 
ADD zlib-1.2.8.tar.gz / 
ADD hello.zip / 
ADD http://example.com/hello.txt /hello.txt 
ADD *.txt /root/
                      </code>
                    </pre>
                    <hr>
                    &lt;복사할 파일 경로> 는 컨텍스트 아래를 기준으로 하여 컨텍스트 바깥의 파일, 디렉터리나 절대 경로는 사용할 수 없다. <br>
                    <hr>
                    &lt;복사할 파일 경로> 는 파일 뿐만 아니라 디렉터리도 설정할 수 있으며, 디렉터리를 지정하면 디렉터리의 모든 파일을 복사합니다. 또한, 와일드카드를 사용하여 특정 파일만 복사할 수 있습니다. <br>
                    <hr>
                    &lt;복사할 파일 경로> 에 인터넷이 있는 파일의 URL을 설정할 수 있습니다. <br>
                    <hr>
                    로컬에 있는 압축 파일(tar.gz, tar.bz2, tar.xz ) 은 압축을 해제하고 tar를 풀어서 추가됩니다. 단, 인터넷에 있는 파일 URL은 압축만 해제한 뒤 tar 파일이 그대로 추가됩니다. 
                    <hr>
                    이미지에서 파일이 위치할 경로>는 항상 절대 경로를 설정해야 합니다. 그리고 마지막이 /로 끝나면 디렉터리가 생성되고 파일은 그 아래에 복사됩니다. 
                    <hr>
                    ADD ./ /hello 와 같이 현재 디렉터리를 추가할 때 .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다. 
                  </li>
                  <li>COPY
                    <hr>
                    <pre>
                        <code class="shell" >
COPY &lt;src>... &lt;dest>
COPY . /usr/src/app
                        </code>
                      </pre>                  
                    <hr>
                    파일이나 디렉토리를 이미지로 복사합니다. 일반적으로 소스를 복사하는 데 사용합니다. target디렉토리가 없다면 자동으로 생성합니다.  <br>
                    ADD와는 달리 압축 파일을 추가할 때 압축을 해제하지 않고, 파일 URL도 사용할 수 없습니다. 
                    <pre>
                      <code class="shell" >
COPY hello-entrypoint.sh /entrypoint.sh 
COPY hello-dir /hello-dir 
COPY zlib-1.2.8.tar.gz /zlib-1.2.8.tar.gz 
COPY *.txt /root/ 
                      </code>
                    </pre>
                    <hr>
                    &lt;복사할 파일 경로>는 컨텍스트 아래를 기준으로 하며 컨텍스트 바깥의 파일, 디렉터리나, 절대 경로는 사용할 수 없습니다. 
                    <hr>
                    &lt;복사할 파일 경로>는 파일 뿐만 아니라 디렉터리도 설정할 수 있으며, 디렉터리를 지정하면 디렉터리의 모든 파일을 복사합니다. 또한 와일드 카드를 사용하여 특정 파일만 복사할 수 있습니다. 
                    <hr>
                    &lt;복사할 파일 경로>에 인터넷에 있는 파일의 URL을 사용할 수 없습니다. 
                    <hr>
                    &lt;이미지에서 파일이 위치할 경로>는 항상 절대 경로로 설정해야합니다. 그리고 마지막이 / 로 끝나면 디렉토리가 생성되고 파일은 그 아래에 복사됩니다. 
                    <hr>
                    COPY ./ /hello와 같이 현재 디렉터리를 추가할 때 .dockerignore 파일에 설정한 파일과 디렉터리는 제외됩니다. 
                  </li>
                  <li>VOLUME
                    <hr>
                    <pre>
                      <code class="shell" >
VOLUME ["/data"]
                      </code>
                    </pre>                  
                    <hr>
                    컨테이너 외부에 파일시스템을 마운트 할 때 사용합니다. 반드시 지정하지 않아도 마운트 할 수 있지만, 기본적으로 지정하는 것이 좋습니다. <br>
                    VOLUME는 디렉터리의 내용을 컨테이너에 저장하지 않고 호스트에 저장하도록 설정합니다. 
                    <pre>
                      <code class="shell" >
VOLUMN /data 
VOLUMN [ "/data", "/var/log/hello" ]
                      </code>
                    </pre>
                    VOLUME &lt;컨테이너 디렉터리> 또는 VOLUME ["컨테이너 디렉터리 1", "컨테이너 디렉터리 2" ] 형식 <br>
                    단, VOLUME 으로는 호스트의 특정 디렉터리와 연결할 수는 없습니다. 
                    <hr>
                    데이터 볼륨을 호스트의 특정 디렉터리와 연결하려면 docker run 명령에서 -v 옵션을 사용해야 합니다. 
                    <pre>
                      <code class="shell" >
docker run -v /root/data:/data example 
                      </code>
                    </pre>
                   
                  </li>
                  <li>
                    USER 
                    <hr>
                    USER는 명령을 실행할 사용자 계정을 설정합니다. RUN, CMD, ENTRYPOINT에 적용됩니다. 
                    <pre>
                      <code class="shell" >
USER nobody

# USER 뒤에 오는 모든 RUN, CMD, ENTRYPOINT 에 적용되며, 중간에 다른 사용자를 설정하여 사용자를 바꿀 수 있습니다. 
USER nobody # 여기부터는 nobody 계정으로 
RUN touch /tmp/hello.txt

USER root # 여기부터는 root 계정으로 
RUN touch /hello.txt 
ENTRYPOINT /hello-entrypoint.sh 
                      </code>
                    </pre>
                  </li>
                                  
                <li>WORKDIR
                    <hr>
                    WORKDIR 은 RUN, CMD, ENTRYPOINT 의 명령이 실행될 디렉터리를 설정합니다. <br>
                    WORKDIR 뒤에 오는 모든 RUN, CMD , ENTRYPOINT 에 적용되며, 중간에 다른 디렉터리를 설정하여 실행 디렉터리를 바꿀 수 있습니다. 
                    <pre>
                      <code>
WORKDIR /var/www                   
                      </code>
                    </pre>
                    <hr>
                    RUN, CMD, ADD, COPY등이 이루어질 기본 디렉토리를 설정합니다. 각 명령어의 현재 디렉토리는 한 줄 한 줄마다 초기화되기 때문에 RUN cd /path를 하더라도 다음 명령어에선 다시 위치가 초기화 됩니다. 같은 디렉토리에서 계속 작업하기 위해서 WORKDIR을 사용합니다.
                    <hr>
                    <pre>
                      <code class="shell" >
WORKDIR /root 
RUN touch hello.txt 

WORKDIR /tmp 
RUN touch hello.txt 
                      </code>
                    </pre>

                    WORKDIR 은 절대 경로 대신 상대 경로도 사용할 수 있습니다. 상대 경로를 사용하면 먼저 설정한 WORKDIR 의 경로를 기준으로 디렉터리를 변경합니다. 최초 기준으로 / 입니다. 

                    <pre>
                      <code class="shell" >
WORKDIR var 
WORKDIR www 

RUN touch hello.txt 
                      </code>
                    </pre>
                    상대 경로를 사용하여 / 에서 var로 이동한 뒤 www 로 이동했기 때문에 /var/www/hello.txt 에 파일이 생성됩니다. 
                    <hr>
                    <br>
                  </li>
                  <li>
                    ONBUILD 
                    <hr>
                    ONBUILD는 생성한 이미지를 기반으로 다른 이미지가 생성될 때 명령을 실행(trigger) 합니다. <hr>
                    최초에 ONBUILD를 사용한 상태에서는 아무 명령도 실행하지 않습니다. 다음 번에 이미지가 FROM으로 사용될 때 실행할 명령을 예약하는 기능이라고 할수 있습니다. 
                    <hr>
                    <pre>
                      <code>
ONBUILD RUN touch /hello.txt 
ONBUILD ADD world.txt /world.txt                         
                      </code>
                    </pre>
                    ONBUILD &lt;Dockerfile 명령> &lt;Dockerfile 명령의 매개변수> <br>
                    FROM, MAINTAINER, ONBUILD를 제외한 모든 Dockerfile 명령을 사용할 수 있습니다. 
                    <pre>
                      <code class="shell" >
FROM ubuntu:latest 
ONBUILD RUN touch /hello.txt 

$ docker build --tag example . 
$ docker run -i -t example /bin/bash 

# ONBUILD로 설정했기 때문에 example 이미지에서 /hello.txt 파일이 생성되지 않았습니다. 
# 이제 example 이미지를 기반으로 다시 생성해보면 

FROM example 

# docker build AUDFUDDMFH example2 이미지를 생성한 뒤 docker run 명령으로 컨테이너를 생성합니다. 
# 컨테이너의 Bash 셸이 실행되면 ls 명령으로 /의 파일 목록을 출력합니다. 

$ docker build --tag example2 . 

$ docker run -i -t example2 /bin/bash 

# ONBUILD는 바로 아래 자식 이미지를 생성할 때만 적용되고, 손자 이미지에는 적용되지 않습니다. 즉 ONBUILD 설정은 상속되지 않습니다. 
                      </code>
                    </pre>
                    <hr>
                      docker inspect 명령으로 이미지의 ONBUILD 설정을 확인 할 수 있습니다. <br>
                      $ sudo docker inspect -f "{{ .ConainerConfig.OnBuild }}" example <br>
                      [RUM touch /hello.txt]
                    <hr>
                  </li>
              </ul>
            </div>
            <div class="card-footer small text-muted"></div>
            </div>
        </div>
        <!-- /.container-fluid -->

        <!-- Sticky Footer -->
        <footer class="sticky-footer">
          <div class="container my-auto">
            <div class="copyright text-center my-auto">
              <span>Copyright © 1Lines Labs 2019</span>
            </div>
          </div>
        </footer>

      </div>
      <!-- /.content-wrapper -->

    </div>
    <!-- /#wrapper -->

    <!-- Scroll to Top Button-->
    <a class="scroll-to-top rounded" href="#page-top">
      <i class="fas fa-angle-up"></i>
    </a>

    <!-- Logout Modal-->
    

    <!-- Bootstrap core JavaScript-->
    <script src="../vendor/jquery/jquery.min.js"></script>
    <script src="../vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

    <!-- Core plugin JavaScript-->
    <script src="../vendor/jquery-easing/jquery.easing.min.js"></script>

    <!-- Page level plugin JavaScript-->
    <script src="../vendor/chart.js/Chart.min.js"></script>

    <!-- Custom scripts for all pages-->
    <script src="../js/sb-admin.min.js"></script>

    <!-- Demo scripts for this page-->
    <script src="../js/demo/chart-area-demo.js"></script>
    <script src="../js/demo/chart-bar-demo.js"></script>
    <script src="../js/demo/chart-pie-demo.js"></script>

  </body>

</html>
